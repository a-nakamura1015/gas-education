[
{
	"uri": "https://a-nakamura1015.github.io/gas-education/calendar/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "前提条件 GASの開発環境が整備されていること（Chapter1が完了していること） JavaScriptの基礎を理解していること（Chapter2が完了していること） 目標のゴール GASでGoogleカレンダーを操作できるようになること それではGoogleカレンダー編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/es2015/page_2_5_1/",
	"title": "let・const キーワード",
	"tags": [],
	"description": "",
	"content": "新しい変数の宣言 これまで変数を宣言する際は var キーワードを使用してきましたが、es2015からは let キーワードと const キーワードで宣言することができるようになりました。\nここでは、それぞれのキーワードで宣言した場合の違いについて学んでいきましょう。\n変数宣言の種類 これから var ・ let ・ const の違いを確認していきますが、今後のコーディングは以下の前提で行うようにしましょう。\n原則 const で宣言しましょう。 ループ処理などの変数を更新する場合に限っては let で宣言しましょう。 var では宣言しないようにしましょう。 以下の表は、var ・ let ・ const の違いを一覧にまとめたものです。\nvar let const 再宣言 可 不可 不可 再代入 可 可 不可 スコープの種類 関数スコープ ブロックスコープ ブロックスコープ 変数の巻き上げ undefined ReferenceError が発生する ReferenceError が発生する var キーワード var キーワードでの変数の再宣言・再代入 varキーワードで宣言した変数は再宣言・再代入をすることができます。\nコード.gs function var_pattern_1() { // var での再宣言 var value = 1; var value = 2; } function var_pattern_2() { // var での再代入 var value = 1; value = 2; } var キーワードでの変数のスコープ varキーワードで宣言したローカル変数は 関数スコープ となります。\n関数スコープの場合は関数内であれば宣言したブロックが異なっていても参照することができます。\nコード.gs function var_pattern_3() { let isLoop = true; while(isLoop){ // value 変数を宣言したのちループ処理を抜ける var value = 1; isLoop = false; } // ブロックスコープが適用されないため value 変数を参照できる console.log(value); // 1 } var キーワードでの変数の巻き上げ 先述の通り、 var キーワードで宣言されたローカル変数は同関数内であれば参照することができます。\n実は宣言の前からでも参照することができるのです。\nこの事象は「巻き上げ（hosting）」と呼ばれています。\n以下のサンプルコードでは、1回目のconsole.log()でパラメーターに value 変数を渡していますが、実行時点では value 変数は宣言されていません。\n実行してもエラーは発生しませんが、1回目のconsole.log()でログに表示されるのはundefinedとなります。\nコード.gs function var_pattern_4() { console.log(value); // undefined var value = 1; console.log(value); // 1 } 変数の巻き上げで注意すべきは巻き上げが発生してもエラーとして扱われない点です。\n変数の巻き上げに気づかず、そのまま処理を実行することにより期待しない処理が行われる可能性があります。\n一方、後述する let・const キーワードでローカル変数を宣言した場合は変数の巻き上げは発生せずエラーが発生します。\n変数の巻き上げを未然に防ぐためにも、変数は let・const キーワードで宣言するようにしましょう。\nJavaScriptでは関数内で宣言されたローカル変数は、すべてその関数の先頭で宣言されたものとみなされます。\nlet キーワード let キーワードの再宣言・再代入 letキーワードで宣言したローカル変数は再宣言することはできませんが、再代入することはできます。\nletキーワードで宣言したローカル変数を再宣言するようにコーディングすると、保存する際に JavaScript の文法が間違っているという意味の構文エラー（SyntaxError）が発生します。\nコード.gs function let_pattern_1() { // let での再宣言 // 保存時にエラー発生　構文エラー: SyntaxError: Identifier \u0026#39;value\u0026#39; has already been declared let value = 1; //let value = 2; } function let_pattern_2() { // let での再代入 let value = 1; value = 2; } let キーワードのスコープ letキーワードで宣言したローカル変数は ブロックスコープ となります。\nブロックスコープの場合はブロック内であれば宣言したローカル変数を参照することができますが、同じ関数であってもブロック外からは参照することができません。\nコード.gs function let_pattern_3() { let isLoop = true; while(isLoop) { // value 変数を宣言したのちループ処理を抜ける let value = 1; isLoop = false; } // ブロックスコープが適用されるため value 変数を参照できない // 実行時にエラー発生 ReferenceError: value is not defined console.log(value); } let キーワードの変数の巻き戻し let キーワードでローカル変数を宣言した場合は変数の巻き戻しは発生しません。\n代わりに実行する際に参照する変数が見つからないという意味の 参照エラー（ReferenceError）が発生します。\nコード.gs function let_pattern_4() { console.log(value); let value = 1; // 実行時にエラー発生 ReferenceError: Cannot access \u0026#39;value\u0026#39; before initialization console.log(value); } const キーワード const キーワードの再宣言・再代入 constキーワードで宣言したローカル変数は再宣言・再代入ができません。\nconst キーワードのスコープ constキーワードで宣言したローカル変数は、letキーワードと同じく ブロックスコープ となります。\nそのため、ブロック内であれば宣言したローカル変数を参照することができますが、同じ関数であってもブロック外からは参照することができません。\nコード.gs function const_pattern_3() { let isLoop = true; while(isLoop) { // value 変数を宣言したのちループ処理を抜ける const value = 1; isLoop = false; } // ブロックスコープが適用されるため value 変数を参照できない // 実行時にエラー発生 ReferenceError: value is not defined console.log(value); } const キーワードの変数の巻き戻し let キーワードと同様に、const キーワードでローカル変数を宣言した場合は変数の巻き戻しは発生しません。\n代わりに実行する際に参照する変数が見つからないという意味の 参照エラー（ReferenceError）が発生します。\nコード.gs function const_pattern_4() { console.log(value); const value = 1; // 実行時にエラー発生 ReferenceError: Cannot access \u0026#39;value\u0026#39; before initialization console.log(value); } "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "目標のゴール ローカル環境でGAS開発できるようになること それではローカル開発編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "前提条件 GASの開発環境が整備されていること（Chapter1が完了していること） JavaScriptの基礎を理解していること（Chapter2が完了していること） 目標のゴール GASでスプレッドシートを操作できるようになること それではスプレッドシート編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/object_mechanism/page_2_4_1/",
	"title": "オブジェクト",
	"tags": [],
	"description": "",
	"content": "オブジェクトとは オブジェクトは「物」や「対象」という意味ですが、\nプログラミングの世界では情報（属性）や機能を持ったデータの集合体という意味になります。\n配列もオブジェクトの一種になります。\n本章ではJavaScriptの「オブジェクト指向」の入り口にあたる部分について解説していきます。\n「オブジェクト指向」というと難しく見えてしまい、できれば避けたいと思うかもしれませんが、\nGASの各サービスはこのオブジェクトの仕組みに忠実に構成されています。\nつまり、JavaScriptのオブジェクトの仕組みが理解できているのとそうでないのとでは、これからのJavaScriptとGASの習得スピードと理解度に明らかな差が出てきます。\nプロパティとメソッドとは オブジェクトはプロパティと呼ばれるデータを持つことができます。\nプロパティは属性とも呼ばれ、データを管理する役割を果たすことができます。\nプロパティを理解するために、まずはオブジェクトの書式について確認してみましょう。\nオブジェクトは次のようなプロパティと値の組み合わせのデータの集合体です。\n以下のようなデータの集合体をJSON（JavaScript Object Notation）といいます。\n{ プロパティ１:値１, プロパティ２:値２ } プロパティに設定した値は以下のようにして取得することができます。\nオブジェクト名.プロパティ 実際にJSONを作ってみましょう。次の例は学業の成績データをオブジェクトにしてみました。\n成績データ（result）は各科目の点数を格納しており、\n国語（japanese）・数学（math）・英語（english）の点数を持っています。\nコード.gs function object_1() { var result = { japanese: 100, math: 80, english: 90 } console.log(result.japanese); console.log(result.math); console.log(result.english); } 100 80 90 プロパティは変数と同様に再代入することができます。\n次の例は成績データ（result）の国語（japanese）に0を再代入しています。\nコード.gs function object_2() { var result = { japanese: 100, math: 80, english: 90 } console.log(result.japanese); result.japanese = 0; console.log(result.japanese); } 100 0 おそらく、プログラミング初心者にとってはオブジェクト名.プロパティという記法が難しく感じられるかもしれません。\nそのような時は、.をのに置き換えるとしっくりくると思います。\n例えば、先程の例の成績データ（result）の国語（japanese）の点数を取得する際にresult.japaneseとコーディングしましたが、\nresultのjapanaseと置き換えるとどうでしょう？\nこうすると、成績データ（result）の国語（japanese）と読めるようになると思います。\n実は、JSONにはオブジェクトの値として関数を持たせることができます。\nこのように、オブジェクトの要素として関数を指定した場合は、その要素をプロパティとは呼ばずに メソッド と呼びます。\n以下のような要素がオブジェクトに含まれていれば、それがメソッドとなります。\nメソッド: function(仮引数１, 仮引数２, ...) { // 処理 return 戻り値; } メソッドとは、関数が格納されたプロパティのことです。\nプロパティを呼び出す場合と同様に、メソッドは以下のようにして呼び出すことができます。\nメソッドは関数のため、いくつかの引数を持つこともできます。\nオブジェクト名.メソッド(引数１, 引数２) では、下記のサンプルで確認していきましょう。myGreetオブジェクトのsayHelloというメソッドを用意して呼び出しています。\nコード.gs var myGreet = { sayHello: function() { return \u0026#39;Hello!\u0026#39;; } } function outputObj_1() { console.log(myGreet.sayHello()); } Hello! つまり、オブジェクトは 「情報」としてのプロパティ だけでなく、「機能」としてのメソッド を持つことができるのです。\nなお、プロパティとメソッドを総じて、オブジェクトの メンバー と呼びます。\nオブジェクトは、メンバーとしてプロパティとメソッドを持つことができます。\nメソッドの代入と追加 プロパティと同じく、メソッドも次のように代入することができます。オブジェクトに存在しないメソッドを代入すると、メソッドの追加になります。\nオブジェクト名.メソッド = function(仮引数１, 仮引数２, ...) { // 処理 return 戻り値; } myGreetオブジェクトにsayGoodByeメソッドを追加する処理を加えたものが次のサンプルです。\n実行すると、ログには「Good bye!」も出力され、追加したsayGoodByeメソッドが動作していることが確認できます。\nコード.gs var myGreet = { sayHello: function() { return \u0026#39;Hello!\u0026#39;; } } myGreet.sayGoodBye = function() { return \u0026#39;Good bye!\u0026#39; } function outputObj_2() { console.log(myGreet.sayHello()); console.log(myGreet.sayGoodBye()); } Hello! Good bye! "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/page_2_3_1/",
	"title": "宣言と呼び出し",
	"tags": [],
	"description": "",
	"content": "関数の呼び出し おさらいまでに、関数 とは一連の処理をひとつにまとめたものをいいます。\n関数については先ほどご紹介しているので下記を参考にしてください。\n関数とは これまでは関数を実行する際は、スクリプトエディタのツールバーの「関数を選択」のプルダウンで選択した関数から実行してきました。\n実は、関数は「関数を選択」で選択して実行するだけでなく、関数名で 別の関数から呼び出す ことができます。\n関数名() 次のサンプルは他の関数を呼び出す例です。myFunc_1を実行すると、ログには「おはようございます！」と「こんにちは！」、「こんばんは！」が出力されます。\nコード.gs function myFunc_1() { console.log(\u0026#39;おはようございます！\u0026#39;); myFunc_2(); // myFunc_2関数を呼び出す console.log(\u0026#39;こんばんは！\u0026#39;); } function myFunc_2() { console.log(\u0026#39;こんにちは！\u0026#39;); } おはようございます！ こんにちは！ こんばんは！ JavaScriptにおいて関数はオブジェクトとして扱われます。\nそのため、他のオブジェクトと同じように引数として関数に渡したり、変数に代入したりすることができます。\n重要なポイントとして押さえてほしいのは、関数の「呼び出し」と「参照」がしっかり区別されるということです。\n関数名に()をつけることでその関数の呼び出しとなり、関数が実行されて値が返されます。\n一方、()をつけずに関数名だけを書くと、その関数を参照しているだけになります。\nまた、関数は参照されるだけで実行されません。\n次の例はgetMessage()で関数の「呼び出し」を行い、\ngetMessageで関数の「参照」を行っています。\nこのように関数を呼び出さずに参照することができるのですが、\nこの関数の「参照」を利用することでオブジェクトとして扱うことができます。\n（オブジェクトについては次章 で解説します。）\nコード.gs function getMessage() { return \u0026#39;Hello!\u0026#39;; } console.log(getMessage()); // Hello! console.log(getMessage); // [Function: getMessage] 続いて、「変数（定数）への代入」を試してみましょう。\n関数を変数に代入することで、関数を別の名前で呼び出すことができます。\nコード.gs function getMessage() { return \u0026#39;Hello!\u0026#39;; } var message = getMessage; // 関数をmessage変数に代入 console.log(message()); // Hello! 同じプロジェクト内であれば、別のgsファイルに記述した関数も呼び出すことができます。\nこの例でわかるように、関数を呼び出した場合はその呼び出した関数の処理が完了した時点で元の関数に戻ります。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/page_2_2_1/",
	"title": "処理を分岐させる",
	"tags": [],
	"description": "",
	"content": "if文 JavaScriptではスクリプトを実行すると上から順番にステートメントを1つずつ処理していきます。\nしかし、コーディングを進めていくと処理を分岐させたい場面があります。\nこのような分岐処理を実現する命令の一つが if文 です。\nif文は「もし〇〇ならば〇〇する」という処理を実現することができます。構文は下記の通りです。\nif (条件式) { // 条件式がtrueの場合に実行する処理 } if文では丸括弧の中に条件式を記述します。\n条件式は判定の結果がtrueまたはfalseになる式です。\n条件式の結果がtrueであれば中括弧の中の処理が実行され、falseであれば中括弧の中の処理は実行されません。\n（この中括弧の中を ブロック といいます。）\n下記のサンプルを記述して実行してみましょう。\nコード.gs function outputBranch_1() { var x = 10; if (x \u0026gt; 1) { console.log(\u0026#39;xは1よりも大きいです。\u0026#39;); } } xは1よりも大きいです。 if else 文とelse if文 if文の条件式の結果がfalseだった場合に別の処理をさせたい場合は if else 文 を使用します。\nif (条件式) { // 条件式がtrueの場合に実行する処理 } else { // 条件式がfalseの場合に実行する処理 } 条件式がtrueの場合はifブロック内の処理が実行され、falseの場合はelseブロック内の処理が実行されます。\n下記はif else 文のサンプルになります。変数xに代入する値を変更しながら複数回実行して、意図したブロックの処理が実行されるか確認してみましょう。\nコード.gs function outputBranch_2() { var x = 10; if (x \u0026gt; 10) { console.log(\u0026#39;xは10よりも大きいです。\u0026#39;); } else { console.log(\u0026#39;xは10以下です。\u0026#39;); } } xは10以下です。 if else 文では、条件式がtrueかfalseかで処理を分岐することができます。\nまた、分岐を3つ以上にしたい場合は if else if文 を使うと必要な分だけ条件分岐の処理を作ることができます。\nif (条件式１) { // 条件式１がtrueの場合に実行する処理 } else if (条件式２) { // 条件式２がtrueの場合に実行する処理 ・・・ } else { // すべての条件式がfalseの場合に実行する処理 } 条件式１、条件式２と順番に条件式を判定していき、最初に条件式がtrueだった際に該当のブロック内の処理をします。\nまた、最後のelseは省略することができます。\n下記のサンプルを実行して、if else 文の動作を確認してみましょう。\nコード.gs function outputBranch_4() { var x = 10; if (x \u0026lt; 10) { console.log(\u0026#39;xは10よりも大きいです。\u0026#39;); } else if (x \u0026lt; 20) { console.log(\u0026#39;xは10以上で20よりも小さいです。\u0026#39;); } else { console.log(\u0026#39;xは20以上です。\u0026#39;); } } xは10以上で20よりも小さいです。 else if文でいくつでも条件分岐の処理を追加することができますが、あまりに多いと読みづらいコードになってしまいます。\nこの後登場する論理演算子やswitch文を活用したりして、else if文を多用することは避けるようにしましょう。\n比較演算子とは これまで登場した「\u0026lt;」は数学と同じく、左辺と右辺を比較して左辺の方が小さければ条件式としてtrueを返します。\nこのような条件式内で使用し、左辺と右辺を比較してtrue、またはfalseを返す役割を持つ演算子を 比較演算子 といいます。\nJavaScriptで使用できる比較演算子は下記の通りです。\n比較演算子 概要 使用例 == 左辺と右辺の値が等しい場合はtrue 10 == \u0026lsquo;10\u0026rsquo; != 左辺と右辺の値が等しくない場合はtrue 10 != 11 \u0026lt; 左辺が右辺より小さい場合はtrue 10 \u0026lt; 11 \u0026lt;= 左辺が右辺以下の場合はtrue 10 \u0026lt;= 11 \u0026gt; 左辺が右辺より大きい場合はtrue 10 \u0026gt; 9 \u0026gt;= 左辺が右辺以上の場合はtrue 10 \u0026gt;= 9 === 左辺と右辺が値もデータ型も等しい場合はtrue 10 === 10 !== 左辺と右辺が値もデータ型も等しくない場合はtrue 10 !== \u0026lsquo;10\u0026rsquo; この比較演算子には注意すべき点があります。\n下記のサンプルを実行するとログにはtrueとfalseのどちらが出力されるでしょうか？\nコード.gs function outputComparison_1() { var fruits_1 = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;]; var fruits_2 = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;]; console.log(fruits_1 == fruits_2); // false var person_1 = {name: \u0026#39;Taro\u0026#39;}; var person_2 = {name: \u0026#39;Taro\u0026#39;}; console.log(person_1 == person_2); // false } 出力されたログの結果は共にfalseになります。\n実は、配列やオブジェクトを変数に代入した場合に、実際に変数に格納されるのはメモリ上のアドレス（参照値）です。\nしたがって、要素や構造が全く同じであったとしても、物理的に別のアドレスに割り当てられている配列またはオブジェクト同士の比較はfalseとなります。\n一方で、下記のサンプルを実行するといずれのログもtrueとなります。\nそれぞれの変数に格納されているアドレスは等しいため比較結果はtrueとなります。\nコード.gs function outputComparison_2() { var fruits_1 = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;]; var fruits_2 = fruits_1; console.log(fruits_1 == fruits_2); // true var person_1 = {name: \u0026#39;Taro\u0026#39;}; var person_2 = person_1; console.log(person_1 == person_2); // true } 配列とオブジェクトの比較はその参照値の比較となります。\n寛容な比較と厳密な比較 「==」と「===」の違いと、「!=」と「!==」の違いについて確認していきましょう。\n等価演算子には通常の等価演算子（==）と厳密等価演算子（===）があります。\n「==」と「!=」はデータ型は考慮せずに値を比較しているのに対し、\n「===」と「!==」は比較の際にデータ型も考慮します。\n厳密等価演算子（===）で2つの値が「厳密等価」であると見なされるのは次のいずれかです。\n同じオブジェクトを参照しているとき プリミティブ型で、データ型も値も同じであるとき 一方、等価演算子（==）は厳密等価より緩い条件で評価します。\n同じオブジェクトを参照しているとき 「同じ値に変換される」とき 下記のサンプルでそれぞれの演算子の違いを確認していきましょう。\nコード.gs function outputComparison_3() { // 「==」と「===」の違い console.log(10 == \u0026#39;10\u0026#39;); // true console.log(10 === \u0026#39;10\u0026#39;); // false // 「!=」と「!==」の違い console.log(10 != \u0026#39;10\u0026#39;); // false console.log(10 !== \u0026#39;10\u0026#39;); // true } 「==」と「!=」は寛容な比較（データがを考慮しない）を行いますが、データ型を考慮しなかったために想定外の結果を引き起こす可能性があります。\nそのため、「===」と「!==」を使用する方がより安全に開発することができます。\n論理演算子とは if文の複数の条件式を同時に判定させたいケースがありますが、現時点では下記のように記述することができます。\nコード.gs function outputLogical_1() { var x = 11; if (10 \u0026lt; x) { if (x \u0026lt;= 20) { console.log(\u0026#39;xは10よりも大きく、20以下です。\u0026#39;); } } } xは10よりも大きく、20以下です。 このようにif文をネスト（入れ子）にすることで複数条件で判定することができますが、\n条件が増えるごとにネスト（入れ子）が増えていきどんどん複雑になっていきます。\n実は複数条件をシンプルに記述できる演算子があり、これを 論理演算子 といいます。\nJavaScriptで使用できる論理演算子は下記の通りです。\n論理演算子 概要 使用例 \u0026amp;\u0026amp; 左辺と右辺がいずれもtrueであればtrue x === 10 \u0026amp;\u0026amp; y === 100 || 左辺と右辺がいずかがtrueであればtrue x === 10 ! 条件式の結果を反転させる !(x === 10) この論理演算子を使用すると、先ほどのサンプルを下記のように記述することができます。\n他の論理演算子の結果と合わせて確認しましょう。\nコード.gs function outputLogical_2() { var x = 11; if (10 \u0026lt; x \u0026amp;\u0026amp; x\u0026lt;= 20) { console.log(\u0026#39;xは10よりも大きく、20以下です。\u0026#39;); } if (10 \u0026lt; x || x\u0026lt;= 20) { console.log(\u0026#39;xは10よりも大きい、または20以下です。\u0026#39;); } if (!(x \u0026lt; 10)) { console.log(\u0026#39;xは10より小さくないです。\u0026#39;); } } xは10よりも大きく、20以下です。 xは10よりも大きい、または20以下です。 xは10より小さくないです。 switch文 if文による条件分岐では、条件式がtrueかfalseかのどちらかしか分岐処理を記述することができません。\nそれ以上の分岐処理を行いたい場合は先ほど紹介したelse if文で追加することもできますが、\nあまりにも追加する条件式が多い場合は switch文 を使用するとよいでしょう。\nswitch文は、ある式が複数の値のいずれかと一致するかの判定を行うことができ、下記のような記述で実現することができます。\nswitch (式) { case 値１: // 式 === 値１であるときの処理 break; case 値２: // 式 === 値２であるときの処理 break; default: // 式がいずれの値にも一致しなかったときの処理 } switch文では、式の結果と一致する値を、値１、値２・・・の中から探します。\n一致する値が存在すれば、その case節 のステートメントの処理を順次実行していきます。\nbreak文 でswitch文から抜け出し、式の結果と一致する値が存在しなければ default節 のステートメントの処理を実行します。\n例として、下記のサンプルを実行してみましょう。\nfruit変数に代入されている値によって出力されるログの内容が変わりますので、fruit変数に代入する値を変えてみて複数回実行して確認してみましょう。\nコード.gs function outputBranch_5() { var fruit = \u0026#39;apple\u0026#39;; switch(fruit) { case \u0026#39;apple\u0026#39;: console.log(\u0026#39;りんご\u0026#39;); break; case \u0026#39;grape\u0026#39;: console.log(\u0026#39;グレープ\u0026#39;); break; case \u0026#39;orange\u0026#39;: console.log(\u0026#39;オレンジ\u0026#39;); break; default: console.log(\u0026#39;知らないフルーツです！\u0026#39;); } } りんご break文 各case節の処理の末尾にあるbreak文は省略することができますが、原則各case節ごとにbreak文を記述することになります。\nどうしてbreak文が必要なの？と思われるでしょうが、それは下記のサンプルを実行するとわかります。\nコード.gs function outputBranch_6() { var fruit = \u0026#39;apple\u0026#39;; switch(fruit) { case \u0026#39;apple\u0026#39;: console.log(\u0026#39;りんご\u0026#39;); case \u0026#39;grape\u0026#39;: console.log(\u0026#39;グレープ\u0026#39;); case \u0026#39;orange\u0026#39;: console.log(\u0026#39;オレンジ\u0026#39;); default: console.log(\u0026#39;知らないフルーツです！\u0026#39;); } } りんご グレープ オレンジ 知らないフルーツです！ 実行してみると値が一致している「\u0026lsquo;apple\u0026rsquo;」のcase節だけではなく、その他のcase節のログも出力されてしまいます。\n実は、switch文は式に該当するcase節の処理以降の全ての処理を実行する という仕様になっているのです。\nあえて、値が一致したcase節の以降を全て実行させたい場合はbreak文を書く必要はないのですが、各case節ごとでswitch文を抜けたい場合はbreak文を使用します。\nswitch文はbreak文がない限りブロックから抜け出すことはありません。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page_2_1_1/",
	"title": "ステートメント",
	"tags": [],
	"description": "",
	"content": "ステートメントとは JavaScript はスクリプトを実行すると、原則上から順に1行ずつ処理が実行されていきます。\nこの処理の最小単位を ステートメント と呼びます。\nステートメントは単語の途中でない限り、改行を入れることができます。\n（あくまで、改行を入れることができるという話であり、コードの可読性が下がるようであれば無闇に改行を入れることはおすすめしません。）\nコード.gs function myFunction() { console.log( \u0026#39;Hello GAS!\u0026#39; ); } また、ステートメントの最後にはセミコロン（;）をつけることがルールとなっていますが、\nセミコロンをつけなくても大抵のコードは実行されます。\nただし、稀にセミコロンをつけなかったためにエラーが発生するケースもあるため、\nステートメントの最後にはセミコロン（;）をつける ようにしましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "前提条件 GASの開発環境が整備されていること（Chapter1が完了していること） 目標のゴール GASをコーディングをする上で必要となるJavaScriptの基礎が身につくこと 入門編でご説明した通り、GASのベースはJavaScriptです。\nJavaScript基礎編では、GASの開発で使用するJavaScriptの構文やオブジェクトについて解説いたします。\nJavaScriptの構文とオブジェクトを理解することで、GASの実装効率を大幅にあげることができます。\nそれではJavaScript基礎編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "前提条件 Google アカウントがあること Google Chrome をインストールしていること インターネットにつながるPCがあること 目標のゴール Google Apps Script でコーディングをして、作成した関数を実行できること。 それでは入門編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/",
	"title": "入門編",
	"tags": [],
	"description": "",
	"content": "Chapter 1 入門編 Google Apps Script でコーディングしてみよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "前提条件 Google アカウントがあること Google Apps Script である程度スプレッドシートを操作できること 目標のゴール Google スプレッドシートをDBで代用したWebアプリケーションが作成できる Webアプリケーションとは それではWebアプリ編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/calendar/page_2/",
	"title": "Calendarサービス",
	"tags": [],
	"description": "",
	"content": "Calendarサービスとは Calendarサービス は Google App Script で Google カレンダーを操作するためのメソッドを提供しています。\nCalendarサービスでは以下のクラスを活用することで Google カレンダーを操作することができます。\nクラス名 概要 CalendarApp Calendar サービスのグローバルオブジェクト Calendar カレンダーを操作（カレンダーの情報の取得・更新・削除）する CalendarEvent 予定を操作（予定の取得・更新・削除）する Calendar サービスの各クラスは CalendarApp → Calendar → CalendarEvent という階層構造になっています。\n各クラスにはそのオブジェクトを操作するメンバーとともに、その配下のオブジェクトを取得するメンバーが用意されています。\nこれは Google カレンダー に限らず、他のサービスでもオブジェクトを操作する際の基本的な流れとなります。\nまた、GAS のクラスに対して new 演算子でインスタンスを生成することはありません。\nGASのオブジェクト操作の基本動作は、グローバルオブジェクトから辿って目的のオブジェクトを取得し、操作をしていきます。\nGoogle カレンダーの場合は CalendarApp がグローバルオブジェクトになります。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/es2015/page_2_5_2/",
	"title": "テンプレート文字列",
	"tags": [],
	"description": "",
	"content": "文字列に挿入する ES2015までは変数の値と文字列をconsole.log()で出力したい場合は、以下のように+記号で結合をする必要がありました。\nconst name = \u0026#39;Taro\u0026#39;; console.log(\u0026#39;My name is \u0026#39; + name +\u0026#39;.\u0026#39;); ES2015からはテンプレート文字列で文字列の中にプレースホルダを挿入することができます。\n＊）プレースホルダとは変数の中身を置き換えることができる文字列のことです。\n構文は以下の通りで　`（バッククォート）で囲み、$（ドル記号）と{}（波括弧）で作ることができます。\n`（バッククォート）と \u0026lsquo;（シングルクォート）は全く別の文字になるため注意が必要です。\n`${変数名や計算式などのリテラル}` では、サンプルコードで確認をしてみましょう。\n波括弧の中に変数名を指定することで、変数に格納されている値を文字列に挿入することができます。\nコード.gs function template_literals_1() { const name = \u0026#39;Taro\u0026#39;; console.log(`My name is ${name}.`); } My name is Taro. 波括弧の中には値や変数だけでなく四則演算子も指定できます。\nそのため、以下のように計算式を指定することもできます。\nコード.gs function template_literals_2() { const num1 = 1; const num2 = 2; console.log(`Result:${num1 + num2}`); } Result:3 また、テンプレート文字列内で改行をすると、文字列を複数行にすることもできます。\nコード.gs function template_literals_3() { console.log(`1行目 2行目`); } 1行目 2行目 "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_2/",
	"title": "ローカル開発とは",
	"tags": [],
	"description": "",
	"content": "スクリプトエディタの問題点 Google Apps Script は Google が提供しているスクリプトエディタでコーディングすることができます。\nGoogle Chrome があれば実装をすることができるのが Google Apps Script の強みではあるのですが、\nその反面 「好きなエディタで実装することができない！」 や 「Git で管理することができない！」 といった問題があります。\n他にもネット環境がなければコーディングを進められないなどの不便な点もあります。\nこれらの問題は Google サーバー上にソースがあることが原因となっているため、\n皆さんのPCの中（ローカル環境）で開発ができればこれらの問題を解消することができます。\nしかし、GASはスクリプトエディタ上でなければ実行することができないため、\nローカル環境でコーディングしたコードをスクリプトエディタに毎回コピー＆ペーストして実行する必要があります。\nこの手間を解消するツールとして Google は clasp というCLIツールを提供しています。\nclasp とは Google はこれらの問題を提供する clasp というツールを提供しています。\nこの clasp を利用すると Google Apps Script をローカルの好きなエディタで実装することができます。\nローカルに開発環境を整備しなければなりませんが、Google Apps Script でチーム開発をする場合は必須と言っても過言ではありません。\nこの clasp の具体的な使い方を本章で学んでいきましょう。\nなお、clasp は以下リンク先の Github で公開されています。\nhttps://github.com/google/clasp "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_2/",
	"title": "Spreadsheetサービス",
	"tags": [],
	"description": "",
	"content": "Spreadsheetサービスとは Spreadsheetサービス は、GASでスプレッドシートを操作するためのメソッドやスプレッドシートの情報を提供するサービスです。\nSpreadsheetサービスの中でよく使うクラスを下記にまとめています。\nクラス名 概要 SpreadsheetApp Spreadsheetサービスのグローバルオブジェクト Spreadsheet スプレッドシートを操作する機能を提供する Sheet シートを操作する機能を提供する Range セルを操作する機能を提供する Spreadsheetサービスの各クラスは、SpreadsheetApp → Spreadsheet → Sheet → Range という階層構造になっています。\n各クラスにはそのオブジェクトを操作するメンバーとともに、その配下のオブジェクトを取得するメンバーが用意されています。\nこれはスプレッドシートに限らず、他のサービスでもオブジェクトを操作する際の基本的な流れとなります。\nまた、GASのクラスに対して new 演算子でインスタンスを生成することはありません。\nGASのオブジェクト操作の基本動作は、グローバルオブジェクトから辿って目的のオブジェクトを取得し、操作をしていきます。\nスプレッドシートの場合は SpreadsheetApp がグローバルオブジェクトになります。\nSpreadsheetAppクラスとは SpreadsheetAppクラス はSpreadsheetサービスの最上位に位置するグローバルオブジェクトです。\nSpreadsheetサービスが提供する機能を利用するには、まずSpreadsheetAppクラスからアクセスすることになります。\nSpreadsheetAppクラスでは、直下のオブジェクトであるスプレッドシートを取得するメソッドや、\n現在アクティブになっているシートやセル範囲を取得するメソッドが用意されています。\nスプレッドシートを取得する スプレッドシートを操作するには、スプレッドシートを取得する必要があります。\nGASでスプレッドシートを取得する主な方法は下記の通りです。\nアクティブなスプレッドシートを取得する IDでスプレッドシートを特定して取得する URLでスプレッドシートを特定して取得する アクティブなスプレッドシートとは、スクリプトにバインドされているスプレッドシートを指します。\nスプレッドシートのコンテナバインドスクリプトであれば、次の構文でスプレッドシートを取得することができます。\nSpreadhsheetApp.getActiveSpreadsheet() getActiveSpreadsheetメソッドをはじめ、「アクティブ」なオブジェクトを取得するメソッドは、コンテナバインドスクリプトでのみ使用できます。\nそのため、バインドされていないスプレッドシートを取得する場合は、別の方法で取得する必要があります。\nその方法としては、IDで特定して取得するopenByIdメソッドと、URLで特定して取得するopenByUrlメソッドがあります。\nSpreadsheetApp.openById(スプレッドシートのID); SpreadsheetApp.openByUrl(スプレッドシートのURL); スプレッドシートをはじめ Google Apps のファイルは一意のURLが定められています。\nブラウザではそのURLにアクセスすることで、そのファイルを開くことができます。\nGASでも同じように、そのURLがわかればスクリプトからスプレッドシートを特定して取得することができます。\nまた、IDも一意に定められており、このIDはURLの一部を構成しています。以下の{ID}の部分がIDです。\nhttps://docs.google.com/Spreadsheets/d/{ID}/edit#gid=0 このように、URLがわかればIDを取得することが可能です。\nでは、実際にスクリプトでスプレッドシートを取得してみましょう。\nまずは、新規のスプレッドシートを作成して「別のスプレッドシート」と名前をつけてください。\n先ほどの手順で作成した「別のスプレッドシート」のURLとIDを確認した上で、下記のサンプルを記述して実行してください。\nfunction spreadsheet_1() { var spreadsheet = SpreadsheetApp.getActiveSpreadsheet(); SpreadsheetApp.openById(スプレッドシートのID) // はじめてのGAS console.log(spreadsheet.getName()); var url = \u0026#39;https://docs.google.com/Spreadsheets/d/XXXX/edit#gid=0\u0026#39;; spreadsheet = SpreadsheetApp.openByUrl(url); SpreadsheetApp.openById(スプレッドシートのID); // バインドしていないスプレッドシート console.log(spreadsheet.getName()); var id = \u0026#39;XXXX\u0026#39;; spreadhsheet = SpreadsheetApp.openById(id); // バインドしていないスプレッドシート console.log(spreadsheet.getName()); } はじめてのGAS 別のスプレッドシート 別のスプレッドシート アクティブなシートを取得する GASでスプレッドシートを操作する場合、シートやセルを操作対象とすることが多いでしょう。\nその度に、SpreadsheetApp → Spreadsheet → Sheet と辿っていくのは手間に感じるかもしれません。\nまた、メソッド実行による Google Apps へのアクセスは実行時間が遅いという事実があります。\nGASには実行時間に関する制限がありますので、処理速度を落とさないためにも Google Apps へアクセスするメソッドの実行回数はできる限り減らしたほうがよいです。\nコンテナバインドスクリプトであれば、そのような場合にアクティブなシートを取得する方法として getActiveSheetメソッド を使用できます。\nSpreadsheetApp.getActiveSheet() SpreadsheetAppから直接取得できるので、次のサンプルのように簡潔に記述することができます。また、スプレッドシートへアクセスするメソッドの実行回数を減らすこともできます。\nfunction spreadsheet_2() { var sheet = SpreadsheetApp.getActiveSheet(); console.log(sheet.getName()); } シート1 Google Apps へのアクセスは実行時間が遅いので、できる限りアクセスするメソッドの実行回数は少なくなるようにしましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/object_mechanism/page_2_4_2/",
	"title": "インスタンス化",
	"tags": [],
	"description": "",
	"content": "インスタンス化 早速、次のサンプルをご確認ください。\npersonオブジェクトが定義されており、nameとageというプロパティと、greetというメソッドが用意されています。\nコード.gs var person = { name: \u0026#39;Taro\u0026#39;, age: 22, greet: function() { return \u0026#39;My name is Taro. I am 22 years old.\u0026#39; } }; function outputObj_3() { console.log(person.greet()); // My name is Taro. I am 22 years old. } このオブジェクト同じ構造で、5人分のオブジェクトを用意する必要が出てきた場合はどのようにコーディングすればいいでしょうか？\n全てのオブジェクトのプロパティとメソッドを漏れなく記述しようとすると、上記のサンプルのpersonクラスを5つ用意する必要があります。\nこのpersonクラスを5つも用意するとなると記述する量も多く、助長なスクリプトになってしまいます。\nまた、オブジェクトの構造やメソッドの内容を変更しなければならなくなった場合、\n全てのオブジェクトについて修正を加える必要があり、メンテナンス性にも問題があります。\nこの問題を解消する手段として、JavaScriptにはオブジェクトの「ひな型」をベースとして、\n同じプロパティやメソッドを持つ別のオブジェクトを生成する仕組みがあります。\nここで用語の定義として、それぞれ次のように呼びます。\nオブジェクトの特性を定義するひな型： クラス クラスを元にしてオブジェクトを生成すること： インスタンス化 インスタンス化により生成されたオブジェクト： インスタンス オブジェクトをスクリプトの部品として捉えると、その再利用性や可読性が高まりますし、\n「ひな型」自体に変更を加えないので、オリジナルのオブジェクト構造についての安全性が高まります。\nコンストラクタとnew演算子によるインスタンス化 では、クラスを定義してインスタンス化をする方法について順を追って見ていきましょう。\nまず、既にクラスが定義されているとして、\nそのクラスをインスタンス化するには、以下のように new演算子 を使って記述します。\nvar 変数名 = new コンストラクタ名(引数１, 引数２, ...); コンストラクタというのは、クラスをインスタンス化する際に最初に呼び出される関数で、生成したオブジェクトの初期化処理をするという特別な役割を持ちます。\nそして、コンストラクタにより初期化されたオブジェクトが変数に代入されます。\nコンストラクタは一般の関数と同様で、次のように定義することができます。\nvar コンストラクタ名 = function(仮引数１, 仮引数２, ...) { // 処理 } コンストラクタ名は、通常の関数名と区別するために先頭を大文字で始めるのが一般的で、これがいわゆるクラス名として使用されます。\nまた、コンストラクタにはreturn文による戻り値は不要です。\nなぜかというと、new演算子によりコンストラクタを呼び出すことで自動的に初期化したオブジェクトが戻るようになるからです。\nクラスをインスタンス化するときには、new演算子を使ってインスタンスを初期化する関数であるコンストラクタを呼び出します。\nthisキーワード それでは、コンストラクタ内の処理は具体的にどのようなものでしょうか？\nオブジェクトの「ひな型」をインスタンス化したときに、インスタンスに渡すメンバーを定義する必要があります。\nその際に使用するのが thisキーワード です。\nthisキーワードは生成したインスタンス自体を表します。\nそのため、このthisキーワードを用いてインスタンスのメンバーを変更したり、その値を代入することができます。\nthisキーワードは次の書式でコンストラク内に記述します。\nthis.プロパティ名 = 値; this.メソッド名 = function(仮引数１, 仮引数２, ...) { // 処理 return 値; } コンストラクタ内のthisキーワードは、これから生成されるインスタンス自体を表します。\nここで、コンストラクタとインスタンス化の例として次のサンプルを確認してみましょう。\nnew演算子によって、Personコンストラクタにnameおよびageを引数として渡して、オブジェクトを生成するものです。\n実行後ログを確認すると、渡した引数がthisキーワードによって、それぞれのプロパティにセットされているのが確認できるでしょう。\nコード.gs var Person = function(name, age) { this.name = name; this.age = age; this.greet = function() { return \u0026#39;My name is \u0026#39; + this.name + \u0026#39;. I am \u0026#39; + this.age + \u0026#39; years old.\u0026#39; }; }; function outputObj_4() { var person = new Person(\u0026#39;Hanako\u0026#39;, \u0026#39;25\u0026#39;); console.log(person.greet()); } My name is Hanako. I am 25 years old. コンストラクタにメンバーを定義するのであれば、クラスとコンストラクタは同一のものと思われるかもしれません。\n実際にオブジェクトとしては同一のものを指しますが、厳密には下記のように使い分けられています。\nインスタンス化の際に最初に呼び出す関数を指す場合はコンストラクタ ひな型を指す場合はクラス インスタンスのメンバーの変更 クラスから生成したインスタンスはオブジェクトのため、個別にメンバーの値の変更やメンバーの追加も可能です。\n次のサンプルを実行してみましょう。ageプロパティの値に5を加算して、jobs　プロパティを新たに追加しています。\nコード.gs var Person = function(name, age) { this.name = name; this.age = age; }; function outputObj_5() { var person = new Person(\u0026#39;Nobuo\u0026#39;, 20); person.age += 5; person.jobs = \u0026#39;Engineer\u0026#39;; console.log(person); } { name: \u0026#39;Nobuo\u0026#39;, age: 25 , jobs: \u0026#39;Engineer\u0026#39; } "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/page_2_3_2/",
	"title": "引数と戻り値",
	"tags": [],
	"description": "",
	"content": "関数の引数と戻り値 関数を呼び出して処理を実行する際に値を受け渡すことができます。この呼び出した関数に渡す値を 引数 といいます。\nまた、呼び出し関数から処理を戻す際にも値を受け渡すことができます。この呼び出した関数から受け取る値を 戻り値 といいます。\n引数と戻り値を含めた関数の宣言は次のように記述することができます。\nfunction 関数名(仮引数１, 仮引数２, ...) { // 処理 return 戻り値; } 関数が呼び出されたときに受け取る値を格納する変数を 仮引数 といいます。仮引数は関数名の後ろの丸括弧内に指定します。\n仮引数の宣言にはvarは不要で、複数ある場合はカンマ区切りで記述します。\nまた、return文 によって戻り値を指定します。戻り値が不要の場合はreturn文を省略します。\nreturn文が実行されると、それ以降の処理は実行されないため気をつけましょう。\nreturn文が実行されると、戻り値と共に処理も戻ります。\n一方で、引数を渡して関数を呼び出すには下記のように記述します。\n関数名(引数１, 引数２, ...) 戻り値を返す関数を呼び出した場合は、左辺に変数を指定することで代入をしたり、さらに引数として利用をしたりすることができます。\nでは、次のサンプルで確認をしてみましょう。\n面積を求めるcalcArea関数は、引数として縦の長さx変数と横の長さy変数の値を受け取り、戻り値としてx * yの算出結果を返します。\nコード.gs function myFunc_3() { var result = calcArea(10, 5); // 関数の結果を変数に格納することができます console.log(result); console.log(calcArea(2, 15)); // 関数の結果を別の関数の引数に指定することもできます } function calcArea(x, y) { return x * y; } 50 30 関数と return 関数の値はキーワードの return を使って呼び出し側に戻します。\n関数から return で戻らない場合や値が指定されていない return で戻る場合、\n関数が返す値は undefined となります。\nコード.gs function myFunc_4() { console.log(output_1()); console.log(output_2()); } function output_1() { return \u0026#39;Hello!\u0026#39;; } function output_2() { var hello = \u0026#39;Hello!\u0026#39;; } Hello! undefined 関数の引数 関数に情報を渡すには「引数（パラメーター）」と呼ばれるものを利用します。\n引数は「関数が呼び出されるまでは存在しない変数」であり、\n関数の呼び出しの際に（）の中に値を設定することでその値を引数として利用することができます。\nコード.gs function sum(a, b) { return a + b; } 上記のサンプルにおいて、aとbは「仮引数」と呼ばれており、\n関数が呼び出されると仮引数に呼び出し側から渡された値が代入されたのち関数本体が実行されます。\nconsole.log(sum(5, 10); 上記の例では仮引数のaには5、bには10が値として記憶されてから、関数本体が実行されます。\n仮引数は普通の変数と同じような役割をしますが、この関数の本体でしか値の参照や代入はできません。\n関数の外に同じ名前の変数があったとしても別の変数として扱われます。\n関数の引数の注意点 多くの言語では引数の個数が違う場合は異なる関数として扱われます。\n例えば、Javaではf(x)とf(x, y)とでは引数の数が異なるため別の関数として扱われます。\nJavaScriptではこのような区別がなく、引数なしであっても、引数がいくつあっても同じ関数として呼び出されます。\nそのため、どのような関数でも任意個数の引数を指定して呼び出すことができます。\n呼び出し側に引数を指定しない場合は暗黙のうちにundefinedが指定されて呼び出されます。\nコード.gs function myFunc_5() { console.log(output_3()); } function output_3(x) { return \u0026#39;output_3内のxの値：\u0026#39; + x; } output_3内のxの値：undefined "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/page_2_2_2/",
	"title": "処理を繰り返し行う",
	"tags": [],
	"description": "",
	"content": "while文 唐突ですが、「1から10の数値を加算した結果を求めるスクリプトを書いてみましょう！」となったとき、どのようにコーディングしますか？\nここまで学習してきた皆さんであれば、下記のようにコーディングすることができると思います。\nvar num = 0; num += 1; num += 2; ~ num += 10; そして、コーディングの途中で「これ同じことを繰り返していない？」と気づくと思います。\n繰り返す処理の数だけ行数が増えていき、コーディングをするのも大変ですし、後々コードを修正するときも大変です。\n実際にプログラミングをしているとこのように同じ処理を繰り返す場面が多々あります。\n実は、JavaScriptには繰り返し処理を実現する構文が用意されています。\nそのうちの1つが while文 です。\nwhile文は条件式を用いた繰り返しを実現することができます。\nwhile (条件式) { // 条件式がtrueの間は実行される処理 } while文を使いますと、条件式の結果がtrueの間はブロック内の処理を繰り返し実行し、条件式がfalseになったときにループ処理から抜けます。\n下記のサンプルを実行して、while文の処理の流れを確認しましょう。\nコード.gs function outputLoop() { var x = 1; var sum = 0; while(x \u0026lt;= 10) { sum += x; x++; } console.log(sum); } 55 無限ループ 繰り返し処理を行う際には 無限ループ に気をつける必要があります。\n下記のサンプルを実行すると無限ループが発生します。\nコード.gs function outputLoop_2() { var x = 1; var sum = 0; while(x \u0026lt;= 10) { sum += x; } console.log(sum); } このサンプルを実行するとスクリプトエディタの上部に「関数outLoop_2を実行中\u0026hellip;」というメッセージが表示されたまま処理が完了しません。\nこのサンプルは変数xを初期化して1を代入していますが、while文の条件式がx \u0026lt;= 10となっているのにもかかわらず変数xが更新されずにずっと1のままのため、\nwhile文の中をグルグル回り続けてしまっています。\nこのように、while文の条件式がfalseとなることがなく、永遠に同じループが繰り返されてしまう状態を無限ループといいます。\nGASでは無限ループが発生した場合は「関数〇〇を実行中\u0026hellip;」に続く、キャンセルをクリックすることでスクリプトを停止させることができます。\n繰り返し処理をコーディングする際は、必ずループが終了するようになっているかを確認するようにしましょう。\nwhile文による繰り返しでは無限ループに気を付けましょう。\nfor文 while文は条件式がtrueの間は処理を繰り返すという構文でしたが、処理を繰り返す回数があらかじめ決まっているのであれば for文 を使用しましょう。\nfor (①カウンタ変数の初期化; ②条件式; ④増減式) { // ③条件式がtrueの間は実行される処理 } for文では カウンタ変数 と呼ばれる変数を用います。\nfor文を使用すると決められた回数の繰り返し処理をとてもシンプルにコーディングすることができます。\nfor文の処理の流れは以下の通りです。\n①カウンタ変数の初期化\nカウンタ変数に値を代入して初期化します。\n②条件式\n条件式の結果を求めて判定を行います。この判定で true と判定された場合は {} の中の処理を実行します。\nfalse と判定された場合は {} の中の処理を実行せずにループ処理を抜けます。\n③条件式がtrueの間は実行される処理\nfor文の {} の中の処理を実行します。\n④増減式\n最後に計算式を実行し、カウント変数の増減を行います。\n計算後は②条件式に戻ります。\n次のサンプルを実行してfor文の処理の流れを確認しましょう。\nコード.gs function outputLoop_3() { var sum = 0; for (var index = 1; index \u0026lt;= 10; index++) { sum += index; } console.log(sum); } 55 continue文 いまのループを中断して次のループに進みたい（要約するとスキップしたい）場合はcontinue文を活用します。\ncontinue文が実行されると、そのループは中断され増減式が実行されます。\n次のサンプルではカウンタ変数のindex変数が２の倍数の場合は、continue文以降の処理をスキップしています。\nコード.gs function outputLoop_4() { for (var index = 0; index \u0026lt;= 10; index++) { if (index % 2 === 0) { // index が２の倍数の場合はスキップする continue; } console.log(index); } } 1 3 5 7 9 繰り返し処理と配列 これまでは配列の要素を取得しようとすると下記のようにコーディングする必要がありました。\nコード.gs function outputLoop_5() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;]; console.log(fruits[0]); console.log(fruits[1]); console.log(fruits[2]); } apple banana orange 上記の例では取り出す要素が3つだけのため問題ありませんが、\nこの要素の数が10、100と増えていくとそれに比例してコーディング量が増えてしまいます。\nそのような時に繰り返し処理を活用するとコーディング量を減らすことができます。\nコード.gs function outputLoop_6() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;]; for (var index = 0; index \u0026lt; fruits.length; index++) { console.log(fruits[index]); } } apple banana orange 先ほどの例は配列の要素を取得しましたが、多次元配列から要素を取得するときも活躍します。\n以下のサンプルでは繰り返し処理を活用して２次元配列の要素を取得しています。\nコード.gs function outputLoop_7() { var foods = [[\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;], [\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;]]; for (var i = 0; i \u0026lt; foods.length; i++) { console.log(foods[i]); } } [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;] [\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;] ２次元配列から配列（要素）を取得することができましたが、さらにその配列の要素を取得したい場合もあります。\nその場合は繰り返し処理の中でさらに繰り返し処理を行う２重ループを行うことで実現できます。\n1回目のループ（カウント変数がi変数のループ）では配列（要素）を取得して、\n2回目のループ（カウント変数がj変数のループ）で要素を取得しています。\nコード.gs function outputLoop_8() { var foods = [[\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;], [\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;]]; for (var i = 0; i \u0026lt; foods.length; i++) { for (var j = 0; j \u0026lt; foods[i].length; j++) { console.log(foods[i][j]); } } } apple banana orange beef pork chicken "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page_2_1_2/",
	"title": "関数",
	"tags": [],
	"description": "",
	"content": "関数とは 入門編で少し解説しましたが、関数 とは一連の処理をひとまとめにして名前をつけたものです。\n「関数（function）」　は文が集まったもので、プログラムを構成する部品の役割をする「サブプログラム」です。\nJavaScriptでは関数はとても重要な役割を果たしますが、本章ではその基本的な機能と使い方を紹介します。\n関数の構文 関数を実行する際は関数名を指定して呼び出します。\n関数の作り方にはルールがあり、以下のように function キーワード で定義します。\nfunction 関数名() { 処理 } ここまではデフォルトの「myFunction」という名前の関数を実行してきましたが、関数名は任意につけることができます。\n関数名はその関数がどのような処理を行うかがイメージしやすい名前をつけるようにしましょう。\n例えば、「ユーザー名を取得する関数」であれば、「getUserName」とするとわかりやすいですよね。\nまた、波括弧（\u0008{}）で囲った箇所は、複数のステートメントをまとめたもので ブロック といいます。\nこのブロックは今後の説明する構文で重要な役割を果たします。\nブロックは改行しないで記述することもできますが、改行を入れたほうが読みやすいコードになります。\n下記の例で見比べると一目瞭然ですね。\nfunction myFunction() {console.log(\u0026#39;Hello GAS\u0026#39;);} function myFunction() { console.log(\u0026#39;Hello GAS\u0026#39;); } それでは、次のサンプルをコーディングして保存してみましょう。\nコード.gs function sayHello() { console.log(\u0026#39;Hello!\u0026#39;); } すると、スクリプトエディタのツールバーの「関数選択」のプルダウンに「sayHello」が選択可能となっていることが確認できます。\nその関数を選択してスクリプトを実行してそのログ表示を確認してみましょう。\n「sayHello」を実行すると、「Hello!」と表示されます。\nこのように、gsファイルには複数の関数を定義することができます。そして、定義した関数を「関数選択」のプルダウンから選択して実行することができます。\nコーディングする際の注意点 JavaScriptでコーディングする際は基本的に半角英数字と半角記号のみを使用します。\n逆にいうと、全角文字は使用することができません。（後述の文字列やコメントでは使用できます。）\nまた、JavaScriptは同じアルファベットでも大文字と小文字を区別します。\nそのため、下記のようなコードを記述するとスクリプトの実行時にエラーが発生します。\nコード.gs function myFunction() { console.Log(\u0026#39;Hello GAS!\u0026#39;) } 実行すると、「TypeError：オブジェクトconsoleで関数Logが見つかりません。」というエラーが発生します。\nこのようにタイプミスで大文字と小文字を間違えたりするとエラーとなってしまいます。\nちなみに、スクリプトエディタには自動補完機能があるので、この機能を駆使することでタイプミスを防ぐことができます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/",
	"title": "基本構文を学ぼう",
	"tags": [],
	"description": "",
	"content": "Chapter 2 - 2 JavaScriptの基本構文 JavaScriptの基本となる構文を学びましょう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/",
	"title": "JavaScript基礎編",
	"tags": [],
	"description": "",
	"content": "Chapter 2 JavaScript基礎編 JavaScriptの基礎を身につけよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_2/",
	"title": "Google Apps Script とは",
	"tags": [],
	"description": "",
	"content": "Google Apps Script とは Google Apps Scriptは、Google が提供するローコードプラットフォームです。\n厳密には違うのですが、プログラミング言語といっても差し支えないと思います。\n（以降、Google Apps Script を GAS と呼称します。）\nGAS を使うことで、Gmail や Googleカレンダー、Google スプレッドシートなどの\nGoogle が提供するアプリケーションをプログラミングによって操作することができるようになります。\n各アプリケーション単体の動作はもちろん、アプリケーション同士を連携させて動作させることもできます。\nまた、HTMLやCSS、JavaScriptでWebアプリケーションを作成し、公開することもできます。\n一方で、GAS独自のルールがあるため、そのルールを把握した上でコーディングをする必要があります。\nこの入門編ではGASを学ぶ上で土台となる基礎知識を身につけていきます。\nGASのベースはJavaScript！ GASはJavaScriptというプログラミング言語がベースになっています。\nJavaScriptはブラウザ上で動作する標準のスクリプト言語として使われており、\nさらにサーバーの処理を行う言語としても活用されています。\nスクリプト言語は簡易にコーディングと実行ができることが特徴です。\nそのため、プログラミングが初めてという方でも比較的容易に習得することできます！\nGASはクラウド上で動く！ GASの特徴は、コーディングをする場所もプログラムが実行される場所も全てGoogleのクラウドサーバー上にあります。\n例えば、Excel VBA の場合はコーディングやプログラムの実行はPC内で行われます。\n一方、GASはブラウザ上でコーディングを行い、プログラムの実行はクラウドサーバー上で行われます。\nGASの最大の利点は 開発環境の整備が不要 であることです。\nスクリプトが実行されるサーバーも、コーディングを行うエディタもすべてGoogleが用意してくれています。\nまた、スクリプトはGoogleのクラウドサーバー上で動作するため、PCやブラウザが起動していなくてもスクリプトを実行することができます。\nトリガー という機能を使うことで、時間を指定して特定の時間にスクリプトを実行させることができます。\n開発に必要なもの GASで開発をするのに必要なものは下記の３つだけです。\nGoogle アカウント（G Suite でも無料のGoogleアカウントでもどちらでもOKです。） ブラウザ（Google Chrome を推奨） インターネットに接続できるPC（WindowsOSでもMacOSでもどちらでもOKです。） 他のプログラミング言語と比べても敷居はとても低く、\nGASの門戸は常に開かれています。\nGoogle Apps とは Google Apps はGoogle が提供しているアプリケーションを意味していますが、GASはGoogleが提供しているすべてのアプリケーションを操作できるわけではありません。\nどのアプリケーションを操作できるかは、後述の「リファレンスについて」で確認していきましょう。\nGoogle アカウントについて 皆さんはGoogleアカウントを無料で作成してサービスを利用することができます。\nその一方で、これらのサービスが企業や組織向けに提供されている有償版のサービスもあります。\nこれは G Suite と呼ばれており、企業や組織向けのサービスとして利用することができます。\nG Suite のプランにはBasic/Businessというプランが用意されています。\n無料アカウントと G Suite の各プランの違いは下記の通りとなっております。\n項目 無料アカウント G Suite for Basic G Suite for Business 料金 無料 680円/月額 1,360円/月額 メールアドレス ドメイン名はgmail.comのみ 独自ドメインを設定できる 独自ドメインを設定できる サポート なし 24時間365日サポート 24時間365日サポート 管理コンソール なし ユーザー管理、端末管理、セキュリティ設定が可能 ユーザー管理、より高度な端末管理とセキュリティ設定が可能 クラウドストレージ容量 15GB 30GB 無制限 無料のアカウントでも、GASの基本的な機能を利用することは可能です。\nしかし、GASの実行の際に一部制限があり、G Suite の方がその制限が緩くなっています。\nその一例は下記の通りです。\n公式ガイド 項目 無料アカウント G Suite for Basic G Suite for Business スクリプト実行時間 6分/実行 6分/実行 30分/実行 カスタム関数実行時間 30秒/実行 30秒/実行 30秒/実行 トリガーの総実行時間 90分/日 3時間/日 6時間/日 GASで操作できるアプリケーションについて GASで多くのアプリケーションを操作することができますが、\nこの機能は「サービス」と呼ばれており、このサービスは３つのグループに分けられています。\nグループ 概要 提供されるサービス例 サービスの利用方法 G Suite Services G Suite に含まれるアプリケーションを操作するサービス群 Gmail、Calendar、スプレッドシートなど デフォルトで利用可能 Script Services ユーティリティサービス群 Cache、HTML、JDBCなど デフォルトで利用可能 Advanced Google Services G Suite Services よりも高度な操作を行うことができるサービス群 BigQuery、AdminSDKなど デフォルトで利用可能 G Suite Services 主に G Suite で提供されている各アプリケーションを操作するサービスが提供されています。\nG Suite のすべてのサービスを操作できるわけではないのですが、\nこれらのサービスを操作することで業務効率化を図ることができるアプリケーションやツールを作ることができます。\nCalendar：カレンダー Contacts：連絡先 Document：ドキュメント Drive：ドライブ Forms：フォーム Gmail：メール Groups：グループ Language：翻訳 Maps：マップ Slides：スライド Spreadsheet：スプレッドシート Script Services Script Servicesでは、GAS 全般で横断的に利用するユーティリティとして機能するサービスが提供されています。\n例えば、ログを出力したり、ダイアログを表示したりなど便利な機能が揃っています。\nBase Cache Charts Content HTML JDBC Lock Script Url Fetch Advanced Google Services GASには G Suite Services に含まれないアプリケーションや、より高度な操作を可能にするサービスが提供されています。\nこれらは 拡張サービス（Advanced Google Services）と呼ばれていて、\nG Suite Servicesでは操作ができないBigQueryやAdminSDKを操作することができ、\nG Suite Servicesで用意されているGmailやDriveなどのアプリケーションに対して、より高度な処理を行うことができます。\nデフォルトでは無効になっているため、利用したいサービスごとに有効にする必要があります。\nGASを学ぶ上で気をつけること GAS = JavaScriptではない 先述した通り、GASのベースはJavaScriptではあるものの、JavaScriptのすべての機能を利用できるわけではありません。\nGASで利用できる JavaScript は、基本構文、制御構文、演算子、関数、組み込みオブジェクトなどの基本部分であるECMAScript（エクマスクリプト）のみです。\nまた、ECMAScriptは高頻度でバージョンアップを繰り返しているのですが、\nその更新にGASは対応しきれていないため、ECMAScriptであっても記述できない構文などもあります。\nまた、JavaScriptを大きく分けると画面の操作を行う フロントエンド と 外部サービスへの連携やデータベースの処理などを行う サーバーサイド に分けられます。\nGASはサーバーサイドに分類するため、フロントエンドのJavaScriptの機能を利用することができません。\n例えば、下記のような画面にアラートを表示するという初歩的なコードすら実行することができません。\nalert(\u0026#39;Hello World!\u0026#39;) GASの実行には制限がある 先述した通り、GASはGoogleのサーバー上で動作するため、仮にあるユーザーが極端にサーバーに負荷がかかる処理を行うと、GAS全体に影響を及ぼす恐れがあります。\nこのような状況を避けるためにGASにはいくつかの機能に対して制限が設けられています。\n詳細は下記リンク先の公式ガイドをご参照ください。\n公式ガイド 特に気をつけるべきは スクリプトの実行時間 で、無料アカウントや G Suite for Basic の場合は6分、\nG Suite for Business の場合は30分で処理が強制終了してしまいます。\nそのため、GASで開発を行う際は扱うデータ量と処理速度に注意をする必要があります。\nリファレンスについて 具体的にGASがどのようなサービスを提供しているかは下記リンク先のリファレンスで確認することができます。\nどのサービスを利用すればよいか迷ったときは、このリファレンスを参考に吟味するようにしましょう。\n公式リファレンス また、Google社はGASを不定期にアップデートしているため、GASで開発する際は利用するサービスを必ずリファレンスで確認するようにしましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_2/",
	"title": "Web画面を表示してみよう",
	"tags": [],
	"description": "",
	"content": "まずは Google Apps Script でアプリケーションを作成する第一歩として、\nブラウザにWeb画面を表示してみましょう。\nスクリプトの種類 Google Apps Script には2種類のスクリプトがあります。\nContainer Bound Script Standalone Script それぞれのスクリプトの違いについて確認していきましょう。\nContainer Bound Script Google スプレッドシートやドキュメントなどの各アプリケーションのメニューから作成することができるスクリプトです。\n＜スクリプトを作成する手順＞\nGoogle スプレッドシートやドキュメントなどのアプリケーションを開きます。 上部メニューの|[ツール] \u0026gt; [スクリプトエディタ]を選択します。\n＜メリット＞\nバインドしているファイルを簡単に参照できる バインドしているファイルから Google Apps Script を実行できる この方法で作成されたスクリプトと同アプリケーションはバインド（結びつく）しているため、\nスプレッドシートの場合は下記のメソッドによりブラウザで開いている同スプレッドシートを操作することができます。\nconst spreadsheet = SpreadsheetApp.getActiveSpreadsheet(); const sheet = spreadsheet.getActiveSheet(); const range = sheet.getActiveRange(); また、onOpen関数を利用してアプリケーションにメニューを追加し、\nそのメニューからスクリプトエディタでコーディングした関数を実行することができます。\n他にも、図形にコーディングした関数を埋め込み、図形をクリック時に埋め込めんだ関数を実行することもできます。\n要約しますと、この方法で作成したスクリプトはExcelでいうVBAに近い感覚で利用することができます。\nStandalone Script Container Bound Script とは対照的に、どのアプリケーションにもバインド（結びつく）していないスクリプトです。\n作成されたスクリプトは Googleドライブ に表示されます。\n＜スクリプトを作成する手順＞\nGoogle Chrome で Google ドライブを開きます。 Google ドライブの左上に表示されている[新規]ボタンをクリックします。 で表示されたメニュー内の[その他]をクリックします。 で表示されたメニュー内の[Google Apps Script] をクリックします。\n＜メリット＞\n利用者にスクリプトエディタを編集されるリスクがない Google ドライブで管理がしやすい 一見、Container Bound Script でスクリプトを作成した方が始めやすく、\nバインドしたファイルを簡単に参照できるメソッドも利用できるため扱いやすいです。\nしかし、作成したスクリプトを他者と共有して利用したい場合は、\n利用者もスクリプトエディタを編集することができてしまいます。\nつまり、いつの間にか利用者によってスクリプトの内容が書き換えられてしまうことが起こる可能性があります。\n一方で、Standalone Script はスクリプトファイルを共有したアカウントのみ編集することができ、ユーザーによって編集されるリスクがありません。\nまた、作成したスクリプトは Google ドライブに保存されているため管理がしやすいのも特徴です。\n（Container Bound Script の場合は対象のファイルを開かなければスクリプトエディタを開くことができません。また、Google ドライブにスクリプトが表示されません。）\n補足\nGoogle ドライブでは Container Bound Script を管理できないとお伝えしましたが、\n作成したスクリプトは下記リンク先のダッシュボードから簡単にアクセスすることができます。\nhttps://script.google.com/home 今回のWebアプリ編のハンズオンでは Standalone Script で進めていきます。\nContainer Bound Script でも問題なく行うことができますが、\n後々の管理のことを考えて Standalone Script で進めていきましょう。\nHTMLファイルの作り方について Webアプリを作るには画面を作る必要がありますが、画面はHTMLファイルで作ることができます。\nHTMLファイルは下記の手順で作成することができます。\n[ファイル]の右端にある＋マークをクリックして、表示されたメニュー内の[HTML]を選択します。\n作成したHTMLファイルのファイル名を設定します。\n※ ここではファイル名を「index」としてください。\nスクリプトエディタ上に「index.html」が作成されます。 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; doGet関数について ユーザーが公開したWebアプリにアクセスした場合にdoGet関数は実行されます。（別のプログラムからWebアプリにHTTPのGETリクエストが送信される場合も同じく実行されます。）\nWeb画面を表示するにはdoGet関数の戻り値として HtmlServiceオブジェクト を指定する必要があります。\n下記のようにコーディングをしますと、index.htmlを表示する画面として指定することができます。\nCode.gs index.html function doGet() { return HtmlService.createTemplateFromFile(\u0026#39;index\u0026#39;).evaluate(); } \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hello World! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Webアプリのデプロイ方法について 作成したWeb画面はデプロイ（公開）をすることでURLが発行されて確認することができます。\n作成したWebアプリは次の手順でデプロイ（公開）することができます。\n画面右上にある「デプロイ」ボタンをクリックし、メニュー内の「新しいデプロイ」を選択してください。\n「種類の選択」の右隣にある歯車マークをクリックし、メニュー内の「ウェブアプリ」を選択してください。\n以下、各種画面項目を設定し、「デプロイ」ボタンをクリックして下さい。\n・新しい説明文\n⇒ 初めてのデプロイ\n・次のユーザーとして実行\n⇒ ウェブアプリケーションにアクセスしているユーザ\n・アクセスできるユーザー\n⇒ 自分のみ\n表示されたWebアプリのURLをクリックしてアプリケーションを起動しましょう。\n以下の画面が表示されれば成功です！\n無償版の Google アカウントで作成したWebアプリを公開すると以下の画像のように画面上部にメッセージが表示されてしまいます。\nこのメッセージは取り除いたり隠したりすることができないため注意が必要です。\nWebアプリの更新方法について 公開したWebアプリはその後更新することもできます。\nまずはindex.htmlを以下のようにHello World!をこんにちは!に変更してみましょう。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; こんにちは! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 変更できましたら、以下の手順に沿ってWebアプリを更新してみましょう。\n画面右上にある「デプロイ」ボタンをクリックし、メニュー内の「デプロイを管理」を選択します。\n表示された小画面の右上に表示されている「編集」アイコンをクリックします。\n以下、各種画面項目を設定し、「デプロイ」ボタンをクリックして下さい。\n・バージョン\n⇨ 新バージョン\n・説明\n⇨ 2回目のデプロイ\n表示されたWebアプリのURLをクリックしてアプリケーションを起動しましょう。\n更新されたWeb画面が表示されれば成功です！\nデプロイのテストについて Web画面を更新できることを確認することができたと思いますが、\n実際の開発ではコードの修正⇨Web画面の確認の流れが頻繁に発生するため、その都度更新の手順を踏むのは非常に手間に感じられます。\nそこで、デプロイ（公開）はしないで最新のWeb画面を確認する方法をご紹介します。\nまずはindex.htmlを以下のようにこんにちは!をWeb画面を変更しました!に変更してみましょう。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Web画面を変更しました! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 変更できましたら、以下の手順に沿って最新のWebアプリの画面を確認してみましょう。\n画面右上にある「デプロイ」ボタンをクリックし、メニュー内の「デプロイをテスト」を選択します。\n表示されたWebアプリのURLをクリックしてアプリケーションを起動しましょう。\n最新のWebアプリの画面が表示されれば成功です。\n注目して欲しいのはWebアプリのURLです。「デプロイをテスト」からアクセスしたURLの末尾は /dev になっているのに対し、\n公開しているURLの末尾は /exec になっています。\nこの2つのURLを使い分けて開発を進めていきましょう。\n/dev のURLはWebアプリを公開することで発行されます。発行されたURLは変わらないため、以降はプログラムを改修後は /dev のURLを表示した画面を更新（リロード）するだけで最新のWeb画面が確認できるようになります。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/calendar/page_3/",
	"title": "カレンダーを操作しよう",
	"tags": [],
	"description": "",
	"content": "カレンダーを作成しよう Google カレンダーでは複数のカレンダーを作ることができます。(この機能により、用途によってカレンダーを使い分けることができます。)\nGAS でカレンダーを作るには、GoogleAppsクラスの createCalendar メソッド を活用します。\nこのメソッドはパラメータとして カレンダー名 を指定する必要があります。\nメソッド名 パラメータ 戻り値 説明 createCalendar [String] カレンダーの名前 [Calendar] 作成したカレンダー ユーザーが所有する新しいカレンダーを作成します。 今回は以下のサンプルコードを実行して、旅行用のカレンダーを作成してみましょう。\nコード.gs function createCalendar() { const myCalendar = CalendarApp.createCalendar(\u0026#39;旅行用\u0026#39;); } サンプルコードが無事実行ができたら、Google カレンダーを再読み込みしてみましょう。\nすると、マイカレンダーの中に旅行用カレンダーが作成されていることが確認できます。\nカレンダーの情報を取得しよう カレンダーに予定を作るには、まずカレンダーを取得する必要があります。\nCalendarAppクラスの getAllCalendars メソッド を実行することで、Google カレンダー内にある全てのカレンダーを取得することができます。\nこのメソッドは Calendarクラスのオブジェクトを配列で返します。\nメソッド名 パラメータ 戻り値 説明 getAllCalendars なし [Calendar[]] 取得したカレンダーの配列 ユーザーが所有または購読しているすべてのカレンダーを取得します。 以下のサンプルコードは CalendarApp.getAllCalendars() の戻り値をループ処理で一つずつ取得して処理をしています。\nコード.gs function getAllCalendar() { // 全てのカレンダーを取得する const allCalendar = CalendarApp.getAllCalendars(); for (let i = 0; i \u0026lt; allCalendar.length; i++) { // カレンダーを一つずつ取得して、カレンダーの情報をログで出力する const calendar = allCalendar[i]; const id = calendar.getId(); const name = calendar.getName(); const descripion = calendar.getDescription(); console.log(id, name, descripion); } } サンプルコードの変数calendarには Calendarクラスのオブジェクトが格納されています。\nCalendarクラスはカレンダーの情報を取得するためのメソッドを提供しています。\nサンプルコードを実行すると、カレンダーのID、名前、説明がログで表示されますので確認してみましょう。\nメソッド名 パラメータ 戻り値 説明 getId なし [String] 取得したカレンダーの ID カレンダーの ID を取得します。 getName なし [String] 取得したカレンダーの名前 カレンダーの名前を取得します。 getDescription なし [String] 取得したカレンダーの説明 カレンダーの説明を取得します。 カレンダーの説明の確認方法\nカレンダーの説明はカレンダーの設定画面で確認することができます。\n対象のカレンダーにマウスカーソルを合わせると3点リーダーが表示され、クリックするとメニューが表示されます。\nこのメニュー内の「設定と共有」を選択すると、カレンダーの設定画面を表示することができます。\nまた、ある特定のカレンダーのみを取得することもできます。\nCalendarAppクラスの getCalendarById メソッド で特定のカレンダーを取得できます。\nこのメソッドはパラメータにカレンダーのIDを指定するため、特定のカレンダーを取得するには事前にカレンダーのIDを確認する必要があります。\n以下のサンプルコードはカレンダーを特定し、そのカレンダーの情報を取得してログに出力しています。\n\u0026lsquo;カレンダーのID\u0026rsquo; には先ほど作成した旅行用のカレンダーのIDを指定しましょう。\nコード.gs function getCalendarById() { // IDが一致するカレンダーを取得する const calendar = CalendarApp.getCalendarById(\u0026#39;カレンダーのID\u0026#39;); // 取得したカレンダーの情報を取得する const id = calendar.getId(); const name = calendar.getName(); const descripion = calendar.getDescription(); console.log(id, name, descripion); } メソッド名 パラメータ 戻り値 説明 getCalendarById [String] カレンダーのID [Calendar] 取得したカレンダー 指定された ID のカレンダーを取得します。 カレンダーのIDの確認方法\nカレンダーのIDはカレンダーの設定画面で確認することができます。\n対象のカレンダーにマウスカーソルを合わせると3点リーダーが表示され、クリックするとメニューが表示されます。\nこのメニュー内の「設定と共有」を選択すると、カレンダーの設定画面を表示することができます。\nカレンダーの情報を更新しよう カレンダーを特定することができれば、カレンダーの情報を更新することができるようになります。\nCalendarクラスの setName メソッド はカレンダーの名前を、\nCalendarクラスの setDescription メソッド はカレンダーの説明を更新することができます。\n以下のサンプルコードはカレンダーを取得した後にカレンダーの名前と説明を更新しています。\nサンプルコードを実行したのち、期待通りに Google カレンダーが更新されているかを確認してみましょう。\nコード.gs function updateCalendar() { // IDが一致するカレンダーを取得する const calendar = CalendarApp.getCalendarById(\u0026#39;カレンダーのID\u0026#39;); calendar.setName(\u0026#39;Updated Calendar\u0026#39;); calendar.setDescription(\u0026#39;This is updated by gas.\u0026#39;); } メソッド名 パラメータ 戻り値 説明 setName [String] カレンダーの名前 なし カレンダーの名前を設定します。 setDescription [String] カレンダーの説明 なし カレンダーの説明を設定します。 カレンダーを削除しよう カレンダーを特定することができれば、カレンダーを削除することもできます。\nCalendarクラスの deleteCalendar メソッド はカレンダーを削除することができます。\n以下のサンプルコードを実行すると特定したカレンダーが削除されます。\n\u0026lsquo;カレンダーのID\u0026rsquo; には先ほど更新した Updated Calendar カレンダーのIDを指定しましょう。\nコード.gs function deleteCalendar() { // IDが一致するカレンダーを取得する const calendar = CalendarApp.getCalendarById(\u0026#39;カレンダーのID\u0026#39;); calendar.deleteCalendar(); } メソッド名 パラメータ 戻り値 説明 deleteCalendar なし なし カレンダーを完全に削除します。自分が所有するカレンダーのみを削除できます。 "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_3/",
	"title": "HTMLを学ぼう",
	"tags": [],
	"description": "",
	"content": "HTMLとは 本章では、先ほどWeb画面を表示するのに使用したHTMLファイルについて掘り下げていきます。\nHTMLは Hyper Text Markup Language の略で、Webページの構造を作ることができます。\nChromeをはじめとするブラウザはこのHTMLを読み取って画面を形成して表示します。\nまた、HTMLは要素で様々な項目を表現することができ、この要素を タグ で記述することができます。\nHTMLには様々なタグがあるのですが、今回はその中で代表的なタグの使い方を学んでいきましょう。\nまずは、既に作成している以下のHTMLファイルに登場しているタグから確認していきましょう。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Web画面を変更しました! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; htmlタグ HTMLの文章であることを指定するタグであり、このタグで囲われた部分がHTMLを記述することができる範囲になります。\nこの範囲に様々なタグを記述することができます。\nheadタグ 文書のヘッダ部分を意味するタグで、このタグで囲われた範囲でHTMLファイルの情報を宣言することができます。\n後ほど学ぶことになる装飾の情報であるCSSはこの範囲で定義することになります。\nbodyタグ ブラウザの画面上に表示する内容を指定するタグです。このタグの中に書かれた内容が画面に表示されます。\nここからはbodyタグ内に書くことができるタグを学んでいきましょう。\nサンプルコードを書いて、Web画面で確認しながら進めていきましょう。\ndivタグ 単体では意味をなさないタグですが、同タグで囲った部分をグループ化することができます。\ndivタグで囲むことで文章の改行を表現することもできます。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;1つ目\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;2つ目\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; brタグ 「Break」の略で、文章を改行することができるタグです。終了タグが必要ないことが特徴です。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 1行目\u0026lt;br\u0026gt;2行目 \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; pタグ 「Paragraph」の略で、このタグに囲まれた文章は1つの段落（文章の塊）になります。\npタグによってできる改行と、brタグによってできる改行とでは見た目が若干異なるのでうまく使い分けましょう。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;こんにちは、山田太郎です！\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;好きなものはプログラミングで、\u0026lt;br\u0026gt;嫌いなものは静電気です。\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; tableタグ、thタグ、trタグ、tdタグ Web画面に表を作りたい場合はtableタグ内にthタグやtrタグ、tdタグを記述します。\nそれぞれのタグは以下の意味を持ちます。\n名称 タグの意味 thタグ ヘッダー行（テーブルの先頭行） trタグ 表の1行分のデータ tdタグ 表の1セル分のデータ 各タグを以下のように記述することで表を作ることができます。\n\u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;ヘッダー１\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;ヘッダー２\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;ヘッダー３\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;A1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;B1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;C1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;A2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;B2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;C2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; それでは、以下のサンプルコードを書いて、表を作ってみましょう。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;ヘッダー１\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;ヘッダー２\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;ヘッダー３\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;A1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;B1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;C1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;A2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;B2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;C2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; inputタグ ここまでは画面に表示する項目を作ってきましたが、inputタグはテキストの入力欄やボタンなどユーザーが操作することができるアイテムを作ることができます。\ntype属性に設定された値によって表示されるアイテムは変わります。\nまた、これらのinputタグは formタグ でグループ化することができます。\ntext属性 type属性にtextを指定するとテキストの入力欄（テキストボックス）を作ることができます。\nまた、value属性に値を入れると、入れた値が初期値として設定されます。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;初期値\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; password属性 type属性にpasswordを指定するとパスワードを入力するための入力欄を作ることができます。\n入力した文字が確認できないのが特徴です。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; value=\u0026#34;abc123\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; radio属性 type属性にradioを指定すると、複数の選択肢から1つだけを選択できるラジオボタンを作ることができます。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;A\u0026#34;\u0026gt;Aコース \u0026lt;input type=\u0026#34;radio\u0026#34; value=\u0026#34;B\u0026#34;\u0026gt;Bコース \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; checkbox属性 type属性にcheckboxを指定すると、複数の選択肢から複数を選択できるチェックボックスを作ることができます。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;A\u0026#34;\u0026gt;Aコース \u0026lt;input type=\u0026#34;checkbox\u0026#34; value=\u0026#34;B\u0026#34;\u0026gt;Bコース \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; button属性 type属性にbuttonを指定すると、クリックできるボタンを作ることができます。\nvalue属性に値を設定すると、その値がボタンの名前として表示されます。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;ボタン\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; コメント HTMLでも、JavaScriptと同様にコメントを残すことができます。 しかし、コメントの記法がJavaScriptとは異なるため注意が必要です。\n\u0026lt;!-- --\u0026gt;で囲まれた部分はブラウザには表示されないため、残しておきたいメモ書きやタグの一時的な無効化などをしたいときに活用できます。\n\u0026lt;!-- １行分のコメント --\u0026gt; \u0026lt;!-- 1行目のコメント 2行目のコメント --\u0026gt; "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/es2015/page_2_5_3/",
	"title": "アロー関数",
	"tags": [],
	"description": "",
	"content": "関数宣言の省略 これまで、関数を宣言するときはfunction() {}で表記してきましたが、\nES2015では「アロー関数」という表記法が追加されて以下の構文で関数を宣言できるようになりました。\nアロー関数は無名関数であり、アロー（矢）のように見える=\u0026gt;が特徴的ですね。\n() =\u0026gt; {}; これまでの関数の宣言方法と比べると、以下の違いがあり簡略化ができるようになりました。\nキーワードのfunctionを省略できる。 引数がひとつの場合は()を省略できる。 関数が1行の場合は{}とreturnを省略できる。 以下は関数内に通常の記法で宣言した関数（f1）とアロー関数として宣言した関数（f2）を実行するサンプルです。\nコード.gs function arrow_functions_1() { const f1 = function() { return \u0026#39;normal function\u0026#39;; }; console.log(f1()); const f2 = () =\u0026gt; \u0026#39;arrow function\u0026#39;; console.log(f2()); } normal function arrow function 先程のサンプルは関数内の処理が1行のみでしたが、アロー関数で複数行の処理をコーディングしたい場合は{}が必要になります。\nまた、値を返したい場合はreturnも必要になります。\nコード.gs function arrow_functions_2() { const f3 = () =\u0026gt; { const str = \u0026#39;arrow function\u0026#39;; return str; } console.log(f3()); } arrow function 関数に仮引数がある場合 関数が呼び出し元から値を受け取れるように仮引数を指定する場合、通常関数は以下のように書いていました。\nfunction(仮引数名1{, 仮引数名2, ...}){}; 一方、アロー関数は以下のように書きます。仮引数が1つの場合は()を省略することができます。\n// 仮引数が1つの場合 (仮引数名) =\u0026gt; {}; // 仮引数が1つの場合（省略記法） 仮引数名 =\u0026gt; {}; // 仮引数が複数の場合 (仮引数名1{, 仮引数名2, ...}) =\u0026gt; {}; 以下のサンプルを実行し、通常の関数もアロー関数もともに値を受け取れることを確認してみましょう。\nコード.gs function arrow_functions_3() { const name = \u0026#39;Taro\u0026#39;; const f1 = function(str) { console.log(`My name is ${str}.`); } f1(name); const f2 = str =\u0026gt; console.log(`His name is ${str}.`); f2(name); } My name is Taro. His name is Taro. 通常の関数と同じく、アロー関数も仮引数を複数指定することができます。\nしかし、仮引数が1つのときと違って()が必要になります。\nコード.gs function arrow_functions_4() { const num1 = 1; const num2 = 2; const f1 = function(a, b) { console.log(`normal function: ${a + b}`); } f1(num1, num2); const f2 = (a, b) =\u0026gt; console.log(`arrow function: ${a + b}`); f2(num1, num2); } normal function: 3 arrow function: 3 通常の関数とアロー関数の違い ここまではアロー関数を通常の関数と同様に使えると述べてきましたが、\nここではアロー関数が通常の関数と異なる点について説明します。\nアロー関数に名前をつけることができない アロー関数は無名関数のため、名前をつけることができません。\nそのため、アロー関数を実行するには変数に代入し、変数の後ろに()をつけて関数として実行する必要があります。\n名前付きの関数が必要な場合はこれまで通り通常の関数として宣言するようにしましょう。\nthis の振る舞いが異なる 通常の関数の場合 thisはオブジェクトを指しますが、\nアロー関数のthis はグローバル領域に宣言したthisを指します。(もし、グローバル領域にthisがない場合、this は undefined になります。)\nコード.gs // グローバル領域にthis.nameを宣言 this.name = \u0026#39;Ichiro\u0026#39;; function arrow_functions_5() { const person1 = { name: \u0026#39;Taro\u0026#39;, greet: function() { console.log(`Hello. My name is ${this.name}.`); } } person1.greet(); const person2 = { name: \u0026#39;Hanako\u0026#39;, greet: () =\u0026gt; console.log(`Hello. My name is ${this.name}.`) } person2.greet(); } Hello. My name is Taro. Hello. My name is Ichiro. 先程の例はメソッドをアロー関数にすると this はグローバル領域を指してしまうという例でしたが、\nメソッドを通常の関数として宣言するとその関数内の this はオブジェクトを指してくれます。\nコード.gs function arrow_functions_6() { const person3 = { name: \u0026#39;Hanako\u0026#39;, greet: function() { // 通常関数内であればアロー関数でもthisはperson3オブジェクトを指してくれます。 const getName = () =\u0026gt; this.name; console.log(`My name is ${getName()}.`); } } person3.greet(); } Hello. My name is Hanako. 上記以外にも違いがあるので、詳細は以下リンク先の公式リファレンスを確認してみましょう。\nアロー関数式 - MDN Web Docs "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_3/",
	"title": "clasp を使う前に",
	"tags": [],
	"description": "",
	"content": "前準備 1. Google Apps Script API を有効化しましょう 実は clasp をインストールしても、Google アカウントの設定で Google Apps Script APIを有効にしなければ clasp を利用することはできません。\n下記リンク先から Google Apps Script を有効化することができます。\nhttps://script.google.com/home/usersettings 設定画面の「Google Apps Script API 」の下に「オフ」と表示されていると、\nGoogle Apps Script API が無効化の状態になっています。\n「Google Apps Script API 」をクリックしますと、「オン」「オフ」を切り替える画面に遷移します。\n遷移先の画面で右端にトグルボタン表示されていますので、\nこちらをクリックして左端の文字が「オフ」から「オン」に変われば設定完了です。\n2. エディタをインストールしましょう お気に入りのエディタをインストールしましょう。\n基本的に好きなエディタを使っていただいても問題ありませんが、\n以降は VSCode でコーディングをしている前提で進めていくため、\n特にこだわりがなければ VSCode をインストールしてください。\nhttps://azure.microsoft.com/ja-jp/products/visual-studio-code/ 3. Node.js をインストールしましょう clasp を利用するにはPCに Node.js と呼ばれるJavaScriptの実行環境をインストールする必要があります。\n以下リンク先から Node.js をインストールしてください。\nhttps://nodejs.org/ja/ インストールを完了しましたら、以下のコマンドを実行して Node.js と npm がインストールされているかを確認しましょう。\nnpm は　Node.js　のパッケージを管理しており、そのパッケージの中に clasp があります。\n-vでインストールされているバージョンを確認することができます。\n以下のバージョンよりも新しければ問題ありません。\nnode -v v12.14.1 npm -v 6.13.4 4. clasp をインストールしましょう Node.js と npm がインストールされましたら、以下のnpmコマンドで clasp をインストールしましょう。\nnpm install @google/clasp -g これで前準備は完了です！\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_3/",
	"title": "スプレッドシートを操作する",
	"tags": [],
	"description": "",
	"content": "Spreadsheetクラスとは Spreadsheetクラス は、文字通りスプレッドシートを操作する機能を提供するクラスです。\nシートを取得したり作成したりするメソッドやスプレッドシートの情報など（メンバー）が提供されています。\nでは早速、Spreadsheetクラスのメンバーを使って、スプレッドシートの様々な情報を取得してみましょう。\n次のサンプルはスプレッドシートのID、スプレッドシート名、URLがログに出力されます。\nfunction spreadsheet_3() { var spreadsheet = SpreadsheetApp.getActiveSpreadsheet(); console.log(spreadsheet.getId()); // スプレッドシートのID console.log(spreadsheet.getName()); // スプレッドシートの名前 console.log(spreadsheet.getUrl()); // スプレッドシートのURL } シートを取得する Spreadsheetクラスはその配下であるシートを取得することができます。\nシートの取得方法は次のような方法があります。\nアクティブなシートを取得する シート名で特定して取得する インデックスで配列からシートを特定して取得する アクティブなシートは先ほど説明した通りコンテナバインドスクリプトに限り、SpreadsheetAppクラスから直接取得することができます。\n別な方法として、getSheetByNameメソッド を使用してシート名で特定して取得する方法があります。\nシート名で取得するのは簡単ではありますが、シート名が変わると取得できなくなる点に注意です。\nSpreadsheetオブジェクト.getSheetByName(シート名) 他にも、getSheetsメソッド でシートを配列として取得した上で、インデックスでシートを特定する方法もあります。\nSpreadsheetオブジェクト.getSheets() getSheetsメソッドは、スプレッドシートに含まれるシートのうち最も左に位置するシートのインデックスを0として、\nそこから右方向に順番にシートを配列に格納して取得します。\n戻り値が配列になりますので、全てのシートに処理を行いたい場合などに便利です。\nしかし、インデックスは並び順に依存しているため、\n特定のシートのみ処理をしたい（例えば左から2つめのシートのみ処理したい）場合はシートの並び順が変更された場合は意図したシートが処理されないことになります。\nそれでは、次のサンプルを実行して確認してみましょう。\nfunction spreadsheet_4() { var spreadsheet = SpreadsheetApp.getActiveSpreadsheet(); var sheet = spreadsheet.getSheetByName(\u0026#39;シート1\u0026#39;); console.log(sheet.getName()); var sheets = spreadsheet.getSheets(); console.log(sheets[0].getName()); console.log(sheets[1].getName()); } getNameメソッド はシート名を取得するメソッドです。getSheetsメソッドはシートを配列として取得するため、角括弧内にインデックスを用いて各シートを取り出すことができます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/",
	"title": "スプレッドシート編",
	"tags": [],
	"description": "",
	"content": "Chapter 3 スプレッドシート編 GASでスプレッドシートを操作してみよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/object_mechanism/page_2_4_3/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "ここまでオブジェクトの仕組みについてお伝えしてきました。\n本チャプターでお伝えした内容は、今後GASでの開発において独自のクラスを用意する際の基礎となるのはもちろん、\n以降でお伝えするGASで提供されているクラスについての習得スピードと理解度が増すものとなると思います。\nさあ、いよいよGASで開発する準備ができました。\n次のチャプターからスプレッドシートをGASで操作してみたいと思います。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/page_2_2_3/",
	"title": "例外処理でエラーを検知する",
	"tags": [],
	"description": "",
	"content": "例外処理とは GASではスクリプトを実行すると、想定しないエラーが発生することがあります。\n次のサンプルを実行するとエラーが発生して、スクリプトはその時点で止まってしまいます。\nこのように発生するエラーを例外といいます。\nコード.gs function outputException_1() { Browser.MsgBox(\u0026#39;Hello\u0026#39;); } TypeError: オブジェクト Browser で関数 MsgBox が見つかりません。 今回のサンプルは呼び出しているメソッド名に誤字があるため起こるべくしてエラーが起きていますが、\nユーザーの操作やGASの制限などエラーが発生する要因というのは多岐にわたります。\nこの全てを想定して処理が落ちないように完全に防ぐのは非常に難しいのですが、例外が発生したときにスクリプトが停止しないようにする 例外処理 が活躍します。\n例外処理を使用すると、例外の発生を検知して、発生したエラーに応じて処理を継続したり、処理を分岐したりすることができます。\nJavaScriptで例外処理を行う場合はtry catch finally文を使用し、下記のように記述します。\ntry { // 例外を検知する対象となる処理 } catch (変数) { // 例外が発生した際に実行する処理 } finally { // 例外が起きても起きなくても実行される処理 } 例外が起こりうる（検知したい）処理をtryブロックに記述します。\ntryブロック内で例外が発生した場合には、その時点で処理を中断してcatchブロックに処理が移ります。\nfinallyブロックは例外が起きても起きなくても実行される処理で、不要であれば省略することができます。\n先ほどのサンプルに例外処理を追加したのが次のサンプルになります。\nコード.gs function outputException_2() { try { Browser.MsgBox(\u0026#39;Hello\u0026#39;); } catch(e) { console.log(\u0026#39;例外が発生しました。: \u0026#39; + e.message); } finally { console.log(\u0026#39;スクリプトが完了しました！\u0026#39;); } } 例外が発生しました。: Browser.MsgBox is not a function スクリプトが完了しました！ 実行すると例外が発生するのですが、処理は止まらずにcatchブロック内の処理が実行され、その後finallyブロック内の処理が実行されます。\nサンプルコードで登場した変数eには、例外が発生したときに生成されるErrorオブジェクトが格納されています。\nErrorオブジェクトのmessageプロパティにはエラーメッセージが格納されているため、e.messageでエラーメッセージを取り出して表示しています。\nthrow文 発生した例外を受動的に検知して利用するだけではなく、throw文 を使用することでスクリプト内で能動的に例外を発生させることができます。\nこのように例外を能動的に発生させることを「例外をスローする」といいます。\nthrow new Error(\u0026#39;エラーメッセージ\u0026#39;); 次のサンプルを実行してみましょう。\n実行すると例外が発生し、エラーメッセージに「xに負の数が代入されました。」が表示されます。\nコード.gs function outputException_3() { var x = -1; if (x \u0026lt; 0) { throw new Error(\u0026#39;xに負の数が代入されました。\u0026#39;); } } throw文とtry catch文を組み合わせたのが次のサンプルです。\n変数xの値が負の数である場合に例外をスローして処理を分岐しています。\nコード.gs function outputException_4() { var x = -1; try { if (x \u0026lt; 0) { throw new Error(\u0026#39;xに負の数が代入されました。\u0026#39;); } } catch(e) { console.log(\u0026#39;例外が発生しました。: \u0026#39; + e.message); } } 例外が発生しました。: xに負の数が代入されました。 制御フローの例外 ここまで登場した制御フローの、通常の処理を変えることができる文を整理してみましょう。\n名称 文の意味 break文 ループを途中で抜ける。 continue文 ループ内の今回分の繰り返し処理を終了して、次回分の繰り返し処理に進む。 return文 現在の関数を終了する。（次章で解説します） throw文 例外ハンドラでキャッチする必要がある例外を示す。 "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/",
	"title": "制御構文を学ぼう",
	"tags": [],
	"description": "",
	"content": "Chapter 2 - 3 JavaScriptの制御構文 JavaScriptの制御構文を学びましょう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page_2_1_3/",
	"title": "コメント",
	"tags": [],
	"description": "",
	"content": "コメントとは コメント とは、スクリプト内のメモ書きのことをいいます。\nこのコメントはスクリプトの実行時には無視されるため、実行されることはありません。\nでは、どのようなときにこのコメントを使うのでしょうか？\n例えばですが、しばらく期間をあけてコードを読み返した際に、自身がどのような考えで実装したのか思い出すのは大変です。\nそのようなときにコメントが書かれているとこのような苦労をせずに済みます。\n同様に、自身ではなく他の人にソースを読んでもらうことがあった場合も、\n自身がどのような考えで実装したのかを伝えることができます。\nこのように、コメントを活用することで、\nプログラムを作った人自身、もしくはあとで読む人（将来の自分を含む）がわかるように説明を書き残すことができます。\nなお、JavaScriptのコメントは２種類あります。\nそれぞれのコメントを使い方について解説していきます。\nインラインコメント 「//」で始まる記述はその行の終わりまでコメントとして扱われます。\n1行のみコメントにしたい場合は、その文頭に「//」を入れることでコメントにすることができます。\nコード.gs function myFunction() { // 実行されないので半角英数字や半角記号以外の文字を入れることができます。 console.log(\u0026#39;Hello GAS!\u0026#39;); // 行の後ろにも入れることができます。 } ブロックコメント 「/* 」で始まる文字列は「*/」までの記述をコメントとして扱います。\nこれにより、複数行にわたるコメントを書くことができます。\nコード.gs function muFunction() { /* 1行目 2行目 */ console.log(\u0026#39;Hello GAS!\u0026#39;); } コメントの活用方法 コーディングをしていて、「このステートメントは今は実行したくないな」というときにもコメントは活躍します。\n実行したくないステートメントをコメントにすることで実行されないようにすることができます。\nこのように一時的にコメントにすることを「コメントアウト」といいます。\nコード.gs // 2回目のconsole.log()は実行したくない場合 function myFunction() { console.log(\u0026#39;Hello GAS!\u0026#39;); // 2回目のconsole.log()をコメントアウト // console.log(\u0026#39;Hello GAS!\u0026#39;); } コメントアウトはショートカットキーがあり、コメントアウトしたい行を選択した上で、\nWindonwsはCtrl + /、Macはcontrol + /でコメントアウトをすることができます。\n逆にコメントを解除したい場合も同じ手順で行うことができます。\nCSSのコメントはJavaScriptのブロックコメントと同じ形式で、インラインコメントは使うことができません。\nHTMLもコメントはインラインコメントはなく、ブロックコメントがありますが、JavaScriptとは違い \u0026lt;!-- と　--\u0026gt; で囲まれます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_3/",
	"title": "前準備をしよう",
	"tags": [],
	"description": "",
	"content": "まずは開発環境を整えましょう。\nとは言っても、GASはローコードプラットフォームであるためほとんど手間がかかりません。\nGoogleアカウントでログイン まずはGoogle アカウントでログインをしましょう。\nGoogle アカウントは一つですが、ログインするところは2つあります。\nGoogle Chrome にログイン Google のサービス（G Suite）にログイン 実は「Google のサービス（G Suite）にログイン」のみでGASは利用できるのですが、\nGoogle Chrome へログインしているアカウント と　Google のサービス（G Suite）にログインしているアカウント が不一致の場合、\n意図しない挙動を起こすことがあります。\n必ず Google Chrome へログインしているアカウント と Google のサービス（G Suite）にログインしているアカウント が一致していることを確認した上でこの先の手順を進めていきましょう。\nGoogle Chrome を起動します。\nGoogle Chrome にログインします。\nGoogle Chrome のURLバーに「google.com」と入力してEnterキーを押します。\nGoogleホーム画面の右上にある「ログイン」ボタンをクリックします。\nGoogle Chrome にログインします。\nスプレッドシートを開く 今回のハンズオンではスプレッドシートからスクリプトエディタを開いてみましょう。\nGoogle ドライブを起動します。\nGoogle ドライブの画面の左上にある「新規」ボタンをクリックします。\n表示されたメニュー内から「Google スプレッドシート」を選択します。\nスクリプトエディタを開く それでは、いよいよ スクリプトエディタ を開きます。\nスクリプトエディタ は、GASのスクリプトの編集、実行、デバックなどを行うことができるエディタで、便利な機能が多数搭載されています。\nメニューから[拡張機能]\u0026gt;「Apps Script」を選択します。\nエディタが表示されればOKです。\nプロジェクト名を設定する。 この先の手順を進めるためには、まずプロジェクト名を設定する必要があります。\nプロジェクト名は画面左上に表示されていて、デフォルトでは「無題のプロジェクト」となっています。\n「プロジェクトってなんだろう？」と疑問に思われるでしょうが、\nこれから作成するGASファイルをまとめているフォルダのようなイメージになります。\nプロジェクト名は自由につけていただいて構わないのですが、\n今回のハンズオンではプロジェクト名を「はじめてのGAS」と設定しましょう。\nプロジェクト名をクリックする。\nプロジェクト名を入力して、「OK」ボタンをクリックする。\nプロジェクト名が設定されれば成功です。\nこれでGASでコーディングするための準備は完了です！\nいよいよGASでコーディングをしていきましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/calendar/page_4/",
	"title": "予定を操作しよう",
	"tags": [],
	"description": "",
	"content": "予定を作成しよう いよいよカレンダーの予定を作ってみましょう。\nカレンダーの予定を作るには、まず予定を作成するカレンダーを取得する必要があります。\nカレンダーを取得できたら、Calendarクラスの [createEvent メソッド]で予定を作りましょう。\nCalendar.createEventメソッドを実行するには以下の３つの引数を指定する必要があります。\n予定のタイトル 予定の開始日時 予定の終了日時 以下のサンプルコードは「タイトルが New Event」で、「予定の時間が2022年9月1日の9時〜10時」の予定を作成しています。\nサンプルコードの \u0026lsquo;カレンダーのID\u0026rsquo; には任意のカレンダーのIDを指定しましょう。\nサンプルコードを実行したら、Google カレンダー上に予定が作成されているかを確認してみましょう。\nコード.gs function createEvent() { // IDが一致するカレンダーを取得する const calendar = CalendarApp.getCalendarById(\u0026#39;カレンダーのID\u0026#39;); const title = \u0026#39;New Event\u0026#39;; const startTime = new Date(\u0026#39;2022-09-01 09:00:00\u0026#39;); const endTime = new Date(\u0026#39;2022-09-01 10:00:00\u0026#39;); calendar.createEvent(title, startTime, endTime); } Calendar クラスのメソッド メソッド名 パラメータ 戻り値 説明 createEvent [String] 予定のタイトル、[Date] 予定の開始日時、[Date] 予定の終了日時 [CalendarEvent] 作成されたイベント 新しいイベントを作成します。 予定の情報を取得しよう 続いて、先ほど作成した予定を GAS で取得してみましょう。\nCalendarクラスの getEvents メソッド で、対象のカレンダーの予定を取得することができます。\nCalendar.getEvents メソッドは パラメータで取得する予定の範囲を指定することができ、開始日時と終了日時を指定します。\n以下のサンプルコードを実行すると、2022年9月1日の予定を取得することができます。\nサンプルコードの \u0026lsquo;カレンダーのID\u0026rsquo; には任意のカレンダーのIDを指定しましょう。\nコード.gs function getEvents() { // IDが一致するカレンダーを取得する const calendar = CalendarApp.getCalendarById(\u0026#39;カレンダーのID\u0026#39;); // 2022年9月1日のカレンダーの予定を取得する const events = calendar.getEvents(new Date(\u0026#39;2022-09-01 00:00:00\u0026#39;), new Date(\u0026#39;2022-09-01 23:59:59\u0026#39;)); for (let i = 0; i \u0026lt; events.length; i++) { const event = events[i]; const title = event.getTitle(); const startTime = event.getStartTime(); const endTime = event.getEndTime(); const location = event.getLocation(); const description = event.getDescription(); console.log(event, title, startTime, endTime, location, description); } } Calendar クラスのメソッド メソッド名 パラメータ 戻り値 説明 getEvents [Date] 取得する予定の範囲の開始日時、[Date] 取得する予定の範囲の終了日時 [CalendarEvent[]] 指定した時間範囲内で作成されたイベント 特定の時間範囲内に発生するすべてのイベントを取得します。 CalendarEvent クラスのメソッド メソッド名 パラメータ 戻り値 説明 getTitle なし [String] 取得したイベントのタイトル イベントのタイトルを取得します。 getStartTime なし [Date] 取得したイベントの開始時刻 イベントの開始時刻を取得します。 getEndTime なし [Date] 取得したイベントの終了時刻 イベントの終了時刻を取得します。 getLocation なし [String] 取得したイベントの場所 イベントの場所を取得します。 getDescription なし [String] 取得したイベントの説明 イベントの説明を取得します。 予定の情報を更新しよう 取得した予定はその内容を更新することができます。\n更新対象の予定を特定できたのであれば、各メソッドで予定の内容を変更することができます。\n以下のサンプルコードを実行すると、2022年9月1日の予定のうち、タイトルが New Event の予定の内容が更新されます。\nサンプルコードの \u0026lsquo;カレンダーのID\u0026rsquo; には任意のカレンダーのIDを指定しましょう。\nコード.gs function updateEvent() { // IDが一致するカレンダーを取得する const calendar = CalendarApp.getCalendarById(\u0026#39;カレンダーのID\u0026#39;); // 2022年9月1日のカレンダーの予定を取得する const events = calendar.getEvents(new Date(\u0026#39;2022-09-01 00:00:00\u0026#39;), new Date(\u0026#39;2022-09-01 23:59:59\u0026#39;)); for (let i = 0; i \u0026lt; events.length; i++) { // カレンダーの予定を取得する const event = events[i]; if (event.getTitle() === \u0026#39;New Event\u0026#39;) { event.setTitle(\u0026#39;Updated Event\u0026#39;); event.setTime(new Date(\u0026#39;2022-09-01 15:00:00\u0026#39;), new Date(\u0026#39;2022-09-01 16:00:00\u0026#39;)); event.setLocation(\u0026#39;Tokyo\u0026#39;); event.setDescription(\u0026#39;This is updated by gas.\u0026#39;); } } } CalendarEvent クラスのメソッド メソッド名 パラメータ 戻り値 説明 setTitle [String] イベントの新しいタイトル なし イベントのタイトルを設定します。 setTime [Date] イベントの新しい開始時刻、[Date] イベントの新しい終了時刻 なし イベントの開始時刻を設定します。 setLocation [String] イベントの新しい場所 なし イベントの場所を設定します。 setDescription [String] イベントの新しい説明 なし イベントの説明を設定します。 予定を削除しよう 最後に GAS で予定を削除してみましょう。\nCalendarクラスの deleteEvent メソッド を実行すると、対象の予定を削除することができます。\n以下のサンプルコードは2022年9月1日の予定のうち、タイトルが Updated Event の予定が削除されます。\nサンプルコードの \u0026lsquo;カレンダーのID\u0026rsquo; には任意のカレンダーのIDを指定しましょう。\nコード.gs function deleteEvent() { // IDが一致するカレンダーを取得する const calendar = CalendarApp.getCalendarById(\u0026#39;カレンダーのID\u0026#39;); // 2022年9月1日のカレンダーの予定を取得する const events = calendar.getEvents(new Date(\u0026#39;2022-09-01 00:00:00\u0026#39;), new Date(\u0026#39;2022-09-01 23:59:59\u0026#39;)); for (let i = 0; i \u0026lt; events.length; i++) { // カレンダーの予定を取得する const event = events[i]; if (event.getTitle() === \u0026#39;Updated Event\u0026#39;) { event.deleteEvent(); } } } CalendarEvent クラスのメソッド メソッド名 パラメータ 戻り値 説明 deleteEvent なし なし イベントを削除します。 "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/calendar/",
	"title": "Google カレンダー編",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Google カレンダー編 GASでGoogleカレンダーを操作してみよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_4/",
	"title": "CSSを学ぼう",
	"tags": [],
	"description": "",
	"content": "CSSとは CSSはWebページの装飾をすることができます。これまでは質素なデザインのWebページしか作ることができませんでしたが、\nCSSを活用すると自由にWebページのレイアウトを設定できるようになります。\nCSSは Cascading Style Sheetsの略で、以下のいずれかの方法でCSSを書くことができます。\n外部ファイルのCSSファイルを作成して書く styleタグの範囲内に書く GASプロジェクトではGSファイルか、HTMLファイルしか作れないため、\n必然的に「styleタグの範囲内に書く」ことになります。\nstyleタグは以下のようにheadタグ内に書くことができます。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSSを活用するにあたり、HTMLのidとclassの使い分けを理解する必要があります。\ncolorプロパティで実際に文字の色を変えながら確認してみましょう。\nHTMLのid属性 id属性は任意の1つのタグを特定するために使用します。そのため、HTMLファイル内でid属性は重複しないようにすることが望ましいです。\n以下のサンプルコードでは、Aコースは赤色、Bコースは青色となるようにCSSを設定しています。\nid属性を指定してCSSを設定する場合は、id属性の前に # を付けます。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; #A { color: red; } #B { color: blue; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;A\u0026#34;\u0026gt; Aコース \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;B\u0026#34;\u0026gt; Bコース \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; HTMLのclass属性 class属性は複数のタグをグループ化するために使用します。そのため、HTMLファイル内でclass属性が重複しても問題はありません。\n以下のサンプルコードでは、AコースもBコースも同じclass属性のため同じCSSが適用されます。\nclass属性を指定してCSSを設定する場合は、class属性の前に . を付けます。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; .course { color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;course\u0026#34;\u0026gt; Aコース \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;course\u0026#34;\u0026gt; Bコース \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1つのタグにid属性とclass属性の両方を設定することもできますが、この場合はclass属性よりもid属性の方が優先されます。\nそれでは代表的なCSSを実際に書いてみましょう。\ncolorプロパティ テキストの色を指定することができるプロパティです。\n色の種類は英字で指定することができますが、カラーコードで指定することもできます。\nカラーコードは # の後ろに6文字の英数字の形式で書くことができます。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; .course { color: #4b0082; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;course\u0026#34;\u0026gt; Aコース \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;course\u0026#34;\u0026gt; Bコース \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; background-colorプロパティ 背景の色を指定することができるプロパティです。\n色の指定方法はcolorプロパティと同じです。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; #A { background-color: #fa8072; } #B { background-color: #6495ed; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;A\u0026#34;\u0026gt; Aコース \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;B\u0026#34;\u0026gt; Bコース \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; font-sizeプロパティ 文字の大きさを指定することができるプロパティです。\n大きさの指定方法は 数値+単位(px, %, pt, em) です。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; #A { font-size: 20px; } #B { font-size: 50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;A\u0026#34;\u0026gt; Aコース \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;B\u0026#34;\u0026gt; Bコース \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; widthプロパティ、heightプロパティ widthプロパティで幅を、heigthプロパティで高さを設定することができます。\n大きさの指定方法はfont-sizeプロパティと同じく、 数値+単位(px, %, pt, em) です。\n※ 目視でわかりやすいように背景色も設定しています。 複数のプロパティを設定する場合は、プロパティの最後をセミコロンにする必要があります。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; #A { background-color: #fa8072; width: 100px; } #B { background-color: #6495ed; height: 50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;A\u0026#34;\u0026gt; Aコース \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;B\u0026#34;\u0026gt; Bコース \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; marginプロパティ、paddingプロパティ marginプロパティは内側の余白、paddingプロパティは外側の余白を設定することができます。\n大きさの指定方法はfont-sizeプロパティと同じく、 数値+単位(px, %, pt, em) です。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; .course { margin: 100px; padding: 50px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;course\u0026#34;\u0026gt; Aコース \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;course\u0026#34;\u0026gt; Bコース \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Web画面で右クリックして、メニュー内の「検証」を選択すると要素に設定されている余白を確認できます。\nborderプロパティ 表の上下左右のボーダーラインの太さ、色などを一括でまとめて指定することができるプロパティです。\nプロパティ名を指定したのち、ボーダーラインの太さ・ボーダーラインの種類・ボーダーラインの色の順に指定します。\n設定の種類 指定方法 ボーダーラインの太さ 数値+単位(px, pt, em) ボーダーラインの種類 solid : 実線　double：二重線　dotted：点線 dashed：破線 など ボーダーラインの色 文字の色の英字やカラーコード また、borderプロパティのみで、テーブルのレイアウトを設定すると線と線の間に隙間ができてしまいます。\n隙間を無くして1つの線にしたい場合はtableに border-collapse: collapse を指定する必要があります。\nこれまではid属性もしくはclass属性を使用してCSSを適用してきましたが、実はタグ名で指定することもできます。\n以下のように「tableのth」の場合はtable th、「tableのtd」の場合はtable tdと指定します。\nまた、複数の要素に対して同じCSSを適用する場合は要素間をカンマで区切ります。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; table { border-collapse: collapse; } table th, table td { border: 3px solid red } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;ヘッダー１\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;ヘッダー２\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;ヘッダー３\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;A1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;B1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;C1\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;A2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;B2\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;C2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; コメント CSSもJavaScriptと同様にコメントを書くことができます。\n記法はJavaScriptと同じで、1行のみの場合は //、複数行の場合は/** **/で記述することができます。\n\u0026lt;style\u0026gt; // テーブルの線を1つにまとめる table { border-collapse: collapse; } /** * テーブルのヘッダーとデータに以下のスタイルを設定する * ・太さは3px * ・種類は実線 * ・色は赤色 */ table th, table td { border: 3px solid red } \u0026lt;/style\u0026gt; "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/es2015/page_2_5_4/",
	"title": "class構文",
	"tags": [],
	"description": "",
	"content": "クラスとは クラスを一言で表すと「オブジェクトの雛形（テンプレート）」です。\nクラスはオブジェクトの 属性（プロパティ） と 機能（メソッド） を定義することができます。\n例えば、人間をクラスで定義した場合、\n名前や年齢などの情報を持ちますがこれは人間の属性（プロパティ）にあたります。\n属性（プロパティ）は人間によって同じ場合もあれば異なる場合もあります。\nまた、人間は挨拶をしたり、食事をしたりしますがこれは機能（メソッド）にあたります。\n皆同じ機能を持ちますが、人間によっては結果が異なる場合がありますね。\nこのようにクラスはデータの抽象的な概念を表現する際に活躍します。\nクラスはあくまで「オブジェクトの雛形（テンプレート）」であるため、\n実際に動かす際はクラスをもとに インスタンス（実体） を生成し、このインスタンスに属性（プロパティ）を設定し機能（メソッド）を実行します。\nこれは、人間の設計書（クラス）をもとに人間（インスタンス）を作っているというイメージです。\nクラスの定義 ES2015でクラスを表現するためのclass構文が導入されました。\nclass構文では class キーワードを用いてクラス名を付けて宣言します。\nまた、クラスは コンストラクター（constructor） と呼ばれる特殊なメソッドを持ちます。\nコンストラクターはインスタンスが生成されるときに自動的に呼び出されるメソッドであり、\nインスタンスの初期化処理（プロパティの値の設定など）を行うことができます。\nコンストラクターは省略することができますが、この場合は空っぽのコンストラクターが定義されることになります。\nなお、クラスに定義できるコンストラクターは1つまでです。\nクラスを宣言する方法はクラス宣言とクラス式の２種類があります。\n以下はクラス宣言の構文です。\nclass クラス名 { constructor(仮引数名1{, 仮引数名2...}) { // 同クラスのインスタンスが生成されるとき、インスタンスごとに自動的に呼び出される } } もう一つの宣言方法のクラス式の構文は以下の通りです。\nクラス式は変数に代入する形式となり、無名関数として扱うことができるためクラス名を省略することができます。\n// クラスを値として定義し、変数に代入 const 変数名 = class クラス名 { constructor(仮引数名1{, 仮引数名2...}) {} } // 無名関数としてクラス名を省略して定義 const 変数名 = class { constructor(仮引数名1{, 仮引数名2...}) {} } JavaScriptではクラス名の先頭の文字を大文字で書くことが慣習になっています。\nこの慣習を守ることで、小文字で書くインスタンス名と大文字で書くクラス名は、一目で区別をつけることができます。\nクラスを使うメリット これまではオブジェクトが必要になった際は、以下のようにその都度プロパティやメソッドを定義していました。\nしかし、このコーディング方法はほとんど同じ内容のコードを書かないといけない上、\nメソッドを増やすことになった場合は非常に手間がかかります。\nコード.gs function object_pattern() { const human1 = { name: \u0026#39;Taro\u0026#39;, greet: function() { console.log(`Hello. My name is ${this.name}`); } } const human2 = { name: \u0026#39;Hanako\u0026#39;, greet: function() { console.log(`Hello. My name is ${this.name}`); } } human1.greet(); // Hello. My name is Taro human2.greet(); // Hello. My name is Hanako } 一方、クラスはこの問題を解消してくれます。\n以下は先ほどのサンプルをclass構文を使って書き直したサンプルです。\n仮にメソッドを増やすことになったとしても、Humanクラスにメソッド追加することで、\n各インスタンスは共通のメソッドを呼び出すことができます。\nまた、クラス内でthisはクラスを元に生成されたインスタンスのことを指します。\n以下のサンプルには名前がTaroの人間クラスのインスタンスと名前がHanakoの人間クラスのインスタンスが生成されています。\nインスタンスを生成するには new クラス名() と記述します。\n※) クラスは変数や関数と同様にグローバル領域に定義することができます。\nコード.gs class Human { constructor(name) { this.name = name; } greet() { console.log(`Hello. My name is ${this.name}`); } } function classes_pattern_1() { const human1 = new Human(\u0026#39;Taro\u0026#39;); const human2 = new Human(\u0026#39;Hanako\u0026#39;); human1.greet(); // Hello. My name is Taro human2.greet(); // Hello. My name is Hanako } アクセッサプロパティ 通常、クラスに定義したメソッドは インスタンス.メソッド名() で実行することができますが、\nインスタンスのプロパティの参照（getter）と代入（setter）をする特殊なメソッドは インスタンス.プロパティ名 で実行することができます。\nこのようにプロパティを制御するメソッドをアクセッサプロパティといいます。\nアクセッサプロパティは対象のメソッド名の前にgetまたはsetをつけることで定義できます。\ngetをつけたメソッドはプロパティの参照ができるようになり、仮引数は不要ですが必ず値を返す必要があります。\n一方、setを付けたメソッドはプロパティに代入ができるようになり、値を返す必要はありませんが仮引数は必要になります。\nclass クラス { get プロパティ名() { return 値; } set プロパティ名(仮引数) { // プロパティの代入などのsetterの処理 } } 先ほどのサンプルコードのHumanクラスをアクセッサプロパティでコーディングすると以下の通りになります。\nクラス内のプロパティを指しているthis.nameをthis._nameとしているのには理由があります。\nthis.nameが呼ばれるとgetterが動くのですが、このgetterもまたthis.nameを呼んでいるのです。\nそのため、同じ関数がひたすら呼ばれることによりRangeError: Maximum call stack size exceededが発生してしまいます。\nこのエラーを回避するため、プロパティをthis._nameとコーディングする必要があるのです。\nコード.gs class Human { constructor(name) { this._name = name; } greet() { console.log(`Hello. My name is ${this.name}`); } get name() { return this._name; } set name(name) { this._name = name; } } function classes_pattern_2() { const human = new Human(\u0026#39;Yamada Taro\u0026#39;); human.name = \u0026#39;Suzuki Taro\u0026#39;; // setterでYamada TaroからSuzuki Taroに改名 console.log(human.name); // getterで改名後の名前を取得 } Suzuki Taro プロトタイプ 全ての関数はprototypeと呼ばれる特別なプロパティを持っています。\nこのprototypeの仕組みにより、クラスに対して定義したメソッドは各インスタンスで利用できるメソッドになります。\nこのように各インスタンスで共有で利用できるメソッドは プロトタイプメソッド（インスタンスメソッド） と呼ばれています。\n先ほどのサンプルコードではgreetメソッドを定義していましたが、\nこのメソッドを各インスタンスが利用できるのはプロトタイプメソッドとして定義しているためです。\nプロトタイプメソッドは以下のように定義して呼び出すことができます。\nclass クラス名 { メソッド名() { } } const インスタンス名 = new クラス名(); インスタンス名.メソッド名(); また、生成したインスタンスに対してメソッドやプロパティを定義することができます。\n同じ名前のメソッドやプロパティを宣言すると、プロトタイプメソッドよりもインスタンス生成後にインスタンスに対して追加したメソッドやプロパティが優先されます。\n追加したメソッドやプロパティは対象のインスタンスのみで利用可能で、同クラスの別インスタンスでは利用することはできません。\nコード.gs class Human { constructor(name) { this._name = name; } greet() { console.log(`Hello. My name is ${this.name}`); } get name() { return this._name; } set name(name) { this._name = name; } } function classes_pattern_3() { const human1 = new Human(\u0026#39;Taro\u0026#39;); const human2 = new Human(\u0026#39;Hanako\u0026#39;); // human1にメソッドを再定義・追加する human1.greet = function() { console.log(`I am ${human1.name}`); } human1.shout = function() { console.log(\u0026#39;Hello!!!\u0026#39;); } // 各インスタンスのメソッドを実行する human1.greet(); // I am Taro human1.shout(); // Hello!!! human2.greet(); // Hello. My name is Hanako human2.shout(); // TypeError: human2.shout is not a function } 静的メソッド（クラスメソッド） ここまで紹介したメソッドはインスタンスごとに実行することができるインスタンスメソッドでしたが、\nここではクラスをインスタンス化せずに使用する 静的メソッド（クラスメソッド） を紹介します。\n静的メソッドは特定のインスタンスに関わることなく、クラスに関係する処理を実行することができるメソッドです。\n静的メソッドの定義方法はメソッド名の前にstaticをつけるだけで、\n静的メソッドはインスタンス名.メソッド名ではなくクラス名.メソッド名で呼び出すことができます。\nclass クラス名 { static メソッド名() { // 静的メソッドの処理 } } // 静的メソッドの呼び出し クラス名.メソッド名(); それでは、静的メソッドがどのような場面で活躍するかを紹介します。\n例えば、Humanクラスから生成されたインスタンスの数を管理したい場合、\n各インスタンスではなくクラスでインスタンスの数を管理する必要があります。\n以下のサンプルコードではHumanクラスのインスタンスが生成されるたびに静的メソッドを実行してインスタンスの数をカウントしています。\nコード.gs class Human { constructor(name) { this._name = name; // インスタンスが生成されるたびに静的メソッドを実行 Human.getCounter(); } // Human.countプロパティを加算する静的メソッド static getCounter() { return Human.count++; } greet() { console.log(`Hello. My name is ${this.name}`); } get name() { return this._name; } set name(name) { this._name = name; } } // クラス共通のプロパティを設定 Human.count = 0; function classes_pattern_4() { new Human(\u0026#39;Taro\u0026#39;); new Human(\u0026#39;Hanako\u0026#39;); new Human(\u0026#39;Ichiro\u0026#39;); console.log(Human.count); } 3 継承 クラスのインスタンスを生成すると、クラスのプロトタイプがもつ機能を「継承」します。\n継承とは、クラスの構造や機能を引き継いだ新しいクラスを定義することです。\n仮にオブジェクトのプロトタイプに呼び出そうとしたメソッドが見つからない場合は、\n同クラスが継承している スーパークラス（親クラス） で同じ名前のメソッドがないかを探します。\n同じ名前のメソッドが見つかるまでスーパークラス（親クラス）を遡っていき、一番上まで遡っても見つからない場合はエラーとなります。\nこのようにオブジェクト自身のプロトタイプを追っていくことはプロトタイプチェーンと呼ばれています。\nこのプロトタイプチェーンにより、クラスの間に階層関係を構築することができます。\nextendsキーワードを使い、以下の構文で書くことで既存のクラスを継承することができます。\nclass構文の右辺にextendsキーワードで継承元となるスーパークラス（親クラス）を指定することで、 スーパークラスを継承した サブクラス（子クラス） を定義できます。\nサブクラスのインスタンスは、通常のインスタンスの作成方法と同じくnew演算子をクラス名の前に記述することで作成することができます。\nclass 子クラス名 extends 親クラス名 { } const child = new 子クラス名(); 以下のサンプルコードはスーパークラスである Animal クラスと、\nAnimalクラスを継承するサブクラス（子クラス）のDogクラスとCatクラスをコーディングしています。\nサブクラスのコンストラクタに super() が実行されていますが、\nこのsuper()でextendsを使って定義したサブクラスからスーパークラスを参照することができます。\nサンプルコードではスーパークラスのコンストラクタを参照して実行しています。\nコード.gs class Animal { constructor(categoryName) { this.category = categoryName; this.name; console.log(`${this.category}が産まれた`); } walk() { console.log(`${this.name}が歩いた`); } // 吠える・鳴くメソッド bark() { console.log(`${this.name}が吠えた`); } } /** * 犬は動物のサブクラス */ class Dog extends Animal { constructor() { // スーパークラス（Animalクラス）のコンストラクタを呼び出す super(\u0026#39;犬\u0026#39;); this.name; } setName(name) { this.name = name; } // スーパークラス（Animalクラス）のメソッドを上書き bark() { console.log(\u0026#39;ワン！\u0026#39;); } // サブクラス固有のメソッドを追加 bite() { console.log(`${this.name}は噛み付いた`); } } /** * 猫は動物のサブクラス */ class Cat extends Animal { constructor() { // スーパークラス（Animalクラス）のコンストラクタを呼び出す super(\u0026#39;猫\u0026#39;); this.name; } setName(name) { this.name = name; } // スーパークラス（Animalクラス）のメソッドを上書き bark() { console.log(\u0026#39;ニャ〜\u0026#39;); } // サブクラス固有のメソッドを追加 scratch() { console.log(`${this.name}は引っ掻いた`); } } 先ほどのDogクラスとCatクラスからインスタンスを生成し、メソッドを実行しているのが以下のサンプルコードです。\nDogクラスから生成したインスタンスにはPochiという名前を、Catクラスから生成したインスタンスにはTamaという名前をつけ、\nそれぞれのメソッドを実行しています。\nコード.gs function classes_pattern_5() { const dog = new Dog(); const cat = new Cat(); // スーパークラスの共通のメソッドを呼び出す dog.setName(\u0026#39;Pochi\u0026#39;); dog.walk(); cat.setName(\u0026#39;Tama\u0026#39;); cat.walk(); // 上書きされたスーパークラスの共通メソッドを呼び出す dog.bark(); cat.bark(); // 各クラスの固有のメソッドを呼び出す dog.bite(); cat.scratch(); } 犬が産まれた 猫が産まれた Pochiが歩いた Tamaが歩いた ワン！ ニャ〜 Pochiは噛み付いた Tamaは引っ掻いた このように、継承によりオブジェクトなどのデータ型に関する操作が統一的であることをポリモーフィズムと呼びます。\nまた、JavaScriptにはinstanceof演算子で左辺の値が右辺のクラスのインスタンスであるかを真偽値で返してくれます。\ninstanceof演算子は右辺にスーパークラスが指定された場合はtrueを返します。\nコード.gs function classes_pattern_6() { const dog = new Dog(); // 犬が産まれた const cat = new Cat(); // 猫が産まれた console.log(dog instanceof Dog); // true console.log(cat instanceof Cat); // true console.log(dog instanceof Cat); // false console.log(cat instanceof Dog); // false console.log(dog instanceof Animal); // true console.log(cat instanceof Animal); // true } 犬が産まれた 猫が産まれた true true false false true true JavaScriptのすべてのオブジェクトはルートクラスであるObjectのインスタンスになります。\nそのため、任意のオブジェクト o に対し、o instanceof Objectの結果はtrueになります。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_4/",
	"title": "clasp を使ってみよう",
	"tags": [],
	"description": "",
	"content": "ログイン・ログアウト Webエディタを使用する際と同様に Google アカウントでログインする必要があります。\nWebエディタにアクセスできない Google アカウントでログインをすると clasp でも利用することができないため、\nどの Google アカウントでログインしているかを意識するようにしましょう。\nclasp login 🔑 Authorize clasp by visiting this url: https://accounts.google.com/o/oauth2/v2/auth?access_type=offline\u0026amp;scope=https%3A%2F%2Fwww.googleapis.com... clasp にログインするアカウントを切り替える場合は一度ログアウトする必要があります。\nログアウト後に再度ログインしたいアカウントでログインを行いましょう。\nclasp logout GASプロジェクトの新規作成 clasp で新規のプロジェクトを作成することができます。\nコマンドの最後にはプロジェクト名を指定します。\n※今回はプロジェクト名を newProject としています。\nclasp create newProject コマンドが正常終了すると、作成されたプロジェクトのURLが表示されます。\nこのURLをブラウザに貼り付けてアクセスすることができますが、\n次のコマンドを実行するだけで開くことができます。\nclasp open ここでローカル環境を確認してみましょう。\n以下の２ファイルが生成されていることが確認できます。\n.clasp.json appsscript.json clasp.json はローカル環境とクラウド上のWebエディタを紐付けている重要なファイルです。\nappsscript.json はGASプロジェクトの情報を持っているファイルです。\nこのファイルは実はこれまで作成してきたGASプロジェクトにも存在しており、\nWebエディタ上で確認することができます。（デフォルトで非表示になっています。）\nWebエディタ上のファイルを取得する（clasp pull） clasp でWebエディタ上の最新のファイルを取得することができます。\nこのコマンドを実行することで、ローカル環境をWebエディタと同じ内容にすることができます。\nclasp create の際にWebエディタ上に Code.gs が生成されているため、以下のコマンドでローカルに落としてみましょう。\nclasp pull この際に注目してほしいのはローカルに落としたファイルの拡張子です。\nCode.gs を落としてきたはずが、拡張子が変わり Code.js になっています。\nこれは clasp が自動的に拡張子を変更してくれているためです。\nまた、このコマンドを実行するとローカルの同名ファイルを強制的に上書きしてしまうため、\n実行の際は上書きしても問題がないか確認をしたうえで実行しましょう。\nWebエディタ上にファイルを送る（clasp push） ローカルで編集したファイルをWeb上に送ることができます。\nこのコマンドを実行することで、Webエディタをローカル環境と同じ内容にすることができます。\n試しに Code.js にコーディングされている myFunction を以下の内容に変更してみましょう。\nfunction myFunction() { console.log(\u0026#39;Hello!\u0026#39;); } 変更して保存が完了したら、以下のコマンドを実行してWebエディタに送ってみましょう。\nclasp push コマンド実行後にWebエディタを再表示するとWebエディタがローカル環境と同じ内容になっています。\nclasp pull と同様にローカルの .js ファイルはWebエディタ上では .gs に変換されています。\nこのコマンドで気をつけるべきことは、カレントディレクトリにある全てのファイルをWebエディタ上に送ろうとします。\nWebエディタ上には拡張子が .gs と .htmlのファイルと appsscript.json しか作成することができないため、\nそれ以外のファイルを送ろうとするとエラーが発生して失敗します。\nこのようなときはpush対象のファイルから除外するファイルを指定する .claspignore を作成する必要があります。\ntouch .claspignore .claspignore の内容は適宜必要に応じて変更する必要がありますが、\n以下の内容で .js と appsscript.json 以外のファイルがpushされないようにすることができます。\n**/** !*.js !appsscript.json 1行目の**/**はカレントフォルダ配下にあるフォルダ・ファイルを全て対象にするという意味です。\nこれで全てのファイルがpush対象ではなくなります。\nただこれでは何もWebエディタ上に送ることができないため、2行目以降で送りたいファイルを指定します。\n2行目の !*.js は拡張子が.jsのファイルを除外対象にしないという意味です。\n.js のみですと .js をpushしない対象にするという意味になるため、\nそれを否定する！を先頭につけることで、.jsのファイルを除外対象にしないという意味になります。\n同様に3行目で !appsscript.json は appsscript.json を除外対象にしないという意味になります。\nまた、もう一点注意点があり、pushの際にWebエディタにのみファイルがあって、ローカル環境に同ファイルがない場合は消えてしまいます。\npushする際はWebエディタ上にあるファイルを確認したうえで実行するようにしましょう。\nディレクトリ構成 ファイルの数が増えてくるとフォルダの数を増やしたくなることがあると思います。\n仮にsrcフォルダ内にファイルをまとめるように変更した場合は、\n.claspignore を以下のように変更することでpushできるようになります。\n**/** !src/*.js !appsscript.json 先ほど違うのは2行目で!src/*.jsとすることでsrcフォルダ配下の .js ファイルを除外対象にしないようにしています。\nclasp push をしてWebブラウザを確認してみましょう。\n注目して欲しいのはファイル名で フォルダ名/ファイル名 の形式に変わっています。\nこれにより、clasp pull をした際もsrcフォルダ内のファイルを更新することができます。\nまた、.clasp.json でpush対象の最上位フォルダを指定することができます。\n以下のように rootDir にフォルダ名を追加することで、追加したフォルダ名を push 対象の最上位フォルダにすることができます。\n{ \u0026#34;scriptId\u0026#34;: \u0026#34;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;src\u0026#34; } 既存のGASプロジェクトからクローンする ここまでは clasp で新規作成をしてみましたが、既存のGASプロジェクトとローカル環境を紐づけることもできます。\nGoogle Drive上に新規のスクリプトエディタを作成したのち、以下のコマンドを実行してみましょう。\n対象のスクリプトエディタ内のコードをローカル環境に落とすことができれば成功です。\nclasp clone XXXXXX コマンドの最後のXXXXXXには対象のスクリプトエディタのスクリプトIDを設定してください。\nスクリプトIDはスクリプトエディタの プロジェクトの設定 で確認することができます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_4/",
	"title": "スクリプトエディタの使い方",
	"tags": [],
	"description": "",
	"content": "本章ではスクリプトエディタの使い方について解説します。\n2020年の12月末にスクリプトエディタは刷新され、レイアウトと機能が大幅に変わりました。\nサイドメニュー スクリプトエディタを開くと画面の左端にアイコンが縦に5つ並んだサイドメニューが表示されます。\nサイドメニューの各アイコンをクリックするとそれぞれの画面に切り替わります。\n各アイコンをクリックした際に表示される画面は以下の通りです。\n画面名 内容 概要 プロジェクトの情報の概要が表示されます。 エディタ コードの作成、編集、削除を行う画面です。GASを手動で実行することもできます。 トリガー GASを自動的に実行するトリガーを設定することができます。 実行数 GASの実行ログが表示されます。 プロジェクトの設定 プロジェクトの設定を行うことができます。 概要 プロジェクトの詳細の情報を確認することができます。\nまた、過去７日間のエラー率や実行数を確認することができます。\nエディタ GASのコーディングや実行を行うことができる画面です。\n実行したい関数を指定して「実行」ボタンをクリックすると指定した関数を実行することができます。\n（関数については次章で解説します。）\n関数を実行すると画面下部に実行ログが表示されます。\n関数が正常終了したのか、それともエラーが発生して異常終了したのかはこの実行ログで確認することができます。\nまた、console.log()などのログを出力するメソッドを実行すると、その結果が実行ログに出力されます。\nエディタ画面の左側にはファイル、ライブラリ、サービスの3つの項目があります。\nそれぞれの項目の使い方について解説します。\nファイル 「＋」ボタンをクリックすると、プロジェクトにファイルを追加することができます。\nなお、追加することができるファイルはスクリプト（.gs）とHTML（.html）のみです。\nライブラリ 他のGASプロジェクトのスクリプトを利用したい場合に使用します。\n「＋」ボタンをクリックすると、ダイアログが表示されスクリプトIDの入力欄が表示されます。\nその入力欄にスクリプトIDを入力して設定することでスクリプトを利用できるようになります。\nサービス GASで多くの Google のサービスを操作することができますが、\n各サービスのAPIを活用することでより高度な処理を行うことができるようになります。\n「＋」ボタンをクリックすると、ダイアログが表示され、\n追加したいサービスとそのバージョンを指定して追加ボタンをクリックすることで同サービスを利用できます。\n詳細は公式ガイド をご参照ください。\nトリガー トリガー画面ではGASの関数を時限的に実行するトリガーを設定することができます。\n例えば、以下の画像のようにトリガーを設定すると、myFunction関数が1時間おきに実行されます。\n実行する関数や実行タイミングはそれぞれ設定することができます。\n実行数 実行数画面では過去7日間の同GASプロジェクトの実行結果を確認することができます。\n過去に実行された関数の実行結果はこの画面で確認しましょう。\nプロジェクトの設定 GASプロジェクトの全般の設定をすることができます。\nChrome V8 ランタイムの有効化・無効化 マニュフェストファイル（appsscript.json）の表示・非表示 また、プロジェクトに一意に割り振られているスクリプトIDもこの画面で確認することができます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_4/",
	"title": "シートを操作する",
	"tags": [],
	"description": "",
	"content": "Sheetクラスとは Sheetクラス は、シートを操作する機能を提供するクラスです。\nシートの情報を取得するメソッドや行・列の操作、シート上のセルを取得するなどのメソッドが提供されています。\n早速、次のサンプルを実行し、シートの様々な情報を取得してみましょう。\nfunction spreadsheet_5() { var sheet = SpreadsheetApp.getActiveSheet(); console.log(sheet.getIndex()); // シートのインデックス console.log(sheet.getName());　// シートの名前 } セルを取得する Sheetクラスはシートのセルを取得する機能が備わっていることが大きな特徴です。\nセルを取得するいくつかのメソッドが用意されていますが、その中でも最もスタンダードなメソッドが getRangeメソッド です。\ngetRangeメソッドは引数の数によって様々なパターンのセルを取得することができます。\n一番シンプルなのは、引数に「A1」や「A1:C3」のようなセルのアドレスを文字列で渡して取得する方法です。\nSheetオブジェクト.getRange(アドレス) 他のパターンとしては、行番号・列番号・行数・列数を引数に指定することでセルを取得する方法です。\nSheetオブジェクト.getRange(行番号, 列番号[, 行数, 列数]) ※ []は任意のため省略可能です。\n行番号から行数分、列番号から列数分の範囲を指定して取得することができます。\n行数と列数は省略することができ、省略した場合はそれぞれの値は1となります。\n各値は数値で設定するため、セルを動的に取得したい場合はこの方法を用います。\nそれでは、次のサンプルを実行してセルを取得できているか確認してみましょう。\nfunction spreadsheet_6() { var sheet = SpreadsheetApp.getActiveSheet(); console.log(sheet.getRange(\u0026#39;A1\u0026#39;).getA1Notation()); // A1 console.log(sheet.getRange(\u0026#39;B2:D5\u0026#39;).getA1Notation()); // B2:D5 console.log(sheet.getRange(\u0026#39;2:2\u0026#39;).getA1Notation()); // 2:2 console.log(sheet.getRange(\u0026#39;B:B\u0026#39;).getA1Notation()); // B:B console.log(sheet.getRange(3, 3).getA1Notation()); // C3 console.log(sheet.getRange(3, 3, 2).getA1Notation()); // C3:C4 console.log(sheet.getRange(3, 3, 2, 2).getA1Notation()); // C3:D4 } サンプル内で実行しているgetA1Notationメソッドはセル範囲のアドレスをA1形式で取得するメソッドです。\nA1形式のアドレス指定であれば行または列全体の取得も可能です。\nまた、行番号・列番号・行数・列数は変数で指定することも可能です。\nシートのデータ範囲を取得する アドレスや行番号、列番号がわからない場合や、シートに値が追加されていって取得するセル範囲が変化する場合はどのようにして取得するとよいでしょう？\nこのようなときに getDataRangeメソッド は非常に便利で、シート上のデータが存在する範囲をすべて取得してくれます。\nSheetオブジェクト.getDataRange() また、セルの範囲ではなく、データが存在する最後の行番号を取得する getLastRowメソッド や、\nデータが存在する最後の列を取得する getLastColumメソッド も便利なメソッドです。\nSheetオブジェクト.getLastRow() Sheetオブジェクト.getLastColumn() これらのメソッドの使用例を次のサンプルで確認してみましょう。\nfunction spreadsheet_7() { var sheet = SpreadsheetApp.getActiveSheet(); console.log(sheet.getDataRange().getA1Notation()); console.log(sheet.getLastRow()); console.log(sheet.getLastColumn()); } getDataRangeメソッドの取得範囲の起点はA1セルで、そこからデータが入っている最終行および最終列までの範囲を取得します。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/page_2_2_4/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "条件分岐処理や繰り返し処理などのJavaScriptの制御構文について紹介してきました。\nGASで実装する際に制御構文が書けると処理幅が大きく広がるので是非活用してください。\n次は「関数」について解説いたします。\n関数を使用することで一連の処理をひとまとめにして、再利用をしやすくなります。\n開発を効率よく進めたり、メンテナンス性を高める効果があるのでしっかり学んでいきましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/page_2_3_4/",
	"title": "無名関数",
	"tags": [],
	"description": "",
	"content": "関数式と無名関数 ここまで関数を定義するのに「関数宣言」を用いてきました。\nあとで呼び出して使用する関数名と、関数が何をするかの定義の両方を指定する方法です。\n実はJavaScriptでは他にも関数の定義方法があり、その一つが関数名を指定しない「無名関数（匿名関数）」といいます。\n名前のない関数をどうやって呼び出すのか？といいますと、「関数式」を使用することで呼び出せるようになります。\n関数式は構文的には関数名を省略する以外は関数宣言と全く同じです。\n下記の例では変数fを使って、f()で代入した関数を呼び出すことができます。\nvar f = function() { // 処理内容 } 無名関数は他の関数（メソッド）の引数として、あるいはオブジェクトのプロパティとしてよく使われます。\n即時関数 ここまでの関数は事前に定義をして、その後に関数を実行してきましたが、\n宣言と同時に関数を実行することもできます。\nこの関数を即時関数といいます。\n即時関数の文法は下記の通りです。\n(function() { // 処理内容 })(); 先ほどは関数式を使用することで無名関数を作ることができると説明しましたが、\nその応用でその関数を即時に呼び出すことができます。\n即時関数のメリットは即時に関数を実行できることと、関数内部に独自のスコープを持っているためスコープ外からはアクセスできないことにあります。\nコード.gs var message = (function(){ return 10 * 10; })(); console.log(message); // 100 "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/",
	"title": "関数を学ぼう",
	"tags": [],
	"description": "",
	"content": "Chapter 2 - 4 JavaScriptの関数 JavaScriptの関数の仕組みについて学びましょう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page_2_1_4/",
	"title": "変数",
	"tags": [],
	"description": "",
	"content": "変数とは 変数（variable）は値を記憶する領域に名前つけたもののことを指します。\n変数という名前の通り、記憶した値を変更することができます。\n例えるなら、値を格納する箱のようなものが変数で、その箱に格納した値は任意で変更することができるのです。\n変数を使うことで、データを一時的に保管したり、変数名で呼び出して格納した値を何度でも使用することができます。\n変数を実際に使うには、その変数を 宣言 する必要があります。\nJavaScriptで変数を宣言する際は行頭に varキーワード をつけて、その後に変数名を記述します。\nvar 変数名; var 変数名1, 変数名2, 変数名3; // カンマ区切りにすることで、1行で変数を複数宣言することもできます。 変数に値を代入する 変数にデータを格納することを 代入 といいます。 代入は左辺に変数名を記述し、イコールを挟んで右辺に格納する値を記述します。\n変数名 = 値; 変数を宣言する際に初期値を必ずしも指定する必要はなく、\n指定しない場合は「未定義」であることを意味する undefined が自動的に設定されます。\nコード.gs function myFunction() { var num; console.log(num); // undefined } 変数に値を代入したのち、その変数名を記述することで格納した値を呼び出すことができます。\nまた、変数に代入したのち、変数に格納した値を上書きすることもできます。\n上書きは変数に値を代入する方法と同じ方法で記述することができます。（宣言ではないので varキーワード は不要です。）\n下記のサンプルではログに2回出力しています。\n1回目のログ出力は代入する前であるため「未定義」を意味する undefined が出力され、\n2回目のログ出力は「10」を変数numに代入しているため 10 がログに出力されます。\nコード.gs function myFunction() { var num; console.log(num); // undefined num = 10; console.log(num); // 10 } 変数の宣言時に値の代入をすることもできます。\nこのことを 初期化 といいます。（2行のコードが1行になるのでスッキリしますね。）\nこの場合もカンマ区切りでまとめて初期化を行うことができます。\nコード.gs function myFunction() { var num_1 = 10; var num_2 = 100, num_3 = 1000; // まとめて初期化も可能 console.log(num_1); // 10 console.log(num_2); // 100 console.log(num_3); // 1000 } 定数とは 変数は上書きができると説明しましたが、ときには変数を上書きしたくないケースもあります。\nこのように上書きしたくない変数は 定数 として宣言して使用します。\n定数（constant）も同様に値を保持できますが、変数とは違って初期化後に再代入することができません。\nまた、具体的な数値や文字列を表す定数の変数名には、\n大文字と「_」（アンダースコア）を組み合わせて名前をつけることが慣習となっています。（必須ではありません。）\nこのようにすることで、大量のコードの中から値が変わらない（変えてはいけない）変数が見つかりやすくなります。\n定数は変数と同じく名前をつけることができ、値を格納することもできますが、 一度値を格納すると以降はその値を変更することができません。\nJavaScriptで定数を宣言する際は行頭に const をつけて初期化を行います。\nconst 定数名 = 値; 下記のサンプルで定数が更新されないことを確認してみましょう。\nコード.gs function myFunction() { const num = 10; num = 100; console.log(num); } 定数numに対して、100を再代入して上書きしようとしましたが、\n「TypeError: Assignment to constant variable.」とエラーが表示されます。\n一般的に定数を使用できるのであれば、変数ではなく定数を使うべきです。\nスプレッドシートのIDやURLなど、処理の中で変わることがない値は定数で宣言することを推奨します。\n逆に変数を使うべき場面もあります。\n例えば、ループ処理の中で値が更新される場合は変数を使う必要があります。\n識別子の命名規則 ここまでで変数、定数、関数に対して任意の名前をつけることができると説明してきました。\nこれらの名前は 識別子 といい、JavaScriptでは自由に名前をつけることができるのですが、実はルールが設けられています。\n先頭文字は数字や記号文字を使うことができない。（記号文字のうちアンダースコア（_）とドル記号($)は使用できます。） 予約後は使用できない。 大文字と小文字は区別される。 予約語 はJavaScriptで特別な意味を持つ単語として決められているワードになります。\n例えば、変数宣言で使用する var や、関数の定義で使用する function が挙げられます。\nJavaScriptの予約語は下記の通りです。\nbreak case catch const continue debugger default delete do else finally for function if in instanceof let new throw try typeof var void while with 識別子の命名のコツ 識別子のルールが守られていれば自由に名前をつけることができます。\nただ、名前の付け方が統一されていて、かつ読みやすい名前だとコーディングがしやすいですよね。\n以下のポイントを守って名前をつけるとコーディングがしやすくなります。\n変数の中身や関数の内容がわかる名前をつける 例えば、変数に「名前」を格納したい場合、皆さんはどのような変数名をつけますか？\n下記のサンプルでは、文字列の「Taro」を変数nameと変数numに格納しています。\n変数名をnameにすると、格納されている値は名前だと想像することができます。\nその一方、変数名がnumにすると、格納されている値は一見数字であると想像してしまいます。\n関数の名前も同様にどのような処理が行われているイメージがしやすい名前をつけるようにしましょう。\nvar name = \u0026#39;Taro\u0026#39;; // Good! var num = \u0026#39;Taro\u0026#39;; // NG! 日本語やローマ字は使わず、英語を使う JavaScriptの予約後は英語なので、識別子は英語で統一するとコードが読みやすくなります。\n日本語やローマ字で変数宣言や関数の定義をすることはできますが、書き方に統一感がないと読みにくくなるためおすすめはできません。\nvar name = `Taro`; // Good! var 名前 = `Taro`; // NG! var namae = `Taro`; // NG! 変数名と関数名はキャメル記法、定数名にはスネーク記法を使う キャメル記法 というのは、複数の英単語で変数名や関数名をつける際に2つ目以降の頭文字を大文字にする記法です。\nキャメルというのはラクダ（Camel）が由来なのですが、頭文字を大文字にするとちょうどそこがコブのように見えることから キャメル記法 と言われています。\nもうひとつの記法として スネーク記法 と呼ばれるものがあります。こちらは英単語をアンダースコア（_）でつないでいく記法です。　コード.gs // 関数名はキャメル記法 function getUserName() { // 変数名はキャメル記法 var userName = \u0026#39;Taro\u0026#39;; // 定数はスネーク記法 const GREETING_WORD = \u0026#39;Hello \u0026#39;; console.log(GREETING_WORD + userName); // Hello Taro } これらのポイントを意識しながらコーディングをすると、自然と読みやすいスクリプトになっていきます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_5/",
	"title": "クライアントサイドのJavaScriptを学ぼう",
	"tags": [],
	"description": "",
	"content": "クライアントサイドのJavaScript ここまではGSファイルにJavaScriptを書いてきましたが、実はHTMLファイルにもJavaScriptを書くことができます。\nHTMLファイルでJavaScriptを書ける場所は決まっており、scriptタグ の中に書くことができます。\nまた、このscriptタグも書くことができる場所が決まっています。\nJavaScriptを書くことができる場所 scriptタグを書くことができるのは主に以下の2つの場所になります。\n1つ目はheadタグの中でstyleタグと同様の場所に書くことができます。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; // CSSを記述する \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; // JavaScriptを記述する \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2つ目はbodyタグの中です。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; // CSSを記述する \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;Sample\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // JavaScriptを記述する \u0026lt;script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; それでは、早速クライアントサイドの JavaScript をコーディングしてみましょう。\n今回は Google Chrome のコンソールログに「Hello!」と表示をしてみます。\nconsole.log(\u0026#39;Hello!\u0026#39;); index.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;script\u0026gt; console.log(\u0026#39;Hello!\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Google Chrome のコンソールログは以下の手順で確認できます。\nブラウザ右上「︙」をクリックします。 表示されたメニューから[その他のツール]→[デベロッパーツール]をクリックします。 デベロッパーツール内の「Console」タブを選択します。 続いて、ボタンをクリックした際にコンソールログに「Hello!」と表示をしてみましょう。\n任意のタイミングで処理をさせたい場合は関数として定義する必要があります。\n次のサンプルではボタンをクリックした際にviewMessage()が実行されるように、\ninputタグの onclick にviewMessage()を設定しています。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;script\u0026gt; function viewMessage() { console.log(\u0026#39;ボタンをクリックしました！\u0026#39;); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;メッセージを表示する\u0026#34; onclick=\u0026#34;viewMessage()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; サーバーサイドのJavaScriptとの違い クライアントサイドもサーバーサイドも同じ JavaScript をコーディングしていますが、\nコーディングできる処理はそれぞれ異なります。\nサーバーサイドはGoogle の各種サービスを操作する Google Apps Script を実行することはできますが、\n画面の値や色を変えたりなどの画面側の処理を行うことができません。\n画面側の処理を行いたい場合は .gs ではなくHTMLのスクリプトタグ内にコーディングをしていきます。\nHTMLの要素を操作する クライアントサイドのJavaScriptで画面を操作するには、対象の画面の部品を特定する必要があります。\n画面の各部品にはidを設定することができるため、このidで部品を特定することができます。\n以下のサンプルではviewMessage()でテキストボックスに入力した値を取得してコンソールログに出力していますが、\ndocument.getElementById()で対象のテキストボックスを取得しています。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;script\u0026gt; function viewMessage() { // idが’textBox’の要素を取得します。 const textBox = document.getElementById(\u0026#39;textBox\u0026#39;); // 取得した要素から値を取得します。 const value = textBox.value; // コンソールログで取得した値を表示します。 console.log(value); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;textBox\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;メッセージを表示する\u0026#34; onclick=\u0026#34;viewMessage()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; クライアントサイドの JavaScript は画面から情報取得することだけでなく、\n画面を変化させることもできます。\n以下のサンプルではテキストボックスに入力した内容を画面に出力しています。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;script\u0026gt; function viewMessage() { // idが’textBox’の要素を取得します。 const textBox = document.getElementById(\u0026#39;textBox\u0026#39;); // 取得した要素から値を取得します。 const value = textBox.value; // 取得した値を太字にします。 const output = `\u0026lt;b\u0026gt;${value}\u0026lt;/b\u0026gt;`; // 出力先の要素を取得します。 const outputArea = document.getElementById(\u0026#39;outputArea\u0026#39;); // 出力先の要素に値を追加します。 outputArea.innerHTML = output; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;textBox\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;メッセージを表示する\u0026#34; onclick=\u0026#34;viewMessage()\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;outputArea\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSSを操作する クライアントサイドの JavaScript は画面の見た目も変えることができます。\n以下のサンプルでは CSS の設定を JavaScript で変えています。\nindex.html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;style\u0026gt; #colorBtn { background-color: blue; color: white; font-size: 15px; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; function changeColor() { // idが\u0026#39;colorBtn\u0026#39;の要素を取得する。 const colorBtn = document.getElementById(\u0026#39;colorBtn\u0026#39;); // 取得した要素の背景色を赤色に変更する。 colorBtn.style.backgroundColor = \u0026#39;red\u0026#39;; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; id=\u0026#34;colorBtn\u0026#34; value=\u0026#34;色を変える\u0026#34; onclick=\u0026#34;changeColor()\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ＜ボタンのクリック前＞\n＜ボタンのクリック後＞\n画面にダイアログを表示する 画面上にポップアップでメッセージを表示したい場合はdialogタグを使いましょう。\n以下のサンプルでは画面表示時に閉じるボタン付きのダイアログを表示しています。\nindex.html コード.gs \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body onload=\u0026#34;showAlert()\u0026#34;\u0026gt; \u0026lt;dialog id=\u0026#34;alert\u0026#34;\u0026gt; \u0026lt;p id=\u0026#34;alert-message\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button id=\u0026#34;alert-closeBtn\u0026#34;\u0026gt;閉じる\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/dialog\u0026gt; \u0026lt;script\u0026gt; function showAlert() { var dialog = document.getElementById(\u0026#39;alert\u0026#39;); var dialogMsg = document.getElementById(\u0026#39;alert-message\u0026#39;); var dialogCloseBtn = document.getElementById(\u0026#39;alert-closeBtn\u0026#39;); dialogMsg.innerHTML = \u0026#39;こんにちは！\u0026#39;; dialog.show(); // 閉じるボタンをクリックした時の処理 var closedFnc = function() { dialog.close(); } dialogCloseBtn.addEventListener(\u0026#39;click\u0026#39;, closedFnc); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; function doGet() { return HtmlService.createTemplateFromFile(\u0026#39;index\u0026#39;).evaluate(); } "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/es2015/page_2_5_5/",
	"title": "スプレッド構文",
	"tags": [],
	"description": "",
	"content": "配列の値を展開する ES2015からスプレッド構文が使えるようになりました。\nスプレッド構文は配列やオブジェクトなどの反復可能なオブジェクトを展開してくれます。\n構文は配列やオブジェクトが格納されている変数や仮引数の前に...をつけることで展開することができます。\n...変数または仮引数 それでは「配列を展開する」とはどういうことかを確認してみましょう。\n以下のサンプルコードは数値の1、2、3が格納された配列を展開しています。\nコード.gs function spread_syntax_1() { const numbers = [1, 2, 3]; console.log(numbers); // [1, 2, 3]を、1 2 3に展開する console.log(...numbers); } [ 1, 2, 3 ] 1 2 3 この配列の展開を活用すると、以下のように引数を3つ受け取るSUM関数に対して引数を渡すことができます。\n本来は引数の値を3つ渡す必要があるため、numbers配列の要素を一つずつ取り出す必要があるのですが、\nスプレッド構文を使えばシンプルに書くことができます。\nコード.gs function spread_syntax_2() { const numbers = [1, 2, 3]; // [1, 2, 3]を、1, 2, 3に展開する const result = sum(...numbers); console.log(result); } function sum(x, y, z) { return x + y + z; } 6 スプレッド構文を使えば、配列同士の結合も以下のように書くことができます。\n本来であれば配列の要素を取り出して結合する必要がありますが、スプレッド構文の場合はその必要がありません。\nコード.gs function spread_syntax_3() { const numbers_1 = [2, 3, 4]; const numbers_2 = [1, ...numbers_1, 5, 6]; console.log(numbers_2); } [ 1, 2, 3, 4, 5, 6 ] また、ここまでは配列で解説をしましたが、オブジェクトの要素も同様に展開することができます。\nコード.gs function spread_syntax_4() { const object_1 = {id: 1, name: \u0026#39;Taro\u0026#39;}; const object_2 = {...object_1, age: 25}; console.log(object_2); } { id: 1, name: \u0026#39;Taro\u0026#39;, age: 25 } "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_5/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "これにて clasp の使い方の解説は終了です。\nclasp はGASのチーム開発で必須となるツールです。\nぜひ、活用してみてください！\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_5/",
	"title": "セル範囲を操作する",
	"tags": [],
	"description": "",
	"content": "Rangeクラスとは Rangeクラス は、セル範囲を操作する機能を提供するクラスです。\nセルの値や数式の取得や設定、セル範囲の情報の取得、書式の設定、並べ替えなどのメンバーが用意されています。\n試しに、セル範囲の様々な情報を取得するサンプルを実行してみましょう。\nfunction spreadsheet_8() { var range = SpreadsheetApp.getActiveSheet().getRange(\u0026#39;A2:C5\u0026#39;); console.log(range.getRow()); // 2 console.log(range.getColumn()); // 1 console.log(range.getNumRows()); // 4 console.log(range.getNumColumns()); // 3 console.log(range.getLastRow()); // 5 console.log(range.getLastColumn()); // 3 } 値を取得・設定する Rangeクラスのメンバーで最も基本的な操作はセルからの値の取得・設定といえます。\n単体セルの値を取得する getValueメソッド と単体セルの値を設定する setValueメソッド の構文を確認していきましょう。\nRangeオブジェクト.getValue() Rangeオブジェクト.setValue(値) このメソッドには注意すべきことがありまして、セルを1つ1つ処理していくため、\nそのセルの数の分だけスプレッドシートへのアクセス回数がかさんでしまいます。\nアクセス回数がかさむと処理速度も遅くなります。\nそのため、複数のセル範囲を取得・設定する場合は、\nセル範囲の値を取得する getValuesメソッド と、\nセル範囲の値を設定する setValuesメソッド を使用するようにしましょう。\nRangeオブジェクト.getValues() Rangeオブジェクト.setValues(配列) setValuesメソッドでは、対象となるセル範囲の「行数×列数」と、引数の二次元配列の「要素数×要素数」が一致している必要があります。\nfunction spreadsheet_9() { var sheet = SpreadsheetApp.getActiveSheet(); sheet.getRange(\u0026#39;A1\u0026#39;).setValue(\u0026#39;Google\u0026#39;); console.log(sheet.getRange(\u0026#39;A1\u0026#39;).getValue()); // Google var values = [ [\u0026#39;Taro\u0026#39;, 22, \u0026#39;東京\u0026#39;], [\u0026#39;Hanako\u0026#39;, 25, \u0026#39;大阪\u0026#39;] ]; sheet.getRange(\u0026#39;A2:C3\u0026#39;).setValues(values); console.log(sheet.getRange(\u0026#39;A2:C3\u0026#39;).getValues()); // [\u0026#39;Taro\u0026#39;, 22, \u0026#39;東京\u0026#39;],[\u0026#39;Hanako\u0026#39;, 25, \u0026#39;大阪\u0026#39;] } "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/object_mechanism/",
	"title": "オブジェクトの仕組みを学ぼう",
	"tags": [],
	"description": "",
	"content": "Chapter 2 - 5 オブジェクトの仕組み JavaScriptのオブジェクトの仕組みを学びましょう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/page_2_3_5/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "関数とは何か、またその定義の方法やスコープについて解説いたしました。\nJavaScriptの関数は一連の処理をまとめる以上の機能を持っていることを確認できたのではないかと思います。\n続いては「オブジェクト」について紹介します。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page_2_1_5/",
	"title": "スコープ",
	"tags": [],
	"description": "",
	"content": "スコープとは 宣言した変数はどこからでも参照できるわけではありません。\n変数には参照できる範囲が定められており、その範囲をスコープといいます。\nグローバル領域 早速ですが、下記のサンプルを実行してみましょう。\n実行する関数内にはステートメントは１行もありませんが、実行するとどうなるでしょうか？\nコード.gs var msgHello = \u0026#39;Hello!\u0026#39; console.log(msgHello); function outputScope_1() { } Hello! 関数を実行すると、ログに「Hello!」と表示されたと思います。\n関数の外に記述した2つのステートメント、msg変数の初期化とログ出力が実行されました。\nGASにはどの関数に属さない領域にステートメントを記述することができ、この領域を グローバル領域 といいます。\nプロジェクトに含まれるいずれかの関数が呼び出されると、呼び出された関数よりも先に、グローバル領域に記述されたステートメントが実行されます。\n次のサンプルを実行すると、まずグローバル領域に記述されたステートメントが上から順番に実行されていきます。\nその後、呼び出された関数内のステートメントが実行されることが確認できるでしょう。\nコード.gs console.log(\u0026#39;Good Morning!\u0026#39;); function outputScope_2() { console.log(\u0026#39;Hello!\u0026#39;); } console.log(\u0026#39;Good Night!\u0026#39;); Good Morning! Good Night! Hello! 異なるgsファイルに記述されていたとしても、プロジェクト内の任意の関数の呼び出しにより、グローバル領域に記述される全てのステートメントが実行されます。\n複数のgsファイルのグルーバル領域にステートメントを点在させることは、わかりやすさの観点からおすすめできません。\nグローバルスコープとローカルスコープ 変数にはその変数を参照することができる範囲が定められています。\nこれを スコープ といいます。スコープには次の２種類があります。\nグローバルスコープ：プロジェクト全体から参照できる ローカルスコープ：宣言された関数の中からのみ参照できる 関数の中で宣言された変数のスコープは ローカルスコープ といい、その関数の中でのみ参照することができます。\nこのような変数を ローカル変数 といいます。\n一方、グローバル領域で宣言された変数はプロジェクトのどこからでも参照することができ、\nそのスコープは グローバルスコープ、またその変数を グローバル変数 といいます。\nそれでは、それぞれのスコープについてサンプルで確認していきましょう。\n次のサンプルはローカル変数のスコープを確認するサンプルです。\nlocalFunction_2関数を実行すると「localFunction_2が定義されていません」というエラーが発生します。\nこのようにローカル変数は外からはアクセスすることができないのです。\nコード.gs function localFunction_1() { var localMsg = \u0026#39;ローカル\u0026#39;; } function localFunction_2() { console.log(localMsg); } 続いて、グローバル変数のスコープを確認するために、次のサンプルを実行してみましょう。\nコード.gs var globalMsg = \u0026#39;グローバル\u0026#39;; function globalFunction_1() { console.log(globalMsg); } グローバル このようにグローバル変数は全ての関数からアクセスすることができます。\nそれでは、次のサンプルの場合はどうなるでしょうか？\nmsg変数がグローバル領域でも、関数の中でも宣言されています。\nこのような場合にglobalFunction_2を実行するとローカル変数のmsgが表示されます。\nコード.gs var msg = \u0026#39;グローバル\u0026#39;; function globalFunction_2() { var msg = \u0026#39;ローカル\u0026#39;; console.log(msg); } ローカル "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page_2_1_7/",
	"title": "データ型",
	"tags": [],
	"description": "",
	"content": "データ型とは データ型とは、データの種類のことをいいます。\n例えば、データが「数値型」であれば四則演算で計算を行うことができますが、「文字列型」の場合は四則演算で計算を行うことができません。\nJavaScriptではデータの種類を「プリミティブ(primitive)」と「オブジェクト(object)」の2つに分けられます。\nこれらのデータ型の値は リテラル といわれていて、変数や定数に格納して使用されます。\nプリミティブ プリミティブ（文字列や数値）は「不変(immutable)」という特徴があり、プリミティブのデータ型は次の5種類があります。\n下記のようにデータ型により実行できる処理が異なります。\nデータ型 概要 データの例 数値型（Number） 整数値や浮動小数点値 10, 1.23 文字列型（String） 文字列 \u0026lsquo;Taro\u0026rsquo;, \u0026lsquo;123\u0026rsquo; 真偽型（Boolean） 真と偽のどちらかの値 true, false null 値がないことを表す特殊な値 null undefined 値が定義されていないことを表す特殊な値 undefined この「不変」というのは「変数の値を変更できない」という意味ではありません。\n下記のサンプルは文字列の中から一部の文字列を切り取っていますが、実行すると切り取り元のデータは変わっていないことが確認できます。\nコード.gs function myfunction() { var str = \u0026#39;12345\u0026#39;; // 0文字目から3文字を切り出す var result = str.substr(0, 3); // 切り出した0文字目から3文字 console.log(result); // 切り取り元のデータは変更されていない。 console.log(str); } 123 12345 このように プリミティブ型は置き換える（再代入）することはできますが、値をそのものを変更することはできません。\n上記をプリミティブ型の特徴を念頭に置いて、各プリミティブ型の違いを確認していきましょう。\n他のプログミング言語（Javaなど）では、変数宣言時に指定したデータ型以外の値を入れることができないものもありますが、\nJavaScriptはデータ型については寛容です。\n例えば、数値型のデータを格納していた変数に文字列型のデータを代入することも可能です。\n数値型（Number） 数値型は整数や小数以外にも16進数を扱うことができます。\n全角数値の場合やカンマが含まれている場合（例：1,000）は数値として扱われないため注意しましょう。\nコード.gs function outputNumber() { console.log(10); // 10 console.log(1.23); // 1.23 console.log(0xFFFF); // 65535 console.log(1000000000000000000000); // 1E+21 console.log(0.0000001); // 1.0E-6 } 上記のサンプルを実行すると、「1E+21」や「1.0E-6」という結果が表示されます。\nこれらは 指数表現 といい、整数部の桁数が7桁以上、小数点の桁数が6桁以上の数値は指数表記となります。\nまた、数値と数値の間に四則演算子がある場合は計算が行われます。\nコード.gs function calNumber() { console.log(1 + 1); // 2 console.log(2 - 3); // -1 } 文字列型（String） JavaScriptでは文字列型の値を記述する場合はシングルクォーテーション（\u0026rsquo;）、またはダブルクォーテーション（\u0026quot;）で囲います。\nどちらを使ってもよいのですが、コーディングをする際はどちらかに統一するとコードが読みやすくなります。\nまた、シングルクォーテーションまたはダブルクォーテーションを文字列として使用したい場合は、\n使用されていないクォーテーションで囲うことになります。\nコード.gs function outputString_1() { console.log(\u0026#39;Hello \u0026#34;Taro\u0026#34;!\u0026#39;); // Hello \u0026#34;Taro\u0026#34;! console.log(\u0026#34;I\u0026#39;m Taro\u0026#34;); // I\u0026#39;m Taro } 改行やタブなどの特別な文字はバックスラッシュ（\\）に指定文字を組み合わせることで表現することができます。\nこれを エスケープシーケンス といいます。\nGASで使用できるエスケープシーケンスは下記の通りです。\nエスケープシーケンス 概要 \\n 改行 \\r 復帰 \\t タブ \\\\ バックスラッシュ \\\u0026rsquo; シングルクォーテーション \\\u0026quot; ダブルクォーテーション 試しに下記のサンプルでエスケープシーケンスを確認してみましょう。\nコード.gs function outputString_2() { /* Hello \u0026#39;GAS\u0026#39;! */ console.log(\u0026#39;Hello\\n\\\u0026#39;GAS\\\u0026#39;!\u0026#39;); } 文字列は四則演算子の+で結合することができます。\n下記のサンプルでは+の左辺と右辺を結合してひとつの文字列しています。\nなお、左辺と右辺が数値の場合は加算の処理がなされる点には気をつけてください。\nコード.gs function outputString_3() { console.log(\u0026#39;Hello \u0026#39; + \u0026#39;GAS\u0026#39;); // Hello GAS console.log(\u0026#39;1\u0026#39; + \u0026#39;2\u0026#39;); // 12 console.log(1 + 2); // 3 } 文字列の中に変数などの値を設定したい場合は、下記の通り「＋」記号で文字列連結を行うことで実現できます。\nコード.gs function outputString_4() { var age = 50; var message = \u0026#39;私の年齢は\u0026#39; + age + \u0026#39;歳です。\u0026#39;; console.log(message); // 私の年齢は50歳です。 } 上記のように文字列連結で実現できますが、\nテンプレートリテラル を使用するとよりスマートに書くことができます。\nコード.gs function outputString_5() { var age = 50; var message = `私の年齢は${age}歳です。`; console.log(message); // 私の年齢は50歳です。 } このようにテンプレートリテラルを使うと、変数などの値を文字列に埋め込むのがシンプルに書けます。\nテンプレートリテラルは文頭と文末を「`」(バッククォート）で囲むことで使用できます。\nテンプレートリテラルでは「$」を特別な値として扱っており、\n変数や定数を「${}」で囲むことでその変数や定数の値を文字列に埋め込むことができます。\n「${}」の中には計算式や関数を設定することで、その結果を埋め込むこともできます。\nコード.gs function outputString_6() { var age = 50; var message = `私の年齢は${age + 10}歳です。`; console.log(message); // 私の年齢は60歳です。 } 真偽型（Boolean） 真偽型 は、trueとfalseのいずれかの値で表現する値です。\n「正しい（true）または誤り（false）」、「Yes（true）またはNo（No）」といったどちらかの結果のみ扱う場合に使用します。\n真偽型は後々登場する条件式で活躍するため覚えておきましょう。\nなお、JavaScriptでは次の値は偽（false）とみなされます。\nundefined null false 0 NaN \u0026lsquo;\u0026rsquo;(空文字列) null null は値が存在しないことを意味します。\n数値の「0」や文字列の「’’」も値が存在しないという意味をしているように思えますが、\n厳密には「0」という数値、「\u0026rsquo;\u0026rsquo;」という文字列が存在しています。\n一方で、nullは本当の意味で値が存在しないこと意味しています。\n例えば、文字列型の変数の値がnullの場合は「変数に文字列は入っていない」という意味になります。\n文字列型の変数の値が\u0026rsquo;\u0026lsquo;の場合は「変数に空文字（\u0026rsquo;\u0026rsquo;）が入っている」という意味になります。\nどういうときに使うかといいますと、後々代入する予定の変数を初期化する際に使われることがあります。\nこれができて何が嬉しいの？と思われると思いますが、後々解説する制御構文でその意味がわかると思います。\nvar num = null; undefined undefined は値が未定義であることを意味します。\n例えば、下記のサンプルでは変数の宣言後に代入を行っていませんが、この変数のを参照するとundefinedとなっています。\nどの変数も宣言して代入するまではundefinedの状態になります。\nコード.gs function outputUndefined() { var num; console.log(num); // undefined } オブジェクト オブジェクトはプリミティブとは異なり、さまざまな形式や値をを取ることができる柔軟性があるデータです。\nそのため、実装者にとって都合のよいオリジナルのデータ型を作ることができます。\nJavaScriptにはオブジェクトのデータ型が用意されており、今回は下記の２点を次章以降で紹介します。\nデータ型 概要 データの例 配列型（Array） インデックスをキーとするデータの集合体 [1, 2, 3], [\u0026lsquo;太郎\u0026rsquo;, 20, true] オブジェクト型（Object） プロパティをキーとするデータの集合体 {name: \u0026lsquo;太郎\u0026rsquo;, age: 20, isStudent: true} また、プリミティブ型の数値と文字列、論理値にはそれぞれオブジェクト型が存在しており、\n数値はNumber型、文字列にはString、論理値にはBooleanが対応しています。\nそれぞれ、対応するプリミティブ型の機能を提供しています。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_5/",
	"title": "GASでコーディングしてみよう",
	"tags": [],
	"description": "",
	"content": "関数とは では早速、GASのスクリプトをコーディングしていきましょう。\nスクリプトエディタには既に下記のコードが記述されていると思います。\nfunction myFunction() { } これは関数と呼ばれ、一連の処理をひとまとめにして名前をつけたものになります。\n{ と } の間に1行空いていますが、この間に処理をコーディングしていきます。\nコーディングの際は下記のルールに気をつけてください。\n下記のルールが守られていない場合は、スクリプトを保存する際にエラーとなります。\n英数字、記号はすべて 半角 であること\nアルファベットの大文字、小文字を間違えないこと（myFunctionとMYFUNCTIONとでは別の関数として認識されます。）\nピリオドやセミコロンなどの記号の入力漏れや打ち間違いがないこと\nメッセージを表示してみる 今回のハンズオンでは「Hello World!」というメッセージをスプレッドシートに表示してみたいと思います。\nmyFunction関数の　{ と } の間に下記のようにコードを追記してください。\nまた、追記する際は字下げ（インデント）をしてコードを読みやすくしましょう。\n字下げ（インデント）はTabキーをクリックすると行えます。\nfunction myFunction() { Browser.msgBox(\u0026#39;Hello World!\u0026#39;); } スクリプトを編集した場合は保存をする必要があります。\nスクリプトを編集すると、「コード.gs」の前に赤いアスタリスクマークが表示されます。\nスクリプトエディタ上のスクリプトは編集をしても自動的に更新はされないため、編集したスクリプトを反映させるには保存する必要があります。\nこの赤いアスタリスクマークが表示されている場合は保存がされていない状態です。\nツールメニューバーの「保存」ボタン（ディスクのアイコン）をクリックすると保存することができます。\n赤いアスタリスクのマークがなくなれば保存は完了です！\nスクリプトの保存はショートカットキーがあり、WindowsはCtrl + S、Macはcommand + Sで保存することができます。\n保存が完了すれば、最後にスクリプトの実行です。\nスクリプトの実行はツールメニューバーの「実行」ボタン（再生のアイコン）をクリックすると実行することができます。\nこの際にツールバーに実行する関数の名前が表示されているかを確認しましょう。\nスクリプトの実行はショートカットキーがあり、WindowsはCtrl + R、Macはcommand + Rで実行することができます。\n初回の実行の際は「承認が必要です」というダイアログが表示されます。\nスクリプトを実行するユーザーに対して、操作対象のスプレッドシートへのアクセスを許可する必要があります。\n「許可を確認」をクリックすると、さらに小画面が表示されアカウントの一覧が表示されます。\nここで今回のGASを実行するアカウントを選択します。\n最後に表示された画面の「許可」ボタンをクリックすると、スクリプトが実行されます。\n実行するとスクリプトエディタが表示されており、特に変化は見当たらないと思います。\nでは、スプレッドシートの画面に切り替えてみてください。\n「Hello World!」とメッセージが表示されているはずです。\n（メッセージは「OK」ボタンもしくは右上の「×」ボタンで閉じることができます。）\n関数を更新してみる 作成した関数はもちろん編集することができます。\n先ほど作成したmyFunction関数で表示したメッセージを「Hello World!」から「Hello GAS!」に変更してみましょう。\nfunction myFunction() { Browser.msgBox(\u0026#39;Hello GAS!\u0026#39;); } 先ほどと同じ手順で「保存」→「実行」をしてみましょう。\n（2回目以降は承認の手続きは不要のため、承認のダイアログは表示されません。）\n「Hello GAS!」とメッセージが表示されていれば成功です！\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/",
	"title": "Webアプリ編",
	"tags": [],
	"description": "",
	"content": "Chapter 5 Webアプリ編 Google Apps Script で Webアプリを作ってみよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/es2015/page_2_5_6/",
	"title": "for...of文",
	"tags": [],
	"description": "",
	"content": "繰り返し処理をよりシンプルに書く Chapter2-3の「JavaScriptの制御構文」で for文 に触れましたが、\nES2015からはよりシンプルに書くことができるfor\u0026hellip;of文を使えるようになりました。\n構文は以下の通りで、宣言した変数の中には配列の要素が代入され、配列の先頭の要素から最後の要素まで繰り返されます。\nfor (変数名 of 配列) { // 繰り返す処理 } 以下のサンプルコードでfor\u0026hellip;of文を試してみましょう。\n配列の要素がvalue変数に代入されることが確認できます。\nコード.gs function for_of_1() { const values = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; for (const value of values) { console.log(value); } } A B C for\u0026hellip;of文は原則最後の要素まで繰り返し処理を行いますが、\nbreak文で繰り返し処理を抜けることができます。\nコード.gs function for_of_2() { const values = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; for (const value of values) { console.log(value); break; } } A for\u0026hellip;in文 for\u0026hellip;of文とよく似た構文でfor\u0026hellip;in文があります。\nfor\u0026hellip;of文と同じく、配列の先頭の要素から最後の要素まで繰り返されますが、\n宣言した変数にはインデックス番号が代入されます。\nfor (変数名 in 配列) { // 繰り返す処理 } 以下のサンプルコードで宣言した変数にインデックス番号が代入されていることを確認してみましょう。\nコード.gs function for_in_1() { const values = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;]; for (const index in values) { console.log(index); console.log(values[index]); console.log(\u0026#39;---\u0026#39;); } } 0 A --- 1 B --- 2 C --- また、配列ではなく連想配列を指定すると、宣言した変数にはキー（オブジェクトのプロパティ名）が代入されます。\nコード.gs function for_in_2() { const account = { id: 1, name: \u0026#39;Taro\u0026#39;, age: 20 } for (const property in account) { console.log(property); console.log(account[property]); console.log(\u0026#39;---\u0026#39;); } } id 1 --- name Taro --- age 20 --- "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/",
	"title": "ローカル開発編",
	"tags": [],
	"description": "",
	"content": "Chapter 6 ローカル開発編 ローカル環境でGAS開発をしてみよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_6/",
	"title": "トリガー",
	"tags": [],
	"description": "",
	"content": "トリガーとは GASには、ドキュメントを開くなどの特定のイベントが発生した際に関数を自動的に実行するトリガーという機能があります。\nさまざまな条件でトリガーを設定することができますが、以下のトリガーはGASに組み込まれている予約済みの関数です。\nこのトリガーは シンプルトリガー と呼ばれており、関数を定義することで利用することができます。\n関数名 概要 onOpen(e) ユーザーが編集する権限を持つスプレッドシート、ドキュメント、プレゼンテーション、またはフォームを開いたときに実行されます。 onInstall(e) ユーザーがGoogleドキュメント、スプレッドシート、スライド、またはフォーム内からエディターアドオンをインストールすると実行されます。 onEdit(e) ユーザーがスプレッドシートの値を変更したときに実行されます。 onSelectionChange(e) ユーザーがスプレッドシートの選択を変更したときに実行されます。 doGet(e) ユーザーがWebアプリにアクセスしたとき、 またはプログラムがHTTPGET要求をWebアプリに送信したときに実行されます。 doPost(e) プログラムがHTTPPOSTリクエストをWebアプリに送信するときに実行されます。 シンプルトリガーはユーザーの承認を求めることなく実行できるという特徴があります。\nその一方で、以下のような制限もあります。\nファイルが読み取り専用（表示またはコメント）モードで開かれている場合、これらは実行されません。 承認が必要な サービスにはアクセスできません。(Gmail Service など) 30秒を超えて実行することはできません。 上記以外にもいくつか制限がありますので、詳細は以下リンク先の公式サイトで確認してください。\nhttps://developers.google.com/apps-script/guides/triggers 今回はこのシンプルトリガーのうち onOpen(e) でシンプルトリガーがどのような機能かを確認してみましょう。\n（次章では doGet(e) を深掘りしていきます。）\nonOpen(e) onOpen関数でコーディングした内容は、スプレッドシート、ドキュメント、プレゼンテーション、またはフォームを開いたときに実行されます。\nただし、前提としてファイルを開いたユーザーに編集権限が必要 となります。\nonOpen関数の一般的な活用方法としては、初期表示時に画面上部にメニューを追加する処理を実行することが多いです。\nhttps://developers.google.com/apps-script/guides/menus function onOpen(e) { /** * スプレッドシートの上部に「カスタムメニュー」を追加します。 * 「カスタムメニュー」を開くと選択肢として「アイテム1」と「アイテム2」が表示されます。 */ SpreadsheetApp.getUi() .createMenu(\u0026#39;カスタムメニュー\u0026#39;) .addItem(\u0026#39;アイテム1\u0026#39;, \u0026#39;menuItem1\u0026#39;) .addItem(\u0026#39;アイテム2\u0026#39;, \u0026#39;menuItem2\u0026#39;) .addToUi(); } 上記スクリプトを保存したのち、スプレッドシートを更新して開き直してみてください。\nスプレッドシートを開き直すことでonOpen関数が実行され、以下画像のようにメニューが表示されます。\n時限式のトリガー 特定のイベントが発生した際に実行されるトリガーですが、\n時間を条件にトリガーを設定することもできます。\nこの時限式のトリガーを活用することで、「◯時間ごとに」や「毎日0〜1時に」などの時間を条件にしたトリガーを設定できます。\nトリガーは以下の画像通り、[トリガー]を選択するとトリガーの画面が表示され、\n同画面の[トリガーを追加]ボタンをクリックするとトリガーを追加する画面が表示されます。\nトリガーを追加する画面ではまず「実行する関数を選択」で実行する関数の名前を指定します。\n指定したのちはその関数を実行する条件を指定していきます。\nイベントのソースを「時間主導型」を選択すると、「時間ベースのトリガーのタイプを選択」でトリガーのタイプを選択できます。\nここで「時間ベース」を選択すると何時間おきに実行するかを設定できるようになります。\n他にもさまざまな条件のトリガーを設定することができますので、\n詳細は以下リンク先の公式サイトをご参照ください。\nhttps://developers.google.com/apps-script/guides/triggers/installable "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/es2015/",
	"title": "ES2015を学ぼう",
	"tags": [],
	"description": "",
	"content": "Chapter 2 - 6 ES2015(ES6) ES2015(ES6)での変更点を押さえましょう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page_2_1_8/",
	"title": "配列",
	"tags": [],
	"description": "",
	"content": "配列とは これまでは変数や定数に値を一つずつ代入して扱ってきましたが、複数のデータを1つにまとめたくなるケースもあります。\n例えば、果物の名前を変数で管理したい場合は下記の通りになります。\nvar fruitsName_1 = \u0026#39;apple\u0026#39;; var fruitsName_2 = \u0026#39;grape\u0026#39;; var fruitsName_3 = \u0026#39;orange\u0026#39;; このように一つずつ変数を初期化して扱うことは可能ですが、非常に管理がしづらい問題が発生します。\nさらに果物の名前の変数を作りたいとなった場合、fruiteName_Xの形式で変数名を作ることになりますが、\n今回の果物が何個目の果物なのかをわざわざ確認しないといけないですよね。\nこのように、複数のデータをまとめて集合として扱うことができるデータを 配列 といいます。\n配列はカンマで値と区切り、全体を角括弧（[]）で囲むことで表現することができます。（これを 配列リテラル といいます。）\n[値1, 値2, ...] 配列は下記の図のように、複数の箱が連結しているような構造になっています。\nそれぞれの入れ物には番号が順番に割りふられており、番号は「0」から始まります。\nこの番号は インデックス といい、配列に格納されている値を 要素 といいます。\nまた、配列は変数に代入することもできます。\n下記のサンプルは果物の名前を配列で管理した場合のコードとなります。\nコード.gs function outputArray_1() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;]; console.log(fruits); } [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;] 配列の特徴 配列には以下の3つの特徴があります。\n配列の各要素は添字（インデックス）をもっており、先頭が0から始まる数字が割り当てられている。 JavaScriptの配列には異なる型の要素を入れることができる。 配列の最後の要素の添字（インデックス）よりも大きな添字を使って代入を行うと、\n配列が自動的に大きくなり、値が指定されていない要素にはundefinedが暗黙的に代入される。 配列の要素の参照と代入 配列から特定の要素を取り出す場合はインデックスを用います。\n配列名[インデックス] 下記のサンプルは配列fruitsからインデックスが1の要素をログに出力しています。\nインデックスは0から始まるため、インデックスが1の要素は先頭から2番目の要素なので、「grape」が出力されます。\nコード.gs function outputArray_2() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;]; console.log(fruits[1]); // \u0026#39;grape\u0026#39; } また、配列内の特定の要素を代入で更新することもできます。\n配列名[インデックス] = 値; 配列内に指定したインデックスの要素が存在する場合は上書きされます。\n逆に、配列内に指定したインデックスの要素が存在しない場合は要素の追加がなされます。\nコード.gs function outputArray_3() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;]; fruits[4] = \u0026#39;peach\u0026#39;; console.log(fruits); // \u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;, null, peach fruits[3] = \u0026#39;berry\u0026#39;; console.log(fruits); // \u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;, berry, peach } 多次元配列 先ほどは配列の要素をインデックスで指定して値を取り出したり、上書きしたりしました。\n実はこの要素には配列を設定することができ、配列の中に配列がある 二次元配列 を作ることができます。\nこのように配列が入れ子になっている配列を 多次元配列 といいます。\n二次元配列は下記のように記述することで初期化することができます。\nvar foods = [[\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;], [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;], [\u0026#39;tuna\u0026#39;]]; 二次元配列は要素が多くなるほど構造が複雑になりイメージがしづらいかもしれません。\nそのようなときは下図のように箱の中に箱があるとイメージすると考えやすくなるでしょう。\n二次元配列に対して、「入れ子」になっていない通常の配列を一次元配列といいます。\n二次元配列から特定の要素を取り出す場合もインデックスを用います。\nコード.gs function outputArray_4() { var foods = [[\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;], [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;], [\u0026#39;tuna\u0026#39;]]; console.log(foods[0]); // \u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39; foods[2] = [\u0026#39;carrot\u0026#39;]; console.log(foods); // [\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;], [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;], [\u0026#39;carrot\u0026#39;] } 二次元配列の内側の要素を取り出すには、外側のインデックスに続けて内側のインデックスも指定します。\n配列名[インデックス1][インデックス2] 配列名[インデックス1][インデックス2] = 値; 二次元配列の内側の要素の参照、代入および追加は下記のサンプルのように記述することができます。\nコード.gs function outputArray_5() { var number = [[1, 2, 3], [10, 20], [100]]; console.log(number[0][0]); // 1 console.log(number[1][0]); // 10 console.log(number[1][1]); // 20 } function outputArray_6() { var number = [[1, 2, 3], [10, 20], [100]]; number[0][0] = 0; // 要素への代入 number[2][1] = 200; // 要素の追加 console.log(number); // [0, 2, 3], [10, 20], [100, 200] } GASではスプレッドシートのシートの行列のデータを利用する際にこの二次元配列を扱いますので、\n一次元配列だけでなく多次元配列についても理解しておく必要があります。\n配列要素の操作 配列の要素を操作するメソッドは多々ありますが、\n「配列内の要素を変更してしまうメソッド」と「新しい配列を返すメソッド」の２種類に分けられます。\n先頭の要素を操作する 配列の先頭はarr[0]と表現します。\n先頭の要素を操作する関数は下記の2つで、それぞれ配列そのものを変更します。\nshiftメソッド: 先頭の要素を削除する。削除した要素を返す。\nunshiftメソッド: 先頭に要素を追加する。追加後の配列の長さを返す。\nコード.gs var arr = [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; console.log(arr.shift()); // b console.log(arr); // [ \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] console.log(arr.unshift(\u0026#39;a\u0026#39;)); // 3 console.log(arr); // [ \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] 最後の要素を操作する 配列の最後はarr[arr.length - 1]と表現します。\n最後の要素を操作する関数は下記の2つで、それぞれ配列そのものを変更します。\npushメソッド：最後に要素を追加する。追加後の配列の長さを返す。\npopメソッド:最後の要素を削除する。削除した要素を返す。\nコード.gs var arr = [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; console.log(arr.push(\u0026#39;e\u0026#39;)); // 4 console.log(arr); //[ \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] console.log(arr.pop()); // e console.log(arr); // [ \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] 複数の要素を追加する concatメソッドは複数の要素を配列に追加し、戻り値として配列のコピーを返します。\n引数として渡された配列の全ての要素を対象の配列の最後に追加します。\nコード.gs var arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; var arr2 = arr1.concat(\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;); console.log(arr1); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] console.log(arr2); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] concatメソッドは引数として配列を指定することもできます。\nコード.gs var arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; var arr2 = arr1.concat([\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]); console.log(arr1); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] console.log(arr2); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] 引数に多次元配列を指定することもできますが、その場合は内側の配列はそのまま追加されます。\nコード.gs var arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; var arr2 = arr1.concat([\u0026#39;d\u0026#39;, [\u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]]); console.log(arr1); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] console.log(arr2); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, [ \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39; ] ] 配列内の要素を部分的に取り出す 配列の要素のうち一部のみを取り出したい場合はsliceメソッドを使います。\nsliceメソッドは２個の引数を渡します。\n1つめは「要素を取得する開始位置（インデックス）」、2つめは「要素を取得する終了直前の位置（インデックス）」を指定します。\n第２引数を省略すると最後の要素まで取得することになります。\nまた、第2引数に負の値を指定すると最後の要素から数えた場所を指定することになります。\nコード.gs var arr1 = [1, 2, 3]; var arr2 = arr1.slice(1); // 元の配列に変化はない console.log(arr1); // [ 1, 2, 3 ] // インデックスが１以降の要素が表示される。 console.log(arr2); // [ 2, 3 ] コード.gs var arr1 = [1, 2, 3]; var arr2 = arr1.slice(1, 3); // 元の配列に変化はない console.log(arr1); // [ 1, 2, 3 ] // インデックスが１の要素からインデックスが\u00083の直前の要素までが表示される。 console.log(arr2); // [ 2, 3 ] コード.gs var arr1 = [1, 2, 3]; var arr2 = arr1.slice(1, -1); // 元の配列に変化はない console.log(arr1); // [ 1, 2, 3 ] // インデックスが１の要素から最後のインデックスが\u0008１つ前の要素までが表示される。 console.log(arr2); // [ 2 ] 途中の要素の削除や追加 spliceメソッドを使うと配列の任意の場所を指定して内容を変更することができます。\n第1引数には変更を開始する添字（インデックス）、第2引数には削除する要素の数、\n第3引数以降に追加する要素を指定します。\n戻り値として削除された要素からなる配列を返します。\nコード.gs var arr1 = [1, 4, 5]; var arr2 = arr1.splice(1, 0, 2, 3); // インデックス1の要素に3と4を追加 // 元の配列に要素が追加される console.log(arr1); // [ 1, 2, 3, 4, 5 ] // 要素は削除されていないため要素は返されない console.log(arr2); // [] コード.gs var arr1 = [1, 4, 5]; var arr2 = arr1.splice(1, 2, 2, 3); // インデックス1の要素に3と4を追加 // 元の配列の要素が削除された上で要素が追加される console.log(arr1); // [ 1, 2, 3 ] // 削除された要素が返される console.log(arr2); // [ 4, 5 ] 配列内の要素の逆転とソート 配列の要素を逆順で並び替える場合はreversseメソッドを使用します。\nコード.gs var arr1 = [5, 4, 3, 2, 1]; arr1.reverse(); console.log(arr1); // [ 1, 2, 3, 4, 5 ] また、sortメソッドは配列の要素のソート（並び替え）をします。\n既定のソート順は昇順で、要素を文字列に変換してからUTF-16コード単位の値の並びとして比較します。\nコード.gs var arr1 = [3, 4, 2, 1, 5]; arr1.sort(); console.log(arr1); // [ 1, 2, 3, 4, 5 ] sortメソッドで配列内のオブジェクトも並び替えることができるのですが、\nその際にプロパティ値で並び替えることができます。\n配列内の要素の検索 配列内の要素を検索する方法をいくつかあります。\nindexOfメソッド 指定した値に厳密に等しい要素（===で等しい要素）をもつ最初の添字を返すメソッドです。\nまた、lastIndexOfメソッドは同様に最後の添字を返します。\n配列の一部だけを検索対象としたい場合は引数に開始位置を指定します。\nちなみに、要素が見つからなかった場合は-1を返します。\nコード.gs var arr = [1, 2, 3, 4, 1]; console.log(arr.indexOf(1)); // 0 console.log(arr.lastIndexOf(1)); // 4 console.log(arr.indexOf(5)); // -1 console.log(arr.lastIndexOf(-1)); // -1 上記のサンプルの通り、見つかった場合は添字番号（インデックス）を返し、見つからなかった場合は-1を返します。\nmapとfilter mapメソッドは配列内の要素に対して、引数で指定した関数を呼び出してその結果から新しい配列を生成します。\nコード.gs var fruits = [{name: \u0026#39;apple\u0026#39;, price: 300}, {name: \u0026#39;banana\u0026#39;, price: 400}]; // オブジェクトから名前のみ抽出して配列を生成する。 var names = fruits.map(function(fruit) { return fruit.name; }); // オブジェクトから価格のみ抽出して配列を生成する。 var prices = fruits.map(function(fruit) { return fruit.price; }); console.log(fruits); // [ { name: \u0026#39;apple\u0026#39;, price: 300 }, { name: \u0026#39;banana\u0026#39;, price: 400 } ] console.log(names); // [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;] console.log(prices); // [330, 440] 上記のサンプルでは要素（fruit）を1つずつ取り出し、その要素のプロパティ（name, price）を取得しています。\nmapメソッドの引数に関数を渡して、取得した要素を第1仮引数に設定して関数内の処理を行っています。\n関数に渡した第1仮引数は要素そのものですが、第2仮引数と第3仮引数も指定することできます。\n第２仮引数は添字（インデックス）が渡され、第３仮引数はメソッドを実行した配列そのものが渡されます。\nコード.gs var fruits = [{name: \u0026#39;apple\u0026#39;, price: 300}, {name: \u0026#39;banana\u0026#39;, price: 400}]; // 第1引数は要素そのもの、第2引数は添字、第3引数は配列そのものが設定されます。 var values = fruits.map(function(fruit, index, _fruits) { // ※第1引数の要素そのものを使用して、fruit.name でも名前を取得できます。 return {index: index, name: _fruits[index].name}; }); console.log(values); // [ { index: 0, name: \u0026#39;apple\u0026#39; }, { index: 1, name: \u0026#39;banana\u0026#39; } ] filterメソッドは配列の内容を特定の条件を絞り込むメソッドです。\nfiterはその名前の通り、配列から不要な要素を取り除く（フィルタリングする）ことができます。\nコード.gs var fruits = [{name: \u0026#39;apple\u0026#39;, price: 300}, {name: \u0026#39;banana\u0026#39;, price: 400}]; // オブジェクトから価格が300よりも大きい要素抽出して配列を生成する。 var _fruits = fruits.filter(function(fruit){ return fruit.price \u0026gt; 300; }); console.log(fruits); // [ { name: \u0026#39;apple\u0026#39;, price: 300 }, { name: \u0026#39;banana\u0026#39;, price: 400 } ] console.log(_fruits); // [ { name: \u0026#39;banana\u0026#39;, price: 400 } ] "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_6/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "ここまでで、皆さんはGASでコーディングした関数を実行することができるようになりました！\nでは早速GASをバリバリコーディングしていきましょう！と言いたいところですが、\nGASをコーディングするにはJavaScriptの基礎構文や制御構文を理解できているか否かで、できることの幅が大きく変わってきます。\nそこで、次章では JavaScript基礎編 と題しまして、GASの実行環境でJavaScriptを動かしながら学んでいきます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_6/",
	"title": "Web画面からGASの関数を実行してみましょう",
	"tags": [],
	"description": "",
	"content": "ここまでは主にクライアントサイドのコーディングをしてきましたが、\nここからはサーバーサイドのコーデイングをしていきましょう。\nGoogle Apps Script のサーバーサイドは.gsファイルにコーディングします。\nGoogle Apps Script の関数の作り方について それでは.gsファイルにコーディングをしてみましょう。\n今回はスプレッドシートから値を取得する関数と、スプレッドシートへ値を設定する関数を作成してみます。\nコード.gs var SHEET_ID = \u0026#39;シートのID\u0026#39; var SHEET_NAME = \u0026#39;シートの名前\u0026#39; function getSheetData() { // 1. スプレッドシートを特定して取得します。 var spreadsheet = SpreadsheetApp.openById(SHEET_ID); // 2. シートを特定して取得します。 var sheet = spreadsheet.getSheetByName(SHEET_NAME); // 3. セル（範囲）を特定して取得します。 var range = sheet.getRange(\u0026#39;A1\u0026#39;); // 4. 対象のセルの入力値を返します。 return range.getValue(); } function setSheetData() { // 1. スプレッドシートを特定して取得します。 var spreadsheet = SpreadsheetApp.openById(SHEET_ID); // 2. シートを特定して取得します。 var sheet = spreadsheet.getSheetByName(SHEET_NAME); // 3. セル（範囲）を特定して取得します。 var range = sheet.getRange(\u0026#39;A1\u0026#39;); // 4. 対象のセルの入力値を返します。 range.setValue(\u0026#39;hello!\u0026#39;); } シートのID と シートの名前 は作成した Google スプレッドシートの ID と シートの名前 を入力してください。\nこれで Google Apps Script の関数は用意できました。\n次は用意した関数をクライアントサイドから呼び出してみましょう。\ngoogle.script.run について クライアントサイドでgoogle.script.runを使用すると、サーバーサイドの Google Apps Script 関数を実行することができます。\n【リファレンス】google.script.run それでは、早速先ほど作成したsetSheetData()を呼び出してみましょう。\nindex.html \u0026lt;script\u0026gt; google.script.run.setSheetData(); \u0026lt;/script\u0026gt; 今回はクライアントサイドで関数の中から呼び出さず、scriptタグの中にコーディングしているため、\n画面が表示されるタイミングで実行されます。\n画面を表示したのち、対象のシートのA1セルに hello! と表示されるかを確認してみましょう。\n引数を渡す 先ほどは 対象のシートのA1セルに hello! と表示されるようにしましたが、\nクライアントサイドで表示する値を設定できるようにしてみましょう。\nsetSheetData()に引数を渡せるようにコードを変更します。\n変更点は次の３点です。\nクライアントサイドでsetSheetData()を呼び出す際に、引数に値（\u0026lsquo;こんにちは！\u0026rsquo;）を設定する。 サーバーサイドのsetSheetData()が引数の値を受け取ることができるように、丸括弧内に変数 (value)を設定する。 最後のrange.setValue('hello!')の丸括弧内の\u0026rsquo;hello!\u0026lsquo;を変数（value）に置き換える。 index.html コード.gs \u0026lt;script\u0026gt; google.script.run.setSheetData(\u0026#39;こんにちは！\u0026#39;); \u0026lt;/script\u0026gt; function setSheetData(value) { // 1. スプレッドシートを特定して取得します。 var spreadsheet = SpreadsheetApp.openById(SHEET_ID); // 2. シートを特定して取得します。 var sheet = spreadsheet.getSheetByName(SHEET_NAME); // 3. セル（範囲）を特定して取得します。 var range = sheet.getRange(\u0026#39;A1\u0026#39;); // 4. 対象のセルの入力値を返します。 range.setValue(value); } 変更したのちWeb画面を更新して、対象のシートのA1セルにこんにちは！と出力されているかを確認しましょう。\n画面で入力した値をスプレッドシートに出力する 先ほど実行した関数によって、クライアントサイドから値を渡すことができることを確認しました。\n次はクライアントサイドで入力した値をサーバーサイドに渡してみましょう。\nindex.html \u0026lt;input type=\u0026#39;txt\u0026#39; id=\u0026#39;msg\u0026#39; onclick=\u0026#39;output()\u0026#39; /\u0026gt; \u0026lt;script\u0026gt; function output() { // 1. テキストボックスに入力した値を取得します。 var value = document.getElementById(\u0026#39;msg\u0026#39;).value; // 2. 取得した値を setSheetData関数の引数として設定して呼び出します。 google.script.run.setSheetData(value); } \u0026lt;/script\u0026gt; 変更したのちWeb画面を更新して、対象のシートのA1セルに、テキストボックスに入力した値が出力されているかを確認しましょう。\n同期処理と非同期処理について 次はサーバーサイドから値を取得してみましょう。\n先ほどコーディングしたgetSheetData()を実行してみます。\nindex.htmlを下記の通りに変更したのち、Web画面を更新してコンソールログに値が表示されるかを確認してみましょう。\nindex.html \u0026lt;script\u0026gt; // 1. スプレッドシートから値を取得する var result = google.script.run.getSheetData(); // 2. 取得した値をコンソールログ表示する console.log(result); \u0026lt;/script\u0026gt; コンソールログにはundefinedと表示されました。\nこれはconsole.log(result)で表示しようとしているresult変数の中身が空っぽということになります。\ngetSheetData()が実行されなかったのでしょうか。\n実はgetSheetData()は実行されていますが、その戻り値が返ってくる前にconsole.log(result)が実行されているのです。\nこのような事象が起きるのは、JavaScriptのアプリケーションが「シングルスレッド」で実行されているためです。\n「シングルスレッド」を端的に説明すると、 一度にひとつのことを実行していく処理 ということです。\nつまり、1度に1つの処理しかできない（並列処理ができない）のです。\nしかし、非同期処理により外部に処理を任せている間に自身の処理を進めることができます。\n同期処理とは 同期処理はコーディングした処理の上から順番に実行されるという意味です。\n上から順番に実行されるのでシンプルですね。\n下記のスクリプトも同期処理で動いているため、アラートは「1」、「2」、「3」と順に表示されます。\nindex.html \u0026lt;script\u0026gt; alert(1); // ① alert(2); // ② alert(3); // ③ \u0026lt;/script\u0026gt; 非同期処理とは 非同期処理は外部に処理を任せている間に自身の処理を進めることができます。\n先ほどシートの値を取得しようとしたスクリプトで確認してみましょう。\nindex.html \u0026lt;script\u0026gt; // 1. スプレッドシートから値を取得する var result = google.script.run.getSheetData(); // 2. 取得した値をアラートで表示する console.log(result); \u0026lt;/script\u0026gt; getSheetData()でブラウザから Google サーバーに処理を行うように命令をしています。（具体的にはシートから値を取得するように命令しています。）\nしかし、このように外部（Google サーバー）に処理を行うように命令した場合は、その処理結果（戻り値）を待たずにクライアントサイドのJavaScriptは順次処理を続行してしまいます。\nこれが非同期処理です。\nしかし、GAS関数の戻り値を受け取って同期処理を行いたいですよね。\nそれを実現するのがwithSuccessHandlerメソッドとwithFailureHandlerメソッドです。\nwithSuccessHandler について withSuccessHandlerメソッドの特徴は 「クライアントサイドからGAS関数を呼び出した後の処理を設定できる」 ことです。\nこれらのメソッドを活用することでGAS関数で取得した結果をクライアントサイドに表示することができます。\nしかし、活用するには コールバック関数 を理解する必要があります。\nコールバック関数とは 日常生活でコールバックと言いますと、「かかってきた電話に対して電話をかけ直す（折り返し電話をする）」という意味で使われますね。\nJavaScriptでコールバックは「後々呼び出すために定義した関数」という意味で使われます。\nただ、このコールバックされる関数は特別なことは何もなく、普通のJavaScriptの関数です。\nでは、具体的にどのように使用するのかを下記のようにHTMLを修正して確認してみましょう。\nindex.html \u0026lt;script\u0026gt; // 数値の2を返す関数（後々呼び出すためにコーディングされた関数） function getNumber() { return 2; } // 1. コンソールログに「1」を表示する。 console.log(1); // 2. コンソールログに「getNumber関数の戻り値」を表示する。 console.log(getNumber()); // 3. コンソールログに「3」を表示する。 console.log(3); \u0026lt;/script\u0026gt; 上記ではgetNumber関数というコールバック関数をコーディングしています。\nこのコールバック関数をconsole.log(getNumber());で呼び出して実行しています。\nこのように 即時実行するのではなく、後々実行するための関数を定義することができます。\nこれがwithSuccessHandlerメソッドとどのように関係があるのか？といいますと、\nこれらのメソッドは　クライアントサイドからGAS関数を呼び出した後の処理を設定できる のですが、\nGAS関数を呼び出した後の処理をコールバック関数で定義することができるのです。\nwithSuccessHandlerとは GAS関数（サーバーサイドの関数）が 正常に完了 して戻り値が返ってきた場合に、\n実行する関数を定義することができます。\nコーディングの仕方は下記の通りです。\ngoogle.script.run.withSuccessHandler(コールバック関数).GAS関数() それでは、シートから値を取得するgetSheetData()を同期処理で取得してアラートでその値を表示してみましょう。\n先ほどはundefinedと返ってきましたが、シートのA1セルの値が表示されれば成功です。\nindex.html \u0026lt;script\u0026gt; function outputResult(result) { console.log(result); } google.script.run.withSuccessHandler(outputResult).getSheetData(); \u0026lt;/script\u0026gt; 上記のコードは下記のようにコールバック関数をwithSuccessHandlerメソッドの引数として設定してコーディングすることができます。\n（少しコードの量が少なくなりますね！）\nindex.html \u0026lt;script\u0026gt; google.script.run.withSuccessHandler(function(result){ console.log(result); }).getSheetData(); \u0026lt;/script\u0026gt; "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/page_3/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "最後に "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page_2_1_9/",
	"title": "オブジェクト",
	"tags": [],
	"description": "",
	"content": "オブジェクトとは 複数のデータを扱う方法として配列について説明をしましたが、JavaScriptには他にも複数のデータの集合を扱う方法があります。\nそれが オブジェクト です。（連想配列やハッシュとも呼ばれています。）\nオブジェクトは下記のようにプロパティと値の間をコロン（:）で繋いだ組み合わせをカンマ区切りで記述し、全体を波括弧（{}）で囲むことで生成できます。\nこの表記方法を オブジェクトリテラル といいます。\n{ プロパティ1: 値1, プロパティ2: 値2 } 配列ではインデックスをキーにしてその要素を参照したり、代入したりすることができました。\n一方、オブジェクトでは プロパティ をキーにすることで、同様に要素への参照や代入を行うことができます。\n下記の図のように複数の入れ物に、それぞれ名前がつけている構造です。\nそれぞれの入れ物につけられている名前がプロパティとなります。\nオブジェクトは文字列であるプロパティをキーにしてデータにアクセスできるので、配列と比べると可読性の高いデータ構造と言うことができます。\n図の配列を初期化するスクリプトは下記のよう記述することができます。\nvar person = {name: \u0026#39;Taro\u0026#39;, age: 22, gendar: \u0026#39;male\u0026#39;}; プロパティには数値や文字列などのデータのほか、関数を格納することができます。関数を格納されたプロパティはメソッドといいます。\nプロパティの参照と代入 オブジェクトから値を取り出す方法は２つあります。\n1つ目はドット（.）でプロパティを指定する ドット記法 、もう一つが角括弧（[]）内に文字列のプロパティで指定する ブラケット記法 です。\n// ドット記法 オブジェクト名.プロパティ // ブラケット記法 オブジェクト名[\u0026#39;プロパティ\u0026#39;] 下記のサンプルではドット記法とブラケット記法でプロパティで値を取得してログに出力しています。\nコード.gs function outputObject_1() { var person = {name: \u0026#39;Taro\u0026#39;, age: 22, gendar: \u0026#39;male\u0026#39;}; console.log(person.name); // Taro console.log(person[\u0026#39;age\u0026#39;]); // 22 } 一般的にドット記法の方が単純に記述できて可読性も高いので、どちらでもよい場合はドット記法を使うことがおすすめです。\n一方で、ブラケット記法は変数を使用してプロパティの指定ができることがメリットと言えます。\nfor in 文 によるループ内でプロパティの値を取り出す際などはブラケット記法が有効です。\nいずれの記法でも下記のようにイコール（=）を使うことで指定したプロパティの値を代入することができます。\nまた、オブジェクトに存在しないプロパティを指定して代入をするとオブジェクトにプロパティと値が追加されます。\n// ドット記法 オブジェクト名.プロパティ = 値; // ブラケット記法 オブジェクト名[\u0026#39;プロパティ\u0026#39;] = 値; コード.gs function outputObject_2() { var person = {name: \u0026#39;Taro\u0026#39;, age: 22, gender: \u0026#39;male\u0026#39;}; person.name = \u0026#39;Hanako\u0026#39;; person[\u0026#39;gender\u0026#39;] = \u0026#39;female\u0026#39;; person.job = \u0026#39;Engineer\u0026#39;; console.log(person); // {name:\u0026#39;Hanako\u0026#39;, age:22, gender:\u0026#39;female\u0026#39;, job:\u0026#39;Engineer\u0026#39;} } 存在しないプロパティから値を取り出そうとすると、その値はundefinedとなります。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_7/",
	"title": "Web画面にスプレッドシートの値を表示してみましょう",
	"tags": [],
	"description": "",
	"content": "Scriptletについて GASで生成した値を画面に出力したいときは　Scriptlet を使用すると簡単に出力することができます。\nScriptletには「Standard scriptlets」と「Printing scriptlets」の２種類があります。\nStandard scriptlets スクリプトとして実行しますが、結果は画面に出力されません。\nfor文などの処理をしたい場合に記述します。\n\u0026lt;? ... ?\u0026gt; Printing scriptlets スクリプトの実行結果を画面に出力することができます。\n\u0026lt;?= ... ?\u0026gt; スプレッドシートの値を表示する Scriptletを使用するとスプレッドシートの値を画面に出力することができます。\n以下のサンプルで確認をしてみましょう。\nCode.gs\nfunction doGet(e) { var template = HtmlService.createTemplateFromFile(\u0026#39;index\u0026#39;); var sheet = SpreadsheetApp.openById(\u0026#39;XXXX\u0026#39;).getSheetByName(\u0026#39;XXXX\u0026#39;); var values = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).getValues(); template.values = values; // シートから取得した値を画面に渡します return template.evaluate(); } index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026#34;_top\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;header\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;成績表\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;events\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;名前\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;国語\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;英語\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;数学\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;? for (var i = 0; i \u0026lt; values.length; i++) { ?\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][0]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][1]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][2]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][3]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;? } ?\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 注目する点は index.html の以下の処理です。\nScriptlet を活用してスプレッドシートから取得した値（values）を設定しています。\n\u0026lt;? for (var i = 0; i \u0026lt; values.length; i++) { ?\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][0]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][1]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][2]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][3]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;? } ?\u0026gt; "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page_2_1_10/",
	"title": "演算子",
	"tags": [],
	"description": "",
	"content": "算術演算子とは 演算子 は値や変数などに対して、処理を行うための記号です。\n演算子にはいくつか種類があり、そのうちのひとつの 算術演算子 は、四則演算子など計算を行うための演算子です。\n下記にJavaScriptで一般的に使用する算術演算子をまとめています。\n演算子 概要 使用例 + 数値の加算または文字列の連結 1 + 2, \u0026lsquo;a\u0026rsquo; + \u0026lsquo;bc\u0026rsquo; - 数値の減算または符号の反転 3 - 1, -(-1) * 数値の乗算 10 * 2 / 数値の徐算 10 / 2 % 数値の剰余 11 % 3 コード.gs function outputCalculate_1() { var x = 11; var y = 4; console.log(x + y); // 15 console.log(x - y); // 7 console.log(x * y); // 44 console.log(x / y); // 2.75 console.log(x % y); // 3 console.log(-x); // -11 } 式の中に複数の演算が含まれている場合、数学での演算と同様に加減よりも乗除の方が優先して処理されます。\n優先順位が同列である場合は左に記述されている順に処理されます。\nまた、この優先順位は丸括弧を使用することで任意で変えることができます。各演算子の優先順位は下記の通りです。\n演算子 優先順位 処理の内容 () 1 丸括弧 - 2 符号を反転 * 3 乗算 / 3 徐算 % 3 剰余 + 4 数値の加算 + 4 文字列の連結 - 4 減算 「+」による演算は、演算対象の値が どちらか一方が文字列である場合は文字列の連結 を行い、共に数値である場合は加算 を行います。\nこの処理がどの段階で行われるかは下記のサンプルを実行して確認してみましょう。\nコード.gs function outputCalculate_2() { console.log(1 + 2); // 3 console.log(1 + \u0026#39;2\u0026#39;); // 12 console.log(1 + 2 + \u0026#39;3\u0026#39;); // 33 console.log(1 + \u0026#39;2\u0026#39; + 3); // 123 } インクリメント演算子とデクリメント演算子 JavaScriptには数値を1だけ加算する インクリメント演算子 と 数値を1だけ減算する デクリメント演算子 があります。\n演算子 処理の内容 ++ インクリメント（1だけ加算） \u0026ndash; デクリメント（1だけ減算） インクリメント演算子とデクリメント演算子は 演算対象となる変数の値自体を変更します。\nそのため、下記の表の通りこの演算子を使用することで省略して書くことができます。\n省略後の書き方 省略前の書き方 x++ x = x + 1 x\u0026ndash; x = x - 1 下記のサンプルを記述したのち実行して確認してみましょう。\nコード.gs function outputCalculate_3() { var x = 10; x++; // インクリメント console.log(x); // 11 x--; // デクリメント console.log(x); // 10 } インクリメント演算子やデクリメント演算子は「++x」のように変数の前に演算子を書く方法と、\n「x++」のように変数の後に演算子を書く方法の2つがあります。\n実はこの2つの書き方ではそれぞれ値を返すタイミングが異なります。\n++xと\u0026ndash;xの場合：変数をインクリメント・デクリメントした値を返す。 x++とx\u0026ndash;の場合：変数の値を返したのち、インクリメント・デクリメントをする。 それぞれの違いについては下記のサンプルで確認をしてみましょう。\nコード.gs function outputCalculate_4() { var x = 1; var y = 10; console.log(++x); // 2 console.log(x); // 2 console.log(y++); // 10 console.log(y); // 11 } 「++x」のログ出力はインクリメントされた後の値が出力されます。\n一方、「y++」のログ出力はインクリメントされる前の値が出力され、その後にインクリメントされていることが確認できます。\n代入演算子 代入演算子 とは、変数に値を代入する演算子です。ここまで登場してきました「=」も代入演算子です。\nまた、代入演算子には代入と同時に処理を行う複合代入演算子が存在しています。\n代入演算子 概要 使用例 = 左辺の変数に値を代入 x = 10 += 左辺の変数に右辺の値を加算して代入 x += 10 -= 左辺の変数に右辺の値を減算して代入 x -= 10 *= 左辺の変数に右辺の値を乗算して代入 x *= 10 /= 左辺の変数に右辺の値を徐算して代入 x /= 10 %= 左辺の変数に右辺の値で徐算した剰余を代入 x %= 10 複合代入演算子はそれぞれ下記の記法で表現することができ、使用することでスクリプトをシンプルに記述することができます。\n省略後の書き方 省略前の書き方 x += 1 x = x + 1 x -= 1 x = x - 1 x *= 1 x = x * 1 x /= 1 x = x / 1 x %= 1 x = x % 1 下記のサンプルを記述し、実行して確認してみましょう。\nコード.gs function outputCalculate_5() { var x = 1; var y = 10; x += 5; console.log(x); // 6 y *= 5; console.log(y); // 50 } 演算子には算術演算子や代入演算子の他にも存在し、比較演算子や論理演算子があります。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/value/page2_1_11/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "JavaScriptの基本構文、変数、データ型、演算子について解説しました。\n配列とオブジェクトは直感的にイメージするのが難しいと思いますが、GASでは重量な役割を果たしていますのでしっかり理解をしておきましょう。\nここまでは書かれている順番にステートメントを上から順番に実行する「順次処理」のみを紹介してきましたが、\n実際のプログラミングは途中で処理を分岐したり、同じ処理を何度も繰り返したりします。\n次のチャプターではこのようなより多様な処理パターンである「条件分岐処理」と「繰返処理」のコーディング方法について学んでいきましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/calendar/page_5/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "GASでのカレンダーの予定の作成、参照、更新、削除を行う方法について解説いたしました。\nこれで GAS を使ってカレンダーを自由に操作ができるようになったと思います。\nいよいよ、次はGASでWebアプリケーションを作ってみましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/es2015/page_2_5_7/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "ES2015(ES6)で利用できるようになった構文や関数について解説しました。\n他にも同期処理を実現するPromiseもあるのですが、\nこちらはWebアプリ編で紹介します。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_7/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "GASでのスプレッドシートの操作、およびSpreadsheetサービスの基本となるクラスについて解説してきました。\nスプレッドシートはGASによるシステムではデータベースとしての役割を果たしますので、ぜひ活用してください。\nいよいよ、次はGASでWebアプリケーションを作ってみましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/",
	"title": "GAS Edu",
	"tags": [],
	"description": "",
	"content": "GAS Edu 本コンテンツはGAS初心者向けのハンズオン形式の教材となります。\nコンテンツ一覧 ※ 未公開のコンテンツは随時更新予定\nNo. コンテンツ名 ステータス 1 入門編 公開済 2 JavaScript基礎編 公開済 3 スプレッドシート編 公開済 4 Googleカレンダー編 公開済 5 Webアプリ編 公開済 6 ローカル開発編 公開済 "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]