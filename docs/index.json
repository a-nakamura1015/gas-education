[
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "目標のゴール  ローカル環境でGAS開発できるようになること  それではローカル開発編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "前提条件  GASの開発環境が整備されていること（Chapter1が完了していること） JavaScriptの基礎を理解していること（Chapter2が完了していること）  目標のゴール  GASでスプレッドシートを操作できるようになること  それではスプレッドシート編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/object_mechanism/page_2_4_1/",
	"title": "オブジェクト",
	"tags": [],
	"description": "",
	"content": "オブジェクトとは オブジェクトは「物」や「対象」という意味ですが、\nプログラミングの世界では情報（属性）や機能を持ったデータの集合体という意味になります。\n配列もオブジェクトの一種になります。\n本章ではJavaScriptの「オブジェクト指向」の入り口にあたる部分について解説していきます。\n「オブジェクト指向」というと難しく見えてしまい、できれば避けたいと思うかもしれませんが、\nGASの各サービスはこのオブジェクトの仕組みに忠実に構成されています。\nつまり、JavaScriptのオブジェクトの仕組みが理解できているのとそうでないのとでは、これからのJavaScriptとGASの習得スピードと理解度に明らかな差が出てきます。å\nプロパティとメソッドとは オブジェクトはプロパティと呼ばれるデータを持つことができます。\nプロパティは属性とも呼ばれ、データを管理する役割を果たすことができます。\nプロパティを理解するために、まずはオブジェクトの書式について確認してみましょう。\nオブジェクトは次のようなプロパティと値の組み合わせのデータの集合体です。\n{ プロパティ１:値１, プロパティ２:値２ } プロパティに設定した値は以下のようにして取得することができます。\nオブジェクト名.プロパティ 実際にオブジェクトを作ってみましょう。\n次の例は学業の成績データをオブジェクトにしてみました。\n成績データ（result）は各科目の点数を格納しており、\n国語（japanese）・数学（math）・英語（english）の点数を持っています。\nfunction object_1() { var result = { japanese: 100, math: 80, english: 90 } console.log(result.japanese); console.log(result.math); console.log(result.english); } 100 80 90 プロパティは変数と同様に再代入することができます。\n次の例は成績データ（result）の国語（japanese）に0を再代入しています。\nfunction object_2() { var result = { japanese: 100, math: 80, english: 90 } console.log(result.japanese); result.japanese = 0; console.log(result.japanese); } 100 0  おそらく、プログラミング初心者にとってはオブジェクト名.プロパティという記法が難しく感じられるかもしれません。\nそのような時は、.をのに置き換えるとしっくりくると思います。\n例えば、先程の例の成績データ（result）の国語（japanese）の点数を取得する際にresult.japaneseとコーディングしましたが、\nresultのjapanaseと置き換えるとどうでしょう？\nこうすると、成績データ（result）の国語（japanese）と読めるようになると思います。\n 実は、オブジェクトの値として関数を持たせることができます。\nこのように、オブジェクトの要素として関数を指定した場合は、その要素をプロパティとは呼ばずに メソッド と呼びます。\n以下のような要素がオブジェクトに含まれていれば、それがメソッドとなります。\nメソッド: function(仮引数１, 仮引数２, ...) { // 処理  return 戻り値; }  メソッドとは、関数が格納されたプロパティのことです。\n プロパティを呼び出す場合と同様に、メソッドは以下のようにして呼び出すことができます。\nメソッドは関数のため、いくつかの引数を持つこともできます。\nオブジェクト名.メソッド(引数１, 引数２) では、下記のサンプルで確認していきましょう。myGreetオブジェクトのsayHelloというメソッドを用意して呼び出しています。\nvar myGreet = { sayHello: function() { return \u0026#39;Hello!\u0026#39;; } } function outputObj_1() { console.log(myGreet.sayHello()); } Hello! つまり、オブジェクトは 「情報」としてのプロパティ だけでなく、「機能」としてのメソッド を持つことができるのです。\nなお、プロパティとメソッドを総じて、オブジェクトの メンバー と呼びます。\nオブジェクトは、メンバーとしてプロパティとメソッドを持つことができます。\n メソッドの代入と追加 プロパティと同じく、メソッドも次のように代入することができます。オブジェクトに存在しないメソッドを代入すると、メソッドの追加になります。\nオブジェクト名.メソッド = function(仮引数１, 仮引数２, ...) { // 処理  return 戻り値; } のmyGreetオブジェクトにsayGoodByeメソッドを追加する処理を加えたものが次のサンプルです。\n実行すると、ログには「Good bye!」も出力され、追加したsayGoodByeメソッドが動作していることが確認できます。\nvar myGreet = { sayHello: function() { return \u0026#39;Hello!\u0026#39;; } } myGreet.sayGoodBye = function() { return \u0026#39;Good bye!\u0026#39; } function outputObj_2() { console.log(myGreet.sayHello()); console.log(myGreet.sayGoodBye()); } Hello! Good bye! "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/page_2_3_1/",
	"title": "宣言と呼び出し",
	"tags": [],
	"description": "",
	"content": "関数の呼び出し おさらいまでに、関数 とは一連の処理をひとつにまとめたものをいいます。\n関数については先ほどご紹介しているので下記を参考にしてください。\n関数とは\nこれまでは関数を実行する際は、スクリプトエディタのツールバーの「関数を選択」のプルダウンで選択した関数から実行してきました。\n実は、関数は「関数を選択」で選択して実行するだけでなく、関数名から 別の関数から呼び出す ことができます。\n関数名() 次のサンプルは他の関数を呼び出す例です。myFunc_1を実行すると、ログには「おはようございます！」と「こんにちは！」、「こんばんは！」が出力されます。\nfunction myFunc_1() { console.log(\u0026#39;おはようございます！\u0026#39;); myFunc_2(); // myFunc_2関数を呼び出す  console.log(\u0026#39;こんばんは！\u0026#39;); } function myFunc_2() { console.log(\u0026#39;こんにちは！\u0026#39;); } おはようございます！ こんにちは！ こんばんは！ JavaScriptにおいて関数はオブジェクトとして扱われます。\nそのため、他のオブジェクトと同じように引数として関数に渡したり、変数に代入したりすることができます。\n重要なポイントとして押さえてほしいのは、関数の「呼び出し」と「参照」をしっかり区別されるということです。\n関数名に()をつけることでその関数を呼び出しとなり、関数が実行されて値が返されます。\n一方、()をつけずに関数名だけを書くと、その関数を参照しているだけになります。\nまた、関数は参照されるだけで実行されません。\n次の例はgetMessage()で関数の「呼び出し」を行い、\ngetMessageで関数の「参照」を行なっています。\nこのように関数を呼び出さずに参照することができるのですが、\nこの関数の「参照」を利用することでオブジェクトとして扱うことができます。\n（オブジェクトについては次章で解説します。）\nfunction getMessage() { return \u0026#39;Hello!\u0026#39;; } console.log(getMessage()); // Hello! console.log(getMessage); // [Function: getMessage] 続いて、「変数（定数）への代入」を試してみましょう。\n関数を変数に代入することで、関数を別の名前で呼び出すことができます。\nfunction getMessage() { return \u0026#39;Hello!\u0026#39;; } var message = getMessage; // 関数をmessage変数に代入 console.log(message()); // Hello!  同じプロジェクト内であれば、別のgsファイルに記述した関数も呼び出すことができます。\n この例でわかるように、関数を呼び出した場合はその呼び出した関数の処理が完了した時点で元の関数に戻ります。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/page_2_2_1/",
	"title": "処理を分岐させる",
	"tags": [],
	"description": "",
	"content": "if文 JavaScriptではスクリプトを実行すると上から順番にステートメントを1つずつ処理していきます。\nしかし、コーディングを進めていくと処理を分岐させたい場面があります。\nこのような分岐処理を実現する命令の一つが if文 です。\nif文は「もし〇〇ならば〇〇する」という処理を実現することができます。構文は下記の通りです。\nif (条件式) { // 条件式がtrueの場合に実行する処理 } if文では丸括弧の中に条件式を記述します。\n条件式は判定の結果がtrueまたはfalseになる式です。\n条件式の結果がtrueであれば中括弧の中の処理が実行され、falseであれば中括弧の中の処理は実行されません。\n（この中括弧の中を ブロック といいます。）\n下記のサンプルを記述して実行してみましょう。\nfunction outputBranch_1() { var x = 10; if (x \u0026gt; 1) { console.log(\u0026#39;xは1よりも大きいです。\u0026#39;); } } xは1よりも大きいです。  if else 文とelse if文 if文の条件式の結果がfalseだった場合に別の処理をさせたい場合は if else 文 を使用します。\nif (条件式) { // 条件式がtrueの場合に実行する処理 } else { // 条件式がfalseの場合に実行する処理 } 条件式がtrueの場合はifブロック内の処理が実行され、falseの場合はelseブロック内の処理が実行されます。\n下記はif else 文のサンプルになります。変数xに代入する値を変更しながら複数回実行して、意図したブロックの処理が実行されるか確認してみましょう。\nfunction outputBranch_2() { var x = 10; if (x \u0026gt; 10) { console.log(\u0026#39;xは10よりも大きいです。\u0026#39;); } else { console.log(\u0026#39;xは10以下です。\u0026#39;); } } xは10以下です。 if else 文では、条件式がtrueかfalseかで処理を分岐することができます。\nまた、分岐を3つ以上にしたい場合は if else if文 を使うと必要な分だけ条件分岐の処理を作ることができます。\nif (条件式１) { // 条件式１がtrueの場合に実行する処理 } else if (条件式２) { // 条件式２がtrueの場合に実行する処理  ・・・ } else { // すべての条件式がfalseの場合に実行する処理 } 条件式１、条件式２と順番に条件式を判定していき、最初に条件式がtrueだった際に該当のブロック内の処理をします。\nまた、最後のelseは省略することができます。\n下記のサンプルを実行して、if else 文の動作を確認してみましょう。\nfunction outputBranch_4() { var x = 10; if (x \u0026lt; 10) { console.log(\u0026#39;xは10よりも大きいです。\u0026#39;); } else if (x \u0026lt; 20) { console.log(\u0026#39;xは10以上で20よりも小さいです。\u0026#39;); } else { console.log(\u0026#39;xは20以上です。\u0026#39;); } } xは10以上で20よりも小さいです。  else if文でいくつでも条件分岐の処理を追加することができますが、あまりに多いと読みづらいコードになってしまいます。\nこの後登場する論理演算子やswitch文を活用したりして、else if文を多用することは避けるようにしましょう。\n  比較演算子とは これまで登場した「\u0026lt;」は数学と同じく、左辺と右辺を比較して左辺の方が小さければ条件式としてtrueを返します。\nこのような条件式内で使用し、左辺と右辺を比較してtrue、またはfalseを返す役割を持つ演算子を 比較演算子 といいます。\nJavaScriptで使用できる比較演算子は下記の通りです。\n   比較演算子 概要 使用例     == 左辺と右辺の値が等しい場合はtrue 10 == \u0026lsquo;10\u0026rsquo;   != 左辺と右辺の値が等しくない場合はtrue 10 != 11   \u0026lt; 左辺が右辺より小さい場合はtrue 10 \u0026lt; 11   \u0026lt;= 左辺が右辺以下の場合はtrue 10 \u0026lt;= 11   \u0026gt; 左辺が右辺より大きい場合はtrue 10 \u0026gt; 9   \u0026gt;= 左辺が右辺以上場合はtrue 10 \u0026gt;= 9   === 左辺と右辺が値もデータ型も等しい場合はtrue 10 === 10   === 左辺と右辺が値もデータ型も等しくない場合はtrue 10 !== \u0026lsquo;10\u0026rsquo;    この比較演算子には注意すべき点があります。\n下記のサンプルを実行するとログにはtrueとfalseのどちらが出力されるでしょうか？\nfunction outputComparison_1() { var fruits_1 = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;]; var fruits_2 = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;]; console.log(fruits_1 == fruits_2); // false  var person_1 = {name: \u0026#39;Taro\u0026#39;}; var person_2 = {name: \u0026#39;Taro\u0026#39;}; console.log(person_1 == person_2); // false } 出力されたログの結果は共にfalseになります。\n実は、配列やオブジェクトを変数に代入した場合に、実際に変数に格納されるのはメモリ上のアドレス（参照値）です。\nしたがって、要素や構造が全く同じであったとしても、物理的に別のアドレスに割り当てられている配列またはオブジェクト同士の比較はfalseとなります。\n一方で、下記のサンプルを実行するといずれのログもtrueとなります。\nそれぞれの変数に格納されているアドレスは等しいため比較結果はtrueとなります。\nfunction outputComparison_2() { var fruits_1 = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;]; var fruits_2 = fruits_1; console.log(fruits_1 == fruits_2); // true  var person_1 = {name: \u0026#39;Taro\u0026#39;}; var person_2 = person_1; console.log(person_1 == person_2); // true }  配列とオブジェクトの比較はその参照値の比較となります。\n 寛容な比較と厳密な比較 「==」と「===」の違いと、「!=」と「!==」の違いについて確認していきましょう。\n等価演算子には通常の等価演算子（==）と厳密等価演算子（===）があります。\n「==」と「!=」はデータ型は考慮せずに値を比較しているのに対し、\n「===」と「!==」は比較の際にデータ型も考慮します。\n厳密等価演算子（===）で2つの値が「厳密等価」であると見なされるのは次のいずれかです。\n 同じオブジェクトを参照しているとき プリミティブ型で、データ型も値も同じであるとき  一方、等価演算子（==）は厳密等価より緩い条件で評価します。\n 同じオブジェクトを参照しているとき 「同じ値に変換される」とき  下記のサンプルでそれぞれの演算子の違いを確認していきましょう。\nfunction outputComparison_3() { // 「==」と「===」の違い  console.log(10 == \u0026#39;10\u0026#39;); // true  console.log(10 === \u0026#39;10\u0026#39;); // false  // 「!=」と「!==」の違い  console.log(10 != \u0026#39;10\u0026#39;); // false  console.log(10 !== \u0026#39;10\u0026#39;); // true } 「==」と「!=」は寛容な比較（データがを考慮しない）を行いますが、データ型を考慮しなかったために想定外の結果を引き起こす可能性があります。\nそのため、「===」と「!==」を使用する方がより安全に開発することができます。\n論理演算子とは if文の複数の条件式を同時に判定させたいケースがありますが、現時点では下記のように記述することができます。\nfunction outputLogical_1() { var x = 10; if (x \u0026lt; 10) { if (x =\u0026lt; 20) { console.log(\u0026#39;xは10よりも大きく、20以下です。\u0026#39;); } } } xは10よりも大きく、20以下です。 このようにif文をネスト（入れ子）にすることで複数条件で判定することができますが、\n条件が増えるごとにネスト（入れ子）が増えていきどんどん複雑になっていきます。\n実は複数条件をシンプルに記述できる演算子があり、これを 論理演算子 といいます。\nJavaScriptで使用できる論理演算子は下記の通りです。\n   論理演算子 概要 使用例     \u0026amp;\u0026amp; 左辺と右辺がいずれもtrueであればtrue x === 10 \u0026amp;\u0026amp; y === 100   || 左辺と右辺がいずかがtrueであればtrue x === 10   ! 条件式の結果を反転させる !(x === 10)    この論理演算子を使用すると、先ほどのサンプルを下記のように記述することができます。\n他の論理演算子の結果と合わせて確認しましょう。\nfunction outputLogical_2() { var x = 10; if (x \u0026lt; 10 \u0026amp;\u0026amp; x\u0026lt;= 20) { console.log(\u0026#39;xは10よりも大きく、20以下です。\u0026#39;); } if (x \u0026lt; 10 || x\u0026lt;= 20) { console.log(\u0026#39;xは10よりも大きい、または20以下です。\u0026#39;); } if (!(x \u0026lt; 10)) { console.log(\u0026#39;xは10より小さくないです。\u0026#39;); } } xは10よりも大きく、20以下です。 xは10よりも大きい、または20以下です。 xは10より小さくないです。 switch文 if文による条件分岐では、条件式がtrueかfalseかのどちらかしか分岐処理を記述することができません。\nそれ以上の分岐処理を行いたい場合は先ほど紹介したelse if文で追加することもできますが、\nあまりにも追加する条件式が多い場合は switch文 を使用するとよいでしょう。\nswitch文は、ある式が複数の値のいずれかと一致するかの判定を行うことができ、下記のような記述で実現することができます。\nswitch (式) { case 値１: // 式 === 値１であるときの処理  break; case 値２: // 式 === 値２であるときの処理  break; default: // 式がいずれの値にも一致しなかったときの処理 } switch文では、式の結果と一致する値を、値１、値２・・・の中から探します。\n一致する値が存在すれば、その case節 のステートメントの処理を順次実行していきます。\nbreak文 でswitch文から抜け出し、式の結果と一致する値が存在しなければ default節 のステートメントの処理を実行します。\n例として、下記のサンプルを実行してみましょう。\nfruit変数に代入されている値によって出力されるログの内容が変わりますので、fruit変数に代入する値を変えてみて複数回実行して確認してみましょう。\nfunction outputBranch_5() { var fruit = \u0026#39;apple\u0026#39;; swich(fruit) { case \u0026#39;apple\u0026#39;: console.log(\u0026#39;りんご\u0026#39;); break; case \u0026#39;grape\u0026#39;: console.log(\u0026#39;グレープ\u0026#39;); break; case \u0026#39;orange\u0026#39;: console.log(\u0026#39;オレンジ\u0026#39;); break; default: console.log(\u0026#39;知らないフルーツです！\u0026#39;); } } りんご break文 各case節の処理の末尾にあるbreak文は省略することができますが、原則各case節ごとにbreak文を記述することになります。\nどうしてbreak文が必要なの？と思われるでしょうが、それは下記のサンプルを実行するとわかります。\nfunction outputBranch_5() { var fruit = \u0026#39;apple\u0026#39;; swich(fruit) { case \u0026#39;apple\u0026#39;: console.log(\u0026#39;りんご\u0026#39;); case \u0026#39;grape\u0026#39;: console.log(\u0026#39;グレープ\u0026#39;); case \u0026#39;orange\u0026#39;: console.log(\u0026#39;オレンジ\u0026#39;); default: console.log(\u0026#39;知らないフルーツです！\u0026#39;); } } りんご グレープ オレンジ 知らないフルーツです！ 実行してみると値が一致している「\u0026lsquo;apple\u0026rsquo;」のcase節だけではなく、その他のcase節のログも出力されてしまいます。\n実は、switch文は式に該当するcase節の処理以降の全ての処理を実行する という仕様になっているのです。\nあえて、値が一致したcase節の以降を全て実行させたい場合はbreak文を書く必要はないのですが、各case節ごとでswich文をに抜けたい場合はbreak文を使用します。\nswich文はbreak文がない限りブロックから抜け出すことはありません。\n "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/page_2_1_1/",
	"title": "ステートメント",
	"tags": [],
	"description": "",
	"content": "ステートメントとは JavaScript はスクリプトを実行すると、原則上から順に1行ずつ処理が実行されていきます。\nこの処理の最小単位を ステートメント と呼びます。\nステートメントは単語の途中でない限り、改行を入れることができます。\n（あくまで、改行と入れることができるという話であり、コードの可読性が下がるようであれば無闇に改行を入れることはおすすめしません。）\nfunction myFunction() { console.log( \u0026#39;Hello GAS!\u0026#39; ); } また、ステートメントの最後にはセミコロン（;）をつけることがルールとなっていますが、\nセミコロンをつけなくても大抵のコードは実行されます。\nただし、稀にセミコロンをつけなかったためにエラーが発生するケースもあるため、\nステートメントの最後にはセミコロン（;）をつける ようにしましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "前提条件  GASの開発環境が整備されていること（Chapter1が完了していること）  目標のゴール  GASをコーディングをする上で必要となるJavaScriptの基礎が身につくこと  入門編でご説明した通り、GASのベースはJavaScriptです。\nJavaScript基礎編では、GASの開発で使用するJavaScriptの構文やオブジェクトについて解説いたします。\nJavaScriptの構文とオブジェクトを理解することで、GASの実装効率を大幅にあげることができます。\nそれではJavaScript基礎編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "前提条件  Google アカウントがあること Google Chrome をインストールしていること インターネットにつながるPCがあること  目標のゴール  Google Apps Script でコーディングをして、作成した関数を実行できること。  それでは入門編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/",
	"title": "入門編",
	"tags": [],
	"description": "",
	"content": "Chapter 1 入門編 Google Apps Script でコーディングしてみよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_1/",
	"title": "はじめに",
	"tags": [],
	"description": "",
	"content": "前提条件  Google アカウントがあること Google Apps Script である程度スプレッドシートを操作できること  目標のゴール  Google スプレッドシートをDBで代用したWebアプリケーションが作成できる  Webアプリケーションとは それではWebアプリ編のハンズオンをはじめましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_2/",
	"title": "ローカル開発とは",
	"tags": [],
	"description": "",
	"content": "スクリプトエディタの問題点 Google Apps Script は Google が提供しているスクリプトエディタでコーディングすることができます。\nGoogle Chrome があれば実装をすることができるのが Google Apps Script の強みではあるのですが、\nその反面 「好きなエディタで実装することができない！」 や 「Git で管理することができない！」 といった問題があります。\n他にもネット環境がなければコーディングを進められないなどの不便な点もあります。\nこれらの問題は Google サーバー上にソースがあることが原因となっているため、\n皆さんのPCの中（ローカル環境）で開発ができればこれらの問題を解消することができます。\nしかし、GASはスクリプトエディタ上でなければ実行することができないため、\nローカル環境でコーディングしたコードをスクリプトエディタに毎回コピー＆ペーストして実行する必要があります。\nこの手間を解消するツールとして Google は clasp というCLIツールを提供しています。\nclasp とは Google はこれらの問題を提供する clasp というツールを提供しています。\nこの clasp を利用すると Google Apps Script をローカルの好きなエディタで実装することができます。\nローカルに開発環境を整備しなければなりませんが、Google Apps Script でチーム開発をする場合は必須と言っても過言ではありません。\nこの clasp の具体的な使い方を本章で学んでいきましょう。\nなお、clasp は以下リンク先の Github で公開されています。\nhttps://github.com/google/clasp\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_2/",
	"title": "Spreadsheetサービス",
	"tags": [],
	"description": "",
	"content": "Spreadsheetサービスとは Spreadsheetサービス は、GASでスプレッドシートを操作するためのメソッドやスプレッドシートの情報をを提供するサービスです。\nSpreadsheetサービスの中でよく使うクラスを下記にまとめています。\n   クラス名 概要     SpreadsheetApp Spreadsheetサービスのグローバルオブジェクト   Spreadsheet スプレッドシートを操作する機能を提供する   Sheet シートを操作する機能を提供する   Range セルを操作する機能を提供する    Spreadsheetサービスの各クラスは、SpreadsheetApp → Spreadsheet → Sheet → Range という階層構造になっています。\n各クラスにはそのオブジェクトを操作するメンバーとともに、その配下のオブジェクトを取得するメンバーが用意されています。\nこれはスプレッドシートに限らず、他のサービスでもオブジェクトを操作する際の基本的な流れとなります。\nまた、GASのクラスに対して new 演算子でインスタンスを生成することはありません。\nGASのオブジェクト操作の基本動作は、グローバルオブジェクトから辿って目的のオブジェクトを取得し、操作をしていきます。\nスプレッドシートの場合は SpreadsheetApp がグローバルオブジェクトになります。\n SpreadsheetAppクラスとは SpreadsheetAppクラス はSpreadsheetサービスの最上位に位置するグローバルオブジェクトです。\nSpreadsheetサービスが提供する機能を利用するには、まずSpreadsheetAppクラスからアクセスすることになります。\nSpreadsheetAppクラスでは、直下のオブジェクトであるスプレッドシートを取得するメソッドや、\n現在アクティブになっているシートやセル範囲を取得するメソッドが用意されています。\nスプレッドシートを取得する スプレッドシートを操作するには、スプレッドシートを取得する必要があります。\nGASでスプレッドシートを取得する主な方法は下記の通りです。\n アクティブなスプレッドシートを取得する IDでスプレッドシートを特定して取得する URLでスプレッドシートを特定して取得する  アクティブなスプレッドシートとは、スクリプトにバインドされているスプレッドシートを指します。\nスプレッドシートのコンテナバインドスクリプトであれば、次の構文でスプレッドシートを取得することができます。\nSpreadhsheetApp.getActiveSpreadsheet()  getActiveSpreadsheetメソッドをはじめ、「アクティブ」なオブジェクトを取得するメソッドは、コンテナバインドスクリプトでのみ使用できます。\n そのため、バインドされていないスプレッドシートを取得する場合は、別の方法で取得する必要があります。\nその方法としては、IDで特定して取得するopenByIdメソッドと、URLで特定して取得するopenByUrlメソッドがあります。\nSpreaadsheetApp.openById(スプレッドシートのID); SpreadsheetApp.openByUrl(スプレッドシートのURL); スプレッドシートをはじめ Google Apps のファイルは一意のURLが定められています。\nブラウザではそのURLにアクセスすることで、そのファイルを開くことができます。\nGASでも同じように、そのURLがわかればスクリプトからスプレッドシートを特定して取得することができます。\nまた、IDも一意に定められており、このIDはURLの一部を構成しています。以下の{ID}の部分がIDです。\nhttps://docs.google.com/Spreadsheets/d/{ID}/edit#gid=0 このように、URLがわかればIDを取得することが可能です。\nでは、実際にスクリプトでスプレッドシートを取得してみましょう。\nまずは、新規のスプレッドシートを作成して「別のスプレッドシート」と名前をつけてください。\n先ほどの手順で作成した「別のスプレッドシート」のURLとIDを確認した上で、下記のサンプルを記述して実行してください。\nfunction spreadsheet_1() { var spreadsheet = SpreadsheetApp.getActiveSpreadsheet(); SpreaadsheetApp.openById(スプレッドシートのID) // はじめてのGAS  var url = \u0026#39;https://docs.google.com/Spreadsheets/d/XXXX/edit#gid=0\u0026#39;; spreadsheet = SpreadsheetApp.openByUrl(url); SpreaadsheetApp.openById(スプレッドシートのID); // バインドしていないスプレッドシート  var id = \u0026#39;XXXX\u0026#39;; spreadhsheet = SpreaadsheetApp.openById(id); // バインドしていないスプレッドシート } はじめてのGAS 別のスプレッドシート 別のスプレッドシート アクティブなシートを取得する GASでスプレッドシートを操作する場合、シートやセルを操作対象とすることが多いでしょう。\nその度に、SpreadsheetApp → Spreadsheet → Sheet と辿っていくのは手間に感じるかもしれません。\nまた、メソッド実行による Google Apps へのアクセスは実行時間が遅いという事実があります。\nGASには実行時間に関する制限がありますので、処理速度を落とさないためにも Google Apps へアクセスするメソッドの実行回数はできる限り減らしたほうがよいです。\nコンテナバインドスクリプトであれば、そのような場合にアクティブなシートを取得する方法として getActiveSheetメソッド を使用できます。\nSpreadsheetApp.getActiveSheet() SpreadsheetAppから直接取得できるので、次のサンプルのように簡潔に記述することができます。また、スプレッドシートへアクセスするメソッドの実行回数が減らすこともできます。\nfunction spreadsheet_2() { var sheet = SpreadsheetApp.getActiveSheet(); console.log(sheet.getName()); } シート1  Google Apps へのアクセスは事項時間が遅いので、できる限りアクセスするメソッドの実行回数は少なくなるようにしましょう。\n "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/object_mechanism/page_2_4_2/",
	"title": "インスタンス化",
	"tags": [],
	"description": "",
	"content": "インスタンス化 早速、次のサンプルをご確認ください。\npersonオブジェクトが定義されており、nameとageというプロパティと、greetというメソッドが用意されています。\nvar person = { name: \u0026#39;Taro\u0026#39;, age: 22, greet: function() { return \u0026#39;My name is Taro. I am 22 years old.\u0026#39; } }; function outputObj_3() { console.log(person.greet()); // My name is Taro. I am 22 years old. } このオブジェクト同じ構造で、5人分のオブジェクトを用意する必要が出てきた場合はどのようにコーディングすればいいでしょうか？\n全てのオブジェクトのプロパティとメソッドを漏れなく記述しようとすると、上記のサンプルのpersonクラスを5つ用意する必要があります。\nこのpersonクラスを5つも用意するとなると記述する量も多く、助長なスクリプトになってしまいます。\nまた、オブジェクトの構造やメソッドの内容を変更しなければならなくなった場合、\n全てのオブジェクトについて修正を加える必要があり、メンテナンス性にも問題があります。\nこの問題を解消する手段として、JavaScriptにはオブジェクトの「ひな型」をベースとして、\n同じプロパティやメソッドを持つ別のオブジェクトを生成する仕組みがあります。\nここで用語の定義として、それぞれ次のように呼びます。\n オブジェクトの特性を定義するひな型： クラス クラスを元にしてオブジェクトを生成すること： インスタンス化 インスタンス化により生成されたオブジェクト： インスタンス  オブジェクトをスクリプトの部品として捉えると、その再利用性や可読性が高まりますし、\n「ひな型」自体に変更を加えないので、オリジナルのオブジェクト構造についての安全性が高まります。\nコンストラクタとnew演算子によるインスタンス化 では、クラスを定義してインスタンス化をする方法について順を追ってみていきましょう。\nまず、既にクラスが定義されているとして、\nそのクラスをインスタンス化するには、以下のように new演算子 を使って記述します。\nvar 変数名 = new コンストラクタ名(引数１, 引数２, ...); コンストラクタというのは、クラスをインスタンス化する際に最初に呼び出される関数で、生成したオブジェクトの初期化処理をするという特別な役割を持ちます。\nそして、コンストラクトにより初期化されたオブジェクトが変数に代入されます。\nコンストラクトを定義するには一般の関数と同様で、次のように定義することができます。\nvar コンストラクタ名 = function(仮引数１, 仮引数２, ...) { // 処理 } コンストラクタ名は、通常の関数名と区別するために先頭を大文字で始めるのが一般的で、これがいわゆるクラス名として使用されます。\nまた、コンストラクタにはreturn文による戻り値は不要です。\nなぜかというと、new演算子によりコンストラクタを呼び出すことで自動的に初期化したオブジェクトが戻るようになるからです。\nクラスをインスタンス化するときには、new演算子を使ってインスタンスを初期化する関数であるコンストラクタを呼び出します。\n thisキーワード それでは、コンストラクタ内の処理は具体的にどのようなものでしょうか？\nオブジェクトの「ひな型」をインスタンス化したときに、インスタンスに渡すメンバーを定義する必要があります。\nその際に使用するのが thisキーワード です。\nthisキーワードは生成したインスタンス自体を表します。\nそのため、このthisキーワードを用いてインスタンスのメンバーを変更したり、その値を代入することができます。\nthisキーワードは次の書式でコンストラク内に記述します。\nthis.プロパティ名 = 値； this.メソッド名 = function(仮引数１, 仮引数２, ...) { // 処理  return 値; }  コンストラクタ内のthisキーワードは、これから生成されるインスタンス自体を表します。\n ここで、コンストラクタとインスタンス化の例として次のサンプルを確認してみましょう。\nnew演算子によって、Personコンストラクタにnameおよびageを引数として渡して、オブジェクトを生成するものです。\n実行後ログを確認すると、渡した引数がthisキーワードによって、それぞれのプロパティにセットされているのが確認できるでしょう。\nvar Person = function(name, age) { this.name = name; this.age = age; this.greet = function() { return \u0026#39;My name is \u0026#39; + this.name + \u0026#39;. I am \u0026#39; + this.age + \u0026#39;years old.\u0026#39; }; }; function outputObj_4() { var person = new Person(\u0026#39;Hanako\u0026#39;, \u0026#39;25\u0026#39;); console.log(person.greet()); } My name is Hanako. I am 25 years old. コンストラクタにメンバーを定義するのであれば、クラスとコンストラクタは同一のものと思われるかもしれません。\n実際にオブジェクトとしては同一のものを指しますが、厳密には下記のように使い分けられています。\n インスタンス化の際に最初に呼び出す関数を指す場合はコンストラクタ ひな型を指す場合はクラス  インスタンスのメンバーの変更 クラスから生成したインスタンスはオブジェクトのため、個別にメンバーの値の変更やメンバーの追加も可能です。\n次のサンプルを実行してみましょう。ageプロパティの値に5を加算して、jobs　プロパティを新たに追加しています。\nvar Person = function(name, age) { this.name = name; this.age = age; }; function outputObj_5() { var person = new Person(\u0026#39;Nobuo\u0026#39;, \u0026#39;20\u0026#39;); person.age += 5; person.jobs = \u0026#39;Engineer\u0026#39;; console.log(person); }  { jobs='Engineer', name='Nobuo', age=25 } "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/page_2_3_2/",
	"title": "引数と戻り値",
	"tags": [],
	"description": "",
	"content": "関数の引数と戻り値 関数を呼び出して処理を実行する際に値を受け渡すことができます。この呼び出した関数に渡す値を 引数 といいます。\nまた、呼び出し関数から処理も戻す際にも値を受け渡すことができます。この呼び出した関数から受け取る値を 戻り値 といいます。\n引数と戻り値を含めた関数の宣言は次のように記述することができます。\nfunction 関数名(仮引数１, 仮引数２, ...) { // 処理  return 戻り値; } 関数が呼び出されたときに受け取る値を格納する変数を 仮引数 といいます。仮引数は関数名の後ろの丸括弧内に指定します。\n仮引数の宣言にはvarは不要で、複数ある場合はカンマ区切りで記述します。\nまた、return文 によって戻り値を指定します。戻り値が不要の場合はreturn文を省略します。\nreturn文が実行されると、それ以降の処理は実行されないため気をつけましょう。\nreturn文が実行されると、戻り値と共に処理も戻ります。\n 一方で、引数を渡して関数を呼び出すには下記のように記述します。\n関数名(引数１, 引数２, ...) 戻り値を返す関数を呼び出した場合は、左辺に変数を指定することで代入をしたり、さらに引数として利用をしたりすることができます。\nでは、次のサンプルで確認をしてみましょう。\n面積を求めるcalcArea関数は引数として縦の長さx変数と横の長さy変数の値を受け取り、戻り値としてx * yの算出結果を返します。\nfunction myFunc_3() { var result = calcArea(10, 5); // 関数の結果を変数に格納することができます  console.log(result); console.log(caclArea(2, 15)); // 関数の結果を別の関数の引数に指定することもできます } function calcArea(x, y) { return x * y; } 50 30 関数と return 関数の値はキーワードの return を使って呼び出し側に戻します。\n関数から return で戻らない場合や値が指定されていない return で戻る場合、\n関数が返す値は undefined となります。\nfunction myFunc_4() { console.log(output_1()); console.log(output_2()); } function output_1() { return \u0026#39;Hello!\u0026#39;; } function output_2() { var hello = \u0026#39;Hello!\u0026#39;; } Hello! undefined 関数の引数 関数に情報を渡すには「引数（パラメーター）」と呼ばれるものを利用します。\n引数は「関数が呼び出されるまでは存在しない変数」であり、\n関数の呼び出しの際に（）のなかに値を設定することでその値を引数として利用することができます。\nfunction sum(a, b) { return a + b; } 上記のサンプルにおいて、aとbは「仮引数」と呼ばれており、\n関数が呼び出されると仮引数に呼び出し側から渡された値が代入されたのち関数本体が実行されます。\nconsole.log(sum(5, 10); 上記の例では仮引数のaには5、bには10が値として記憶されてから、関数本体が実行されます。\n仮引数には普通の変数と同じような役割をしますが、この関数の本体でしか値の参照や代入はできません。\n関数の外に同じ名前の変数があったとしても別の変数として扱われます。\n関数の引数の注意点 多くの言語では引数の個数が違う場合は異なる関数として扱われます。\n例えば、Javaではf(x)とf(x, y)とでは引数の数が異なるため別の関数として扱われます。\nJavaScriptではこのような区別がなく、引数なしであっても、引数がいくつあっても同じ関数として呼び出されます。\nそのため、どのような関数でも任意個数の引数を指定して呼び出すことができます。\n呼び出し側に引数を指定しない場合は暗黙のうちにundefinedが指定されて呼び出されます。\nfunction myFunc_5() { console.log(output_3()); } function output_3(x) { return \u0026#39;output_3内のxの値：\u0026#39; + x; } output_3内のxの値：undefined "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/page_2_2_2/",
	"title": "処理を繰り返し行う",
	"tags": [],
	"description": "",
	"content": "while文 唐突ですが、「1から10の数値を加算した結果を求めるスクリプトを書いてみましょう！」となったとき、どのようにコーディングしますか？\nここまで学習してきた皆さんであれば、下記のようにコーディングすることができると思います。\nvar num = 0; num += 1; num += 2; ~ num += 10; そして、コーディングの途中で「これ同じことを繰り返していない？」と気づくと思います。\n繰り返す処理の数だけ行数を増えていき、コーディングをするのも大変ですし、後々コードを修正するときも大変です。\n実際にプログラミングをしているとこのように同じ処理を繰り返す場面が多々あります。\n実は、JavaScriptには繰り返し処理を実現する構文を用意されています。\nそのうちの1つが while文 です。\nwhile文は条件式を用いた繰り返しを実現することができます。\nwhile (条件式) { // 条件式がtrueの間は実行される処理 } while文を使いますと、条件式の結果がtrueの間はブロック内の処理を繰り返し実行し、条件式がfalseになったときにループ処理から抜けます。\n下記のサンプルを実行して、while文の処理の流れを確認しましょう。\nfunction outputLoop() { var x = 1; var sum = 0; while(x \u0026lt;= 10) { sum += x; x++; } console.log(sum); } 55 無限ループ 繰り返し処理を行う際には 無限ループ に気をつける必要があります。\n下記のサンプルを実行すると無限ループが発生します。\nfunction outputLoop_2() { var x = 1; var sum = 0; while(x \u0026lt;= 10) { sum += x; } console.log(sum); } このサンプルを実行するとスクリプトエディタの上部に「関数outLoop_2を実行中\u0026hellip;」というメッセージが表示されたまま処理が完了しません。\nこのサンプルは変数xを初期化して1を代入していますが、while文の条件式がx \u0026lt;= 10となっているのにもかかわらず変数xが更新されずにずっと1のままのため、\nwhile文の中をグルグル回り続けてしまっています。\nこのように、while文の条件式がfalseとなることがなく、永遠に同じループが繰り返されてしまう状態を無限ループといいます。\nGASでは無限ループが発生した場合は「関数〇〇を実行中\u0026hellip;」に続く、キャンセルをクリックすることでスクリプトを停止させることができます。\n繰り返し処理をコーディングする際は、必ずループが終了するようになっているかを確認するようにしましょう。\nwhile文による繰り返しでは無限ループに気を付けましょう。\n for文 while文は条件式がtrueの間は処理を繰り返すという構文でしたが、処理を繰り返す回数があらかじめ決まっているのであれば for文 を使用しましょう。\nfor (①カウンタ変数の初期化; ②条件式; ④増減式) { // ③条件式がtrueの間は実行される処理 } for文では カウンタ変数 と呼ばれる変数を用います。\nfor文を使用すると決められた回数の繰り返し処理をとてもシンプルにコーディングすることができます。\nfor文の処理の流れは以下の通りです。\n①カウンタ変数の初期化\nカウンタ変数に値を代入して初期化します。\n②条件式\n条件式の結果を求めて判定を行います。この判定で true と判定された場合は {} の中の処理を実行します。\nfalse と判定された場合は {} の中の処理を実行せずにループ処理を抜けます。\n③条件式がtrueの間は実行される処理\nfor文の {} の中の処理を実行します。\n④増減式\n最後に計算式を実行し、カウント変数の増減を行います。\n計算後は②条件式に戻ります。\n次のサンプルを実行してfor文の処理の流れを確認しましょう。\nfunction outputLoop_3() { var sum = 0; for (var index = 1; index \u0026lt;= 10; index++) { sum += index; } console.log(sum); } 55 continue文 いまのループを中断して次のループに進みたい（要約するとスキップしたい）場合はcontinue文を活用します。\ncontinue文が実行されると、そのループは中断され増減式が実行されます。\n次のサンプルではカウンタ変数のindex変数が２の倍数の場合は、continue文以降の処理をスキップしています。\nfunction outputLoop_4() { for (var index = 0; index \u0026lt;= 10; index++) { if (index % 2 === 0) { // index が２の倍数の場合はスキップする  continue; } console.log(index); } } 1.0 3.0 5.0 7.0 9.0 繰り返し処理と配列 これまでは配列の要素を取得しようとすると下記のようにコーディングする必要がありました。\nfunction outputLoop_5() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;]; console.log(fruits[0]); console.log(fruits[1]); console.log(fruits[2]); } apple banana orange 上記の例では取り出す要素が3つだけのため問題ありませんが、\nこの要素の数が10、100と増えていくとそれに比例してコーディング量が増えてしまいます。\nそのような時に繰り返し処理を活用するとコーディング量を減らすことができます。\nfunction outputLoop_6() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;]; for (var index = 0; index \u0026lt; fruits.length; index++) { console.log(fruits[index]); } } apple banana orange 先ほどの例は配列の要素を取得しましたが、多次元配列から要素を取得するときも活躍します。\n以下のサンプルでは繰り返し処理を活用して２次元配列の要素を取得しています。\nfunction outputLoop_7() { var foods = [[\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;], [\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;]]; for (var i = 0; i \u0026lt; foods.length; i++) { console.log(foods[i]); } } ['apple', 'banana', 'orange'] ['beef', 'pork', 'chicken'] ２次元配列から配列（要素）を取得することができましたが、さらにその配列の要素を取得したい場合もあります。\nその場合は繰り返し処理の中でさらに繰り返し処理を行う２重ループを行うことで実現できます。\n1回目のループ（カウント変数がi変数のループ）では配列（要素）を取得して、\n2回目のループ（カウント変数がj変数のループ）で要素を取得しています。\nfunction outputLoop_8() { var foods = [[\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;orange\u0026#39;], [\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;]]; for (var i = 0; i \u0026lt; foods.length; i++) { for (var j = 0; j \u0026lt; foods[i].length) { console.log(foods[i][j]); } } } apple banana orange beef pork chicken "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/page_2_1_2/",
	"title": "関数",
	"tags": [],
	"description": "",
	"content": "関数とは 入門編で少し解説しましたが、関数 とは一連の処理をひとまとめにして名前をつけたものです。\n「関数（function）」　は文が集まったもので、プログラムを構成する部品の役割をする「サブプログラム」です。\nJavaScriptでは関数はとても重要な役割を果たしますが、本章ではその基本的な機能と使い方を紹介します。\n関数の構文 関数を実行する際は関数名を指定して呼び出すことにより、関数を実行することができます。\n関数を作り方にはルールがあり、以下のように function キーワード で定義します。\nfunction 関数名() { 処理 } ここまではデフォルトの「myFunction」という名前の関数を実行してきましたが、関数名は任意でつけることができます。\n関数名はその関数がどのような処理を行うかがイメージしやすい名前をつけるようにしましょう。\n例えば、「ユーザー名を取得する関数」であれば、「getUserName」とするとわかりやすいですよね。\nまた、波括弧（\u0008{}）で囲った箇所は、複数のステートメントをまとめたもので ブロック といいます。\nこのブロックは今後の説明する構文で重要な役割を果たします。\nブロックは改行しないで記述することはできますが、改行を入れたほうが読みやすいコードになります。\n下記の例で見比べると一目瞭然ですね。\nfunction myFunction() {console.log(\u0026#39;Hello GAS\u0026#39;);} function myFunction() { console.log(\u0026#39;Hello GAS\u0026#39;); } それでは、次のサンプルをコーディングして保存してみましょう。\nfunction sayHello() { console.log(\u0026#39;Hello!\u0026#39;); } すると、スクリプトエディタのツールバーの「関数選択」のプルダウンに「sayHello」が選択可能となっていることが確認できます。\nその関数を選択してスクリプトを実行してそのログ表示を確認してみましょう。\n「sayHello」を実行すると、「Hello!」と表示されます。\nこのように、gsファイルには複数の関数を定義することができます。そして、定義した関数を「関数選択」のプルダウンから選択して実行することができます。\nコーディングする際の注意点 JavaScriptでコーディングする際は基本的に半角英数字と半角記号のみを使用します。\n逆にいうと、全角文字は使用することができません。（後述の文字列やコメントでは使用できます。）\nまた、JavaScriptは同じアルファベットでも大文字と小文字を区別します。\nそのため、下記のようなコードを記述するとスクリプトの実行時にエラーが発生します。\nfunction myFunction() { console.Log(\u0026#39;Hello GAS!\u0026#39;) } 実行すると、「TypeError：オブジェクトconsoleで関数Logが見つかりません。」というエラーが発生します。\nこのようにタイプミスで大文字と小文字を間違えたりするとエラーとなってしまいます。\nちなみに、スクリプトエディタには自動補完機能があるので、この機能を駆使することでタイプミスを防ぐことができます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/",
	"title": "基本構文を学ぼう",
	"tags": [],
	"description": "",
	"content": "Chapter 2 - 2 JavaScriptの基本構文 JavaScriptの基本となる構文を学びましょう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/",
	"title": "JavaScript基礎編",
	"tags": [],
	"description": "",
	"content": "Chapter 2 JavaScript基礎編 JavaScriptの基礎を身につけよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_2/",
	"title": "Google Apps Script とは",
	"tags": [],
	"description": "",
	"content": "Google Apps Script とは Google Apps Scriptは、Google が提供するローコードプラットフォームです。\n厳密には違うのですが、プログラミング言語といっても差し支えないと思います。\n（以降、Google Apps Script を GAS と呼称します。）\nGAS を使うことで、Gmail や Googleカレンダー、Google スプレッドシートなどの\nGoogle が提供するアプリケーションをプログラミングによって操作することができるようになります。\n各アプリケーション単体の動作はもちろん、アプリケーション同士の連携させて動作させることもできます。\nまた、HTMLやCSS、JavaScriptでWebアプリケーションを作成し、公開することもできます。\n一方で、GAS独自のルールがあるため、そのルールを把握した上でコーディングをする必要があります。\nこの入門編ではGASを学ぶ上で土台となる基礎知識を身につけていきます。\nGASのベースはJavaScript！ GASはJavaScriptというプログラミング言語がベースになっています。\nJavaScriptはブラウザ上で動作する標準のスクリプト言語として使われており、\nさらにサーバーの処理を行う言語としても活用されています。\nスクリプト言語は簡易にコーディングと実行ができることが特徴です。\nそのため、プログラミングが初めてという方でも比較的容易に習得することできます！\nGASはクラウド上で動く！ GASの特徴は、コーディングをする場所もプログラムが実行される場所も全てGoogleのクラウドサーバー上にあります。\n例えば、Excel VBA の場合はコーディングやプログラムの実行をPC内で行われます。\n一方、GASはブラウザ上でコーディングを行い、プログラムの実行はクラウドサーバー上で行われます。\nGASの最大の利点は 開発環境の整備が不要 であることです。\nスクリプトが実行されるサーバーも、コーディングを行うエディタもすべてGoogleが用意してくれています。\nまた、スクリプトはGoogleのクラウドサーバー上で動作するため、PCやブラウザが起動していなくてもスクリプトを実行することができます。\nトリガー という機能を使うことで、時間を指定して特定の時間にスクリプトを実行させることができます。\n開発に必要なもの GASで開発をするのに必要なものは下記の３つだけです。\n Google アカウント（G Suite でも無料のGoogleアカウントでもどちらでもOKです。） ブラウザ（Google Chrome を推奨） インターネットに接続できるPC（WindowsOSでもMacOSでもどちらでもOKです。）  他のプログラミング言語と比べても敷居はとても低く、\nGASの門戸は常に開かれています。\n Google Apps とは Google Apps はGoogle が提供しているアプリケーションを意味していますが、GASはGoogleが提供しているすべてのアプリケーションを操作できるわけではありません。\nどのアプリケーションを操作できるかは、後述の「リファレンスについて」で確認していきましょう。\n Google アカウントについて 皆さんはGoogleアカウントを無料で作成してサービスを利用することができます。\nその一方で、これらのサービスを企業や組織向けに提供されている有償版のサービスもあります。\nこれは G Suite と呼ばれており、企業や組織向けのサービスを利用することができます。\nG Suite のプランにはBasic/Bussinessというプランが用意されています。\n無料アカウントと G Suite の各プランの違いは下記の通りとなっております。\n   項目 無料アカウント G Suite for Basic G Suite for Bussiness     料金 無料 680円/月額 1,360円/月額   メールアドレス ドメイン名はgmail.comのみ 独自ドメインを設定できる 独自ドメインを設定できる   サポート なし 24時間365日サポート 24時間365日サポート   管理コンソール なし ユーザー管理、端末管理、セキュリティ設定が可能 ユーザー管理、より高度な端末管理とセキュリティ設定が可能   クラウドストレージ容量 15GB 30GB 無制限    無料のアカウントでも、GASの基本的な機能を利用することは可能です。\nしかし、GASの実行の際に一部制限があり、G Suite の方がその制限が緩くなっています。\nその一例は下記の通りです。\n公式ガイド\n   項目 無料アカウント G Suite for Basic G Suite for Bussiness     スクリプト実行時間 6分/実行 6分/実行 30分/実行   カスタム関数実行時間 30秒/実行 30秒/実行 30秒/実行   トリガーの総実行時間 90分/日 3時間/日 6時間/日     GASで操作できるアプリケーションについて GASで多くのアプリケーションを操作することができますが、\nこの機能は「サービス」と呼ばれており、このサービスは３つのグループに分けられています。\n   グループ 概要 提供されるサービス例 サービスの利用方法     G Suite Services G Suite に含まれるアプリケーションを操作するサービス群 Gmail、Calendar、スプレッドシートなど デフォルトで利用可能   Script Services ユーティリティサービス群 Cache、HTML、JDBCなど デフォルトで利用可能   Advanced Google Services G Suite Services よりも高度な操作を行うことができるサービス群 BigQuery、AdminSDKなど デフォルトで利用可能    G Suite Services 主に G Suite で提供されている各アプリケーションを操作するサービスが提供されています。\nG Suite のすべてのサービスを操作できるわけではないのですが、\nこれらのサービスを操作することで業務効率化を図ることができるアプリケーションやツールを作ることができます。\n Calendar：カレンダー Contacts：連絡先 Document：ドキュメント Drive：ドライブ Forms：フォーム Gmail Groups：グループ Language：翻訳 Maps：マップ Slides：スライド Spreadsheet：スプレッドシート  Script Services Script Servicesでは、GAS 全般で横断的に利用するユーティリティとして機能するサービスが提供されています。\n例えば、ログを出力したり、ダイアログを表示したりなど便利な機能が揃っています。\n Base Cache Charts Content HTML JDBC Lock Script Url Fetch  Advanced Google Services GASには G Suite Service に含まれないアプリケーションや、より高度な操作を可能にするサービスが提供されています。\nこれらは 拡張サービス（Advanced Google Services）と呼ばれていて、\nG Suite Serviceでは操作ができないBigQueryやAdminSDKが操作することができ、\nG Suite Serviceで用意されている GmailやDriveなどのアプリケーションに対してより高度な処理を行うことができます。\nデフォルトでは無効になっているため、利用したいサービスごとに有効にする必要があります。\n GASを学ぶ上で気をつけること GAS = JavaScriptではない 先述した通り、GASのベースはJavaScriptではあるものの、JavaScriptのすべての機能を利用できるわけではありません。\nGASで利用できる JavaScript は、基本構文、制御構文、演算子、関数、組み込みオブジェクトなどの基本部分であるECMAScript（エクマスクリプト）のみです。\nまた、ECMAScriptは高頻度でバージョンアップを繰り返しているのですが、\nその更新にGASは対応しきれていないため、ECMAScriptであっても記述できない構文などもあります。\nまた、JavaScriptを大きく分けると画面の操作を行う フロントエンド と 外部サービスへの連携やデータベースの処理などを行う サーバーサイド に分けられます。\nGASはサーバーサイドに分類するため、フロントエンドのJavaScriptの機能を利用することができません。\n例えば、下記のような画面にアラートを表示するという初歩的なコードすら実行することができません。\nalert(\u0026#39;Hello World!\u0026#39;) GASの実行には制限がある 先述した通り、GASはGoogleのサーバー上で動作するため、仮にあるユーザーが極端にサーバーに負荷がかかる処理を行うと、GAS全体に影響を及ぼす恐れがあります。\nこのような状況を避けるためにGASにはいくつかの機能に対して制限が設けられています。\n詳細は下記リンク先の公式ガイドをご参照ください。\n公式ガイド\n特に気をつけるべきは スクリプトの実行時間 で、無料アカウントや G Suite for Basic の場合は6分、\nG Suite for Bussiness の場合は30分で処理が強制終了してしまいます。\nそのため、GASで開発を行う際は扱うデータ量と処理速度に注意をする必要があります。\n リファレンスについて 具体的にGASがどのようなサービスを提供しているかは下記リンク先のリファレンスで確認することができます。\nどのサービスを利用すればよいか迷ったときは、このリファレンスを参考に吟味するようにしましょう。\n公式リファレンス\nまた、Google社はGASを不定期にアップデートしているため、GASで開発する際は利用するサービスを必ずリファレンスで確認するようにしましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_2/",
	"title": "Web画面を表示してみよう",
	"tags": [],
	"description": "",
	"content": "まずは Google Apps Script でアプリケーションを作成する第一歩として、\nブラウザにWeb画面を表示してみましょう。\nスクリプトの種類 Google Apps Script には2種類のスクリプトがあります。\n Container Bound Script Standalone Script  それぞれのスクリプトの違いについて確認していきましょう。\nContainer Bound Script Google スプレッドシートやドキュメントなどの各アプリケーションのメニューから作成することができるスクリプトです。\n＜スクリプトを作成する手順＞\n Google スプレッドシートやドキュメントなどのアプリケーションを開きます。 上部メニューの|[ツール] \u0026gt; [スクリプトエディタ]を選択します。  ＜メリット＞\n バインドしているファイルを簡単に参照できる バインドしているファイルから Google Apps Script を実行できる  この方法で作成されたスクリプトと同アプリケーションはバインド（結びつく）しているため、\nスプレッドシートの場合は下記のメソッドによりブラウザで開いている同スプレッドシートを操作することができます。\nvar spreadsheet = SpreadsheetApp.getActiveSpreadsheet(); var sheet = spreadsheet.getActiveSheet(); var range = sheet.getActiveRange(); また、onOpen関数を利用してアプリケーションにメニューを追加し、\nそのメニューからスクリプトエディタでコーディングした関数を実行することができます。\n他にも、図形にコーディングした関数を埋め込み、図形をクリック時に埋め込めんだ関数を事項することもできます。\n要約しますと、この方法で作成したスクリプトはExcelでいうVBAに近い感覚で利用することができます。\nStandalone Script Container Bound Script とは対照的に、どのアプリケーションにもバインド（結びつく）していないスクリプトです。\n作成されたスクリプトは Googleドライブ に表示されます。\n＜スクリプトを作成する手順＞\n Google Chrome で Google ドライブを開きます。 Google ドライブの左上に表示されている[新規]ボタンをクリックします。  で表示されたメニュー内の[その他]をクリックします。    で表示されたメニュー内の[Google Apps Script] をクリックします。    ＜メリット＞\n 利用者にスクリプトエディタを編集されるリスクがない Google ドライブで管理がしやすい  一見、Container Bound Script でスクリプトを作成した方が始めやすく、\nバインドしたファイルを簡単に参照できるメソッドも利用できるため扱いやすいです。\nしかし、作成したスクリプトを他者と共有して利用したい場合は、\n利用者もスクリプトエディタを編集することができてしまいます。\nつまり、いつの間にか利用者によってスクリプトの内容が書き換えられてしまうことが起こる可能性があります。\n一方で、Standalone Script はスクリプトファイルを共有したアカウントのみ編集することが、ユーザーによって編集されるリスクがありません。\nまた、作成したスクリプトは Google ドライブに保存されているため管理がしやすいのも特徴です。\n（Container Bound Script の場合は対象のファイルを開かなければスクリプトエディタを開くことができません。また、Google ドライブにスクリプトが表示されません。）\n補足\nGoogle ドライブでは Container Bound Script を管理できないとお話ししましたが、\n作成したスクリプトは下記リンク先のダッシュボードから簡単にアクセスすることができます。\nhttps://script.google.com/home\n今回のWebアプリ編のハンズオンでは Standalone Script で進めていきます。\nContainer Bound Script でも問題なく行うことができますが、\n後々の管理のことを考えて Standalone Script で進めていきましょう。\n HTMLファイルの作り方について Webアプリを作るには画面を作る必要がありますが、画面はHTMLファイルで作ることができます。\nHTMLファイルは下記の手順で作成することができます。\n 上部メニューから[ファイル] \u0026gt; [New] \u0026gt; [HTMLファイル]　を選択する。 表示されたダイアログの入力欄にファイル名を設定して、[OK] ボタンをクリックします。\n※ ここではファイル名を「index」としてください。 スクリプトエディタ上に「index.html」が作成されます。  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026quot;_top\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  doGet関数について ユーザーが公開したWebアプリにアクセスした場合にdoGet関数は実行されます。（別のプログラムからWebアプリにHTTPのGETリクエストが送信される場合も同じく実行されます。）\nWeb画面を表示するにはdoGet関数の戻り値として HtmlServiceオブジェクト を指定する必要があります。\n下記のようにコーディングをしますと、index.htmlを表示する画面として指定することができます。\nコード.gs\nfunction doGet() { return HtmlService.createTemplateFromFile(\u0026#39;index\u0026#39;).evaluate(); } index.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026quot;_top\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; Hello World! \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Webアプリのデプロイ方法について 作成したWebアプリは次の手順で公開することができます。\n メニューの「公開」\u0026gt; 「ウェブアプリケーションとして導入」をクリック プロジェクトバージョンを指定して「導入」ボタンをクリック  "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_3/",
	"title": "clasp を使う前に",
	"tags": [],
	"description": "",
	"content": "前準備 1. Google Apps Script API を有効化しましょう 実は clasp をインストールしても、Google アカウントの設定で Google Apps Script APIを有効にしなければ clasp を利用することはできません。\n下記リンク先から Google Apps Script を有効化することができます。\nhttps://script.google.com/home/usersettings\n設定画面の「Google Apps Script API 」の下に「オフ」と表示されていると、\nGoogle Apps Script API が無効化の状態になっています。\n「Google Apps Script API 」をクリックしますと、「オン」「オフ」を切り替える画面に遷移します。\n遷移先の画面で右端にトグルボタン表示されていますので、\nこちらをクリックして左端の文字が「オフ」から「オン」に変われば設定完了です。\n2. エディタをインストールしましょう お気に入りのエディタをインストールしましょう。\n基本的に好きなエディタを使っていただいたも問題ありませんが、\n以降は VSCode でコーディングをしている前提で進めていくため、\n特にこだわりがなければ VSCode をインストールしてください。\nhttps://azure.microsoft.com/ja-jp/products/visual-studio-code/\n3. Node.js をインストールしましょう clasp を利用するにはPCに Node.js と呼ばれるJavaScriptの実行環境をインストールする必要があります。\n以下リンク先から Node.js をインストールしてください。\nhttps://nodejs.org/ja/\nインストールを完了しましたら、以下のコマンドを実行して Node.js と npm がインストールされているかを確認しましょう。\nnpm は　Node.js　のパッケージを管理しており、そのパッケージの中に clasp があります。\n-vでインストールされているバージョンを確認することができます。\n以下のバージョンよりも新しければ問題ありません。\nnode -v v12.14.1 npm -v 6.13.4 4. clasp をインストールしましょう Node.js と npm がインストールされましたら、以下のnpmコマンドで clasp をインストールしましょう。\nnpm install @google/clasp -g これで前準備は完了です！\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_3/",
	"title": "スプレッドシートを操作する",
	"tags": [],
	"description": "",
	"content": "Spreadsheetクラスとは Spreadsheetクラス は、文字通りスプレッドシートを操作する機能を提供するクラスです。\nシートを取得したり作成したりするメソッドやスプレッドシートの情報など（メンバー）が提供されています。\nでは早速、Spreadsheetクラスのメンバーを使って、スプレッドシートの様々な情報を取得してみましょう。\n次のサンプルはスプレッドシートのID、スプレッドシート名、URLがログに出力されます。\nfunction spreadsheet_3() { var spreadsheet = SpreadsheetApp.getActiveSpreadsheet(); console.log(spreadsheet.getId()); // スプレッドシートのID  console.log(spreadsheet.getName()); // スプレッドシートの名前  console.log(spreadsheet.getURL()); // スプレッドシートのURL } シートを取得する Spreadsheetクラスはその配下であるシートを取得することができます。\nシートの取得方法は次のような方法があります。\n アクティブなシートを取得する シート名で特定して取得する インデックスで配列からシートを特定して取得する  アクティブなシートは先ほど説明した通りコンテナバインドスクリプトに限り、SpreadsheetAppクラスから直接取得することができます。\n別な方法として、getSheetByNameメソッド を使用してシート名で特定して取得する方法があります。\nシート名で取得するのは簡単ではありますが、シート名が変わると取得できなくなる点に注意です。\nSpreadsheetオブジェクト.getSheetByName(シート名) 他にも、getSheetsメソッド でシートを配列として取得した上で、インデックスでシートを特定する方法もあります。\nSpreadsheetオブジェクト.getSheets() getSheetsメソッドは、スプレッドシートに含まれるシートのうち最も左に位置するシートのインデックスを0として、\nそこから右方向に順番にシートを配列に格納して取得します。\n戻り値が配列になりますので、全てのシートに処理を行いたい場合などに便利です。\nしかし、インデックスは並び順に依存しているため、\n特定のシートのみ処理をしたい（例えば左から2つめのシートのみ処理したい）場合はシートの並び順が変更された場合は意図したシートが処理されないことになります。\nそれでは、次のサンプルを実行して確認してみましょう。\nfunction spreadsheet_4() { var spreadsheet = SpreadsheetApp.getActiveSpreadsheet(); var sheet = spreadsheet.getSheetByName(\u0026#39;シート1\u0026#39;); conosole.log(sheet.getName()); var sheets = spreadsheetApp.getSheets(); console.log(sheet[0].getName()); console.log(sheet[1].getName()); } getNameメソッド はシート名を取得するメソッドです。getSheetsメソッドはシートを配列として取得するため、角括弧内にインデックスを用いて各シートを取り出すことができます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/",
	"title": "スプレッドシート編",
	"tags": [],
	"description": "",
	"content": "Chapter 3 スプレッドシート編 GASでスプレッドシートを操作してみよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/object_mechanism/page_2_4_3/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "ここまでオブジェクトの仕組みについてお伝えしてきました。\n本チャプターでお伝えした内容は、今後GASでの開発において独自のクラスを用意する際の基礎となるのはもちろん、\n以降でお伝えするGASで提供されているクラスについての習得スピードと理解度が増すものとなると思います。\nさあ、いよいよGASで開発する準備ができました。\n次のチャプターからスプレッドシートでGASで操作してみたいと思います。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/page_2_3_3/",
	"title": "スコープ",
	"tags": [],
	"description": "",
	"content": "グローバル領域 早速ですが、下記のサンプルを実行してみましょう。\n実行する関数内にはステートメントは１行もありませんが、実行するとどうなるでしょうか？\nvar msgHello = \u0026#39;Hello!\u0026#39; console.log(msgHello); function outputScope_1() { } Hello! 関数を実行すると、ログに「Hello!」と表示されたと思います。\n関数の外に記述した2つのステートメント、msg変数の初期化とログ出力が実行されました。\nGASにはどの関数に属さない領域にステートメントを記述することができ、この領域を グローバル領域 といいます。\nプロジェクトに含まれるいずれかの関数が呼び出されると、呼び出された関数よりも先に、グローバル領域に記述されたステートメントが実行されます。\n次のサンプルを実行すると、まずグローバル領域に記述されたステートメントが上から順番に実行されていきます。\nその後、呼び出された関数内のステートメントが実行されることが確認できるでしょう。\nconsole.log(\u0026#39;Good Morning!\u0026#39;); function outputScope_2() { console.log(\u0026#39;Hello!\u0026#39;); } console.log(\u0026#39;Good Night!\u0026#39;); Good Morning! Hello! Good Night!  異なるgsファイルに記述されていたとしても、プロジェクト内の任意の関数の呼び出しにより、グローバル領域に記述される全てのステートメントが実行されます。\n複数のgsファイルのグルーバル領域にステートメントを点在させることは、わかりやすさの観点からおすすめできません。\n グローバルスコープとローカルスコープ 変数にはその変数を参照することができる範囲が定められています。\nこれを スコープ といいます。スコープには次の２種類があります。\n グローバルスコープ：プロジェクト全体から参照できる ローカルスコープ：宣言された関数の中からのみ参照できる  関数の中で宣言された変数のスコープは ローカルスコープ といい、その関数の中でのみ参照することができます。\nこのような変数を ローカル変数 といいます。\n一方、グローバル領域で宣言された変数はプロジェクトのどこからでも参照することができ、\nそのスコープは グローバルスコープ、またその変数を グローバル変数 といいます。\nそれでは、それぞれのスコープについてサンプルで確認していきましょう。\n次のサンプルはローカル変数のスコープを確認するサンプルです。\nlocalFunction_2関数を実行すると「localFunction_2が定義されていません」というエラーが発生します。\nこのようにローカル変数は外からはアクセスすることができないのです。\nfunction localFunction_1() { var localMsg = \u0026#39;ローカル\u0026#39;; } function localFunction_2() { console.log(localMsg); } 続いて、グローバル変数のスコープを確認するために、次のサンプルを実行してみましょう。\nvar globalMsg = \u0026#39;グローバル\u0026#39;; function globalFunction_1() { console.log(globalMsg); } グローバル このようにグローバル変数は全ての関数からアクセスすることができます。\nそれでは、次のサンプルの場合はどうなるでしょうか？\nmsg変数がグローバル領域でも、関数の中でも宣言されています。\nこのような場合にglobalFunction_2を実行するとローカル変数のmsgが表示されます。\nvar msg = \u0026#39;グローバル\u0026#39;; function globalFunction_2() { var msg = \u0026#39;ローカル\u0026#39;; console.log(msg); } ローカル "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/page_2_2_3/",
	"title": "例外処理でエラーを検知する",
	"tags": [],
	"description": "",
	"content": "例外処理とは GASではスクリプトを実行すると、想定しないエラーが発生することがあります。\n次のサンプルを実行するとエラーが発生して、スクリプトはその時点で止まってしまいます。\nこのように発生するエラーを例外といいます。\nfunction outputException_1() { Browser.MsgBox(\u0026#39;Hello\u0026#39;); } TypeError: オブジェクト Browser で関数 MsgBox が見つかりません。 今回のサンプルは呼び出しているメソッド名に誤字があるため起こるべくしてエラーが起きていますが、\nユーザーの操作やGASの制限などエラーが発生する要因というのは多岐にわたります。\nこの全てを想定して処理が落ちないように完全に防ぐのは非常に難しいのですが、例外が発生したときにスクリプトが停止しないようにする 例外処理 が活躍します。\n例外処理を使用すると、例外の発生を検知して、発生したエラーに応じて処理を継続したり、処理を分岐したりすることができます。\nJavaScriptで例外処理を行う場合はtry catch finally文を使用し、下記のように記述します。\ntry { // 例外を検知する対象となる処理 } catch (変数) { // 例外が発生した際に実行する処理 } finally { // 例外の起きても起きなくても実行される処理 } 例外が起こりうる（検知したい）処理をtryブロックに記述します。\ntryブロック内で例外が発生した場合には、その時点で処理を中断してcatchブロックに処理が移ります。\nfinallyブロックは例外が起きても起きなくても実行される処理で、不要であれば省略することができます。\n先ほどのサンプルに例外処理を追加したのが次のサンプルになります。\nfunction outputException_2() { try { Browser.MsgBox(\u0026#39;Hello\u0026#39;); } catch(e) { console.log(\u0026#39;例外が発生しました。: \u0026#39; + e.message); } finally { console.log(\u0026#39;スクリプトが完了しました！\u0026#39;); } } 例外が発生しました。: スクリプトが完了しました！ 実行すると例外が発生するのですが、処理は止まらずにcatchブロック内の処理が実行され、その後finallyブロック内の処理が実行されます。\nサンプルコードで登場した変数eには、例外が発生したときに生成されるErrorオブジェクトが格納されています。\nErrorオブジェクトのmessageプロパティにはエラーメッセージが格納されているため、e.messageでエラーメッセージを取り出して表示しています。\n throw文 発生した例外を受動的に検知して利用するだけではなく、throw文 を使用することでスクリプト内で能動的に例外を発生させることができます。\nこのように例外を能動的に発生させることを「例外をスローする」といいます。\nthrow new Error(\u0026#39;エラーメッセージ\u0026#39;); 次のサンプルを実行してみましょう。\n実行すると例外が発生し、エラーメッセージに「xに負の数が代入されました。」が表示されます。\nfunction outputException_3() { var x = -1; if (x \u0026lt; 0) { throw new Error(\u0026#39;xに負の数が代入されました。\u0026#39;); } } throw文とtry catch文を組み合わせたのが次のサンプルです。\n変数xの値が負の数である場合に例外をスローして処理を分岐しています。\nfunction outputException_4() { var x = -1; try { if (x \u0026lt; 0) { throw new Error(\u0026#39;xに負の数が代入されました。\u0026#39;); } } catch(e) { console.log(\u0026#39;例外が発生しました。: \u0026#39; + e.message); } } 例外が発生しました。: xに負の数が代入されました。 制御フローの例外 ここまで登場した制御フローの通常の処理を変えることができる文を整理してみましょう。\nbreak文：ループを途中で抜ける。\ncontinue文：ループ内の今回分の繰り返し処理を終了して、次回分の繰り返し処理に進む。\nreturn文：現在の関数を終了する。（次章で解説します）\nthrow文：例外ハンドラでキャッチする必要がある例外を示す。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/",
	"title": "制御構文を学ぼう",
	"tags": [],
	"description": "",
	"content": "Chapter 2 - 3 JavaScriptの制御構文 JavaScriptの制御構文を学びましょう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/page_2_1_3/",
	"title": "コメント",
	"tags": [],
	"description": "",
	"content": "コメントとは コメント とは、スクリプト内のメモ書きのことをいいます。\nこのコメントはスクリプトの実行時には無視されるため、実行されることはありません。\nでは、どのようなときにこのコメントを使うのでしょうか？\n例えばですが、しばらく期間をあけてコードを読み返した際に、自身がどのような考えで実装したのか思い出すのは大変です。\nそのようなときにコメントが書かれているとこのような苦労をせずに済みます。\n同様に、自身ではなく他の人にソースを読んでもらうことがあった場合も、\n自身がどのような考えで実装したのかを伝えることができます。\nこのように、コメントを活用することで、\nプログラムを作った人自身、もしくはあとで読む人（将来の自分を含む）がわかるように説明を書き残すことができます。\nなお、JavaScriptのコメントは２種類あります。\nそれぞれのコメントを使い方について解説していきます。\nインラインコメント 「//」で始まる記述はその行の終わりまでコメントとして扱われます。\n1行のみコメントにしたい場合は、その文頭に「//」を入れることでコメントにすることができます。\nfunction myFunction() { // 実行されないので半角英数字や半角記号以外の文字を入れることができます。  console.log(\u0026#39;Hello GAS!\u0026#39;); // 行の後ろにも入れることができます。 } ブロックコメント 「/* 」で始まる文字列は「*/」までの記述をコメントとして扱います。\nこれにより、複数行にわたるコメントを書くことができます。\nfunction muFunction() { /* 1行目 2行目 */ console.log(\u0026#39;Hello GAS!\u0026#39;); } コメントの活用方法 コーディングをしていて、「このステートメントは今は実行したくないな」というときにもコメントは活躍します。\n実行したくないステートメントをコメントにすることで実行されないようにすることができます。\nこのように一時的にコメントにすることを「コメントアウト」といいます。\n// 2回目のconsole.log()は実行したくない場合 function myFunction() { console.log(\u0026#39;Hello GAS!\u0026#39;); // 2回目のconsole.log()をコメントアウト  // console.log(\u0026#39;Hello GAS!\u0026#39;); }  コメントアウトはショートカットキーがあり、コメントアウトしたい行を選択した上で、\nWindonwsはCtrl + /、Macはcontrol + /でコメントアウトをすることができます。\n逆にコメントを解除したい場合も同じ手順で行うことができます。\n CSSのコメントはJavaScriptのブロックコメントと同じ形式で、インラインコメントは使うことができません。\nHTMLもコメントはインラインコメントはなく、ブロックコメントがありますが、JavaScriptとは違い \u0026lt;!-- と　--\u0026gt; で囲まれます。\n "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_3/",
	"title": "前準備をしよう",
	"tags": [],
	"description": "",
	"content": "まずは開発環境を整えましょう。\nとは言っても、GASはローコードプラットフォームであるためほとんど手間がかかりません。\nGoogleアカウントでログイン まずはGoogle アカウントでログインをしましょう。\nGoogle アカウントは一つですが、ログインするところは2つあります。\n Google Chrome にログイン Google のサービス（G Suite）にログイン  実は「Google のサービス（G Suite）にログイン」のみでGASは利用できるのですが、\nGoogle Chrome へログインしているアカウント と　Google のサービス（G Suite）にログインしているアカウント が不一致の場合、\n意図しない挙動を起こすことがあります。\n必ず Google Chrome へログインしているアカウント と Google のサービス（G Suite）にログインしているアカウント が一致していることを確認した上でこの先の手順を進めていきましょう。\n  Google Chrome を起動します。\n  Google Chrome にログインします。\n  Google Chrome のURLバーに「google.com」と入力してEnterキーを押します。\n  Googleホーム画面の右上にある「ログイン」ボタンをクリックします。\n  Google Chrome にログインします。\n   スプレッドシートを開く 今回のハンズオンではスプレッドシートからスクリプトエディタを開いてみましょう。\n  Google ドライブを起動します。\n  Google ドライブの画面の左上にある「新規」ボタンをクリックします。\n  表示されたメニュー内から「Google スプレッドシート」を選択します。\n   スクリプトエディタを開く それでは、いよいよ スクリプトエディタ を開きます。\nスクリプトエディタ は、GASのスクリプトの編集、実行、デバックなどを行うことができるエディタで、便利な機能が多数搭載されています。\n  メニューから[ツール]\u0026gt;「スクリプトエディタ」を選択します。\n  エディタが表示されればOKです。\n  プロジェクト名を設定する。 この先の手順を進めるためには、まずプロジェクト名を設定する必要があります。\nプロジェクト名は画面左上に表示されていて、デフォルトでは「無題のプロジェクト」となっています。\n「プロジェクトってなんだろう？」と疑問に思われるでしょうが、\nこれから作成するGASファイルをまとめているフォルダのようなイメージになります。\nプロジェクト名は自由につけていただいて構わないのですが、\n今回のハンズオンではプロジェクト名を「はじめてのGAS」と設定しましょう。\n  プロジェクト名をクリックする。\n  プロジェクト名を入力して、「OK」ボタンをクリックする。\n  プロジェクト名が設定されれば成功です。\n  これでGASでコーディングするための準備は完了です！\nいよいよGASでコーディングをしていきましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_4/",
	"title": "Web画面からGASの関数を実行してみましょう",
	"tags": [],
	"description": "",
	"content": "ここまでは主にクライアントサイドのコーディングをしてきましたが、\nここからはサーバーサイドのコーデイングをしていきましょう。\nGoogle Apps Script のサーバーサイドは.gsファイルにコーディングします。\nGoogle Apps Script の関数の作り方について それでは.gsファイルにコーディングをしてみましょう。\n今回はスプレッドシートから値を取得する関数と、スプレッドシートへ値を設定する関数を作成してみます。\nコード.gs\nvar SHEET_ID = \u0026#39;シートのID\u0026#39; var SHEET_NAME = \u0026#39;シートの名前\u0026#39; function getSheetData() { // 1. スプレッドシートを特定して取得します。  var spreadsheet = SpreadsheetApp.openById(SHEET_ID); // 2. シートを特定して取得します。  var sheet = spreadsheet.getSheetByName(SHEET_NAME); // 3. セル（範囲）を特定して取得します。  var range = sheet.getRange(\u0026#39;A1\u0026#39;); // 4. 対象のセルの入力値を返します。  return range.getValue(); } function setSheetData() { // 1. スプレッドシートを特定して取得します。  var spreadsheet = SpreadsheetApp.openById(SHEET_ID); // 2. シートを特定して取得します。  var sheet = spreadsheet.getSheetByName(SHEET_NAME); // 3. セル（範囲）を特定して取得します。  var range = sheet.getRange(\u0026#39;A1\u0026#39;); // 4. 対象のセルの入力値を返します。  range.setValue(\u0026#39;hello!\u0026#39;); }  シートのID と シートの名前 は作成した Google スプレッドシートの ID と シートの名前 を入力してください。\n これで Google Apps Script の関数は用意できました。\n次は用意した関数がクライアントサイドから呼び出してみましょう。\n google.script.run について クライアントサイドでgoogle.script.runを使用すると、サーバーサイドの Google Apps Script 関数を実行することができます。\n【リファレンス】google.script.run\nそれでは、早速先ほど作成したsetSheetData()を呼び出してみましょう。\nindex.html\n\u0026lt;script\u0026gt; google.script.run.setSheetData(); \u0026lt;/script\u0026gt; 今回はクライアントサイドで関数の中から呼び出さず、scriptタグの中にコーディングしているため、\n画面が表示されるタイミングで実行されます。\n画面を表示したのち、対象のシートのA1セルに hello! と表示されるかを確認してみましょう。\n引数を渡す 先ほどは 対象のシートのA1セルに hello! と表示されるようにしましたが、\nクライアントサイドで表示する値を設定できるようにしてみましょう。\nsetSheetData()に引数を渡せるようにコードを変更します。\n変更点は次の３点です。\n クライアントサイドでsetSheetData()を呼び出す際に、引数に値（\u0026lsquo;こんにちは！'）を設定する。 サーバーサイドのsetSheetData()が引数の値を受け取ることができるように、丸括弧内に変数 (value)を設定する。 最後のrange.setValue('hello!')の丸括弧内の\u0026rsquo;hello!\u0026lsquo;を変数（value）に置き換える。  index.html\n\u0026lt;script\u0026gt; google.script.run.setSheetData('こんにちは！'); \u0026lt;/script\u0026gt; コード.gs\nfunction setSheetData(value) { // 1. スプレッドシートを特定して取得します。 var spreadsheet = SpreadsheetApp.openById(SHEET_ID); // 2. シートを特定して取得します。 var sheet = spreadsheet.getSheetByName(SHEET_NAME); // 3. セル（範囲）を特定して取得します。 var range = sheet.getRange('A1'); // 4. 対象のセルの入力値を返します。 range.setValue(value); } 変更したのちWeb画面を更新して、対象のシートのA1セルにこんにちは！と出力されているかを確認しましょう。\n画面で入力した値をスプレッドシートに出力する 先ほど実行した関数によって、クライアントサイドから値を渡すことができることを確認できました。\n次はクライアントサイドで入力した値をサーバーサイドに渡してみましょう。\nindex.html\n\u0026lt;input type='txt' id='msg' onclick='output()' /\u0026gt; \u0026lt;script\u0026gt; function output() { // 1. テキストボックスに入力した値を取得します。 var value = document.getElementById('msg').value; // 2. 取得した値を setSheetData関数の引数として設定して呼び出します。 google.script.run.setSheetData(value); } \u0026lt;/script\u0026gt; 変更したのちWeb画面を更新して、対象のシートのA1セルにテキストボックスに入力した値が出力されているかを確認しましょう。\n 同期処理と非同期処理について 次はサーバーサイドから値を取得してみましょう。\n先ほどコーディングしたgetSheetData()を実行してみます。\nindex.htmlを下記の通りに変更したのち、Web画面を更新してアラートで値が表示されるかを確認してみましょう。\nindex.html\n\u0026lt;script\u0026gt; // 1. スプレッドシートから値を取得する var result = google.script.run.getSheetData(); // 2. 取得した値をアラートで表示する alert(result); \u0026lt;/script\u0026gt; アラートにはundefinedと表示されました。\nこれはalert(result)で表示しようとしている変数alertの中身が空っぽということになります。\ngetSheetData()が実行されなかったのでしょうか。\n実はgetSheetData()が実行されていますが、その戻り値が返ってくる前にalert(result)が実行されているのです。\nJavaScriptのアプリケーションは「シングルスレッド」で実行されます。\n「シングルスレッド」を端的に説明すると、 一度にひとつのことを実行していく処理 ということです。\nつまり、1度に1つの処理しかできない（並列処理ができない）のです。\nしかし、非同期処理により外部に処理を任せている間に自身の処理を進めることができます。\n同期処理とは 同期処理はコーディングした処理の上から順番に実行されるという意味です。\n上から順番に実行されるのでシンプルですね。\n下記のスクリプトも同期処理で動いているため、アラートは「1」、「2」、「3」と順に表示されます。\n\u0026lt;script\u0026gt; alert(1); // ① alert(2); // ② alert(3); // ③ \u0026lt;/script\u0026gt; 非同期処理とは 非同期処理は外部に処理を任せている間に自身の処理を進めることができます。\n先ほどシートの値を取得しようとしたスクリプトで確認してみましょう。\nindex.html\n\u0026lt;script\u0026gt; // 1. スプレッドシートから値を取得する var result = google.script.run.getSheetData(); // 2. 取得した値をアラートで表示する alert(result); \u0026lt;/script\u0026gt; getSheetData()でブラウザから Google サーバーに処理を行うように命令をしています。（具体的にはシートから値を取得するように命令しています。）\nしかし、このように外部（Google サーバー）に処理を行うように命令した場合は、その処理結果（戻り値）を待たずにクライアントサイドのJavaScriptは順次処理を続行してしまいます。\nこれが非同期処理です。\nだけど、GAS関数の戻り値を受けとって同期処理を行いたいですよね。\nそれを実現するのがwithSuccessHandlerメソッドとwithFailureHandlerメソッドです。\n withSuccessHandler について withSuccessHandlerメソッドの特徴は 「クライアントサイドからGAS関数を呼び出したのちの処理を設定できる」 ことです。\nこれらのメソッドを活用することでGAS関数で取得した結果をクライアントサイドに表示することができます。\nしかし、活用するには コールバック関数 を理解する必要があります。\nコールバック関数とは 日常生活でコールバックと言いますと、「かかってきた電話にたいして電話をかけ直す（折り返し電話をする）」という意味で使われますね。\nJavaScriptでコールバックは「後々呼び出すために定義した関数」という意味で使われます。\nただ、このコールバックされる関数は特別なことは何もなく、普通のJavaScriptの関数です。\nでは、具体的にどのように使用するのかを下記のようにHTMLを修正して確認してみましょう。\n\u0026lt;script\u0026gt; // 数値の2を返す関数（後々呼び出すためにコーディングされた関数） function getNumber() { return 2; } // 1. アラートで「1」を表示する。 alert(1); // 2. アラートで「getNumber関数の戻り値」を表示する。 alert(getNumber()); // 3. アラートで「3」を表示する。 alert(3); \u0026lt;/script\u0026gt; 上記ではgetNumber関数というコールバック関数をコーディングしています。\nこのコールバック関数をalert(getNumber());で呼び出して実行しています。\nこのように 即時実行するのではなく、後々実行するための関数を定義することができます。\nこれがwithSuccessHandlerメソッドとどのように関係があるのか？といいますと、\nこれらのメソッドは　クライアントサイドからGAS関数を呼び出したのちの処理を設定できる のですが、\nGAS関数を呼び出したのちの処理をコールバック関数で定義することができるのです。\nwithSuccessHandlerとは GAS関数（サーバーサイドの関数）が 正常に完了 して戻り値が返ってきた場合に、\n実行する関数を定義することができます。\nコーディングの仕方は下記の通りです。\ngoogle.script.run.withSuccessHandler(コールバック関数).GAS関数() それでは、シートから値を取得するgetSheetData()を同期処理で取得してアラートでその値を表示してみましょう。\n先ほどはundefinedと返ってきましたが、シートのA1セルの値が表示されれば成功です。\n\u0026lt;script\u0026gt; function outputResult(result) { alert(result); } google.script.run.withSuccessHandler(outputResult).getSheetData(); \u0026lt;/script\u0026gt; 上記のコードは下記のようにコールバック関数をwithSuccessHandlerメソッドの引数として設定してコーディングすることができます。\n（少しコードの量が少なくなりますね！）\n\u0026lt;script\u0026gt; google.script.run.withSuccessHandler(function(result){ alert(result); }).getSheetData(); \u0026lt;/script\u0026gt; "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_4/",
	"title": "clasp を使ってみよう",
	"tags": [],
	"description": "",
	"content": "ログイン・ログアウト Webエディタを使用する際と同様に Google アカウント でログインする必要があります。\nWebエディタにアクセスできない Google アカウントでログインをすると clasp でも利用することができないため、\nどの Google アカウントでログインしているかを意識するようにしましょう。\nclasp login 🔑 Authorize clasp by visiting this url: https://accounts.google.com/o/oauth2/v2/auth?access_type=offline\u0026amp;scope=https%3A%2F%2Fwww.googleapis.com... clasp にログインするアカウントを切り替える場合は一度ログアウトする必要があります。\nログアウト後に再度ログインしたいアカウントでログインを行いましょう。\nclasp logout GASプロジェクトの新規作成 clasp で新規のプロジェクトを作成することができます。\nコマンドの最後にはプロジェクト名を指定します。\n※今回はプロジェクト名を newProject としています。\nclasp create newProject コマンドが正常終了すると、作成されたプロジェクトのURLが表示されます。\nこのURLをブラウザに貼り付けてアクセスすることができますが、\n次のコマンドを実行するだけで開くことができます。\nclasp open ここでローカル環境を確認してみましょう。\n以下の２ファイルが生成されていることが確認できます。\n .clasp.json appsscript.json  clasp.json はローカル環境とクラウド上のWebエディタを紐付けている重要なファイルです。\nappsscript.json はGASプロジェクトの情報を持っているファイルです。\nこのファイルは実はこれまで作成してきたGASプロジェクトにも存在しており、\nWebエディタ上で確認することができます。（デフォルトで非表示になっています。）\nWebエディタ上のファイルを取得する（clasp pull） clasp でWebエディタ上の最新のファイルを取得することができます。\nこのコマンドを実行することで、ローカル環境をWebエディタと同じ内容にすることができます。\nclasp create の際にWebエディタ上に Code.gs が生成されているため、以下のコマンドでローカルに落としてみましょう。\nclasp pull この際に注目してほしいのはローカルに落としたファイルの拡張子です。\nCode.gs を落としてきたはずが、拡張子が変わり Code.js になっています。\nこれは clasp が自動的に拡張子を変更してくれているためです。\nまた、このコマンドを実行するとローカルの同名ファイルを強制的に上書きしてしまうため、\n実行の際は上書きしても問題がないか確認をしたうえで実行しましょう。\nWebエディタ上にファイルを送る（clasp push） ローカルで編集したファイルをWeb上に送ることができます。\nこのコマンドを実行することで、Webエディタをローカル環境と同じ内容にすることができます。\n試しに Code.js にコーディングされている myFunction を以下の内容に変更してみましょう。\nfunction myFunction() { console.log(\u0026#39;Hello!\u0026#39;); } 変更して保存が完了したら、以下のコマンドを実行してWebエディタに送ってみましょう。\nclasp push コマンド実行後にWebエディタを再表示するとWebエディタがローカル環境と同じ内容になっています。\nclasp pull と同様にローカルの .js ファイルはWebエディタ上では .gs に変換されています。\nこのコマンドで気をつけるべきことは、カレントディレクトリにある全てのファイルをWebエディタ上に送ろうとします。\nWebエディタ上には拡張子が .gs と .htmlのファイルと appsscript.json しか作成することができないため、\nそれ以外のファイルを送ろうとするとエラーが発生して失敗します。\nこのようなときはpush対象のファイルから除外するファイルを指定する .claspignore を作成する必要があります。\ntouch .claspignore .claspignore の内容は適宜必要に応じて変更する必要がありますが、\n以下の内容で .js と appsscript.json 以外のファイルがpushされないようにすることができます。\n**/** !.js !appsscript.json 1行目の**/**はカレントフォルダ配下にあるフォルダ・ファイルを全て対象にするという意味です。\nこれで全てのファイルがpush対象ではなくなります。\nただこれでは何もWebエディタ上に送ることができないため、2行目以降で送りたいファイルを指定します。\n2行目の !.js は拡張子が.jsのファイルを除外対象にしないという意味です。\n.js のみですと .js をpushしない対象にするという意味になるため、\nそれを否定する！を先頭につけることで、.jsのファイルを除外対象にしないという意味になります。\n同様に3行目で !appsscript.json は appsscript.json を除外対象にしないという意味になります。\nまた、もう一点注意点があり、pushの際にWebエディタにのみファイルがあって、ローカル環境に同ファイルがない場合は消えてしまいます。\npushする際はWebエディタ上にあるファイルを確認したうえで実行するようにしましょう。\nディレクトリ構成 ファイルの数が増えてくるとフォルダの数を増やしたくなることがあると思います。\n仮にsrcフォルダ内にファイルをまとめるように変更した場合は、\n.claspignore を以下のように変更することでpushできるようになります。\n**/** !src/.js !appsscript.json 先ほど違うのは2行目で!src/.jsとすることでsrcフォルダ配下の .js ファイルを除外対象にしないようにしています。\nclasp push をしてWebブラウザを確認してみましょう。\n注目して欲しいのはファイル名で フォルダ名/ファイル名 の形式に変わっています。\nこれにより、clasp pull をした際もsrcフォルダ内のファイルを更新することができます。\nまた、.clasp.json でpush対象の最上位フォルダを指定することができます。\n以下のように rootDir にフォルダ名を追加することで、追加したフォルダ名を push 対象の最上位フォルダにすることができます。\n{ \u0026#34;scriptId\u0026#34;: \u0026#34;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXx\u0026#34;, \u0026#34;rootDir\u0026#34;: \u0026#34;src\u0026#34; } 既存のGASプロジェクトからクローンする ここまでは clasp で新規作成をしてみましたが、既存のGASプロジェクトとローカル環境を紐づけることもできます。\nGoogle Drive上に新規のスクリプトエディタを作成したのち、以下のコマンドを実行してみましょう。\n対象のスクリプトエディタ内のコードがローカル環境に落とすことができれば成功です。\nclasp clone XXXXXX コマンドの最後のXXXXXXには対象のスクリプトエディタのスクリプトIDを設定してください。\nスクリプトIDはスクリプトエディタの プロジェクトの設定 で確認することができます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_4/",
	"title": "スクリプトエディタの使い方",
	"tags": [],
	"description": "",
	"content": "本章ではスクリプトエディタの使い方について解説します。\n2020年の12月末にスクリプトエディタは刷新され、レイアウトと機能が大幅に変わりました。\nサイドメニュー スクリプトエディタを開くと画面の左端にアイコンが縦に5つ並んだサイドメニューが表示されます。\nサイドメニューの各アイコンをクリックするとそれぞれの画面に切り替わります。\n各アイコンをクリックした際に表示される画面は以下の通りです。\n   画面名 内容     概要 プロジェクトの情報の概要が表示されます。   エディタ コードの作成、編集、削除を行う画面です。GASを手動で実行することもできます。   トリガー GASを自動的に実行するトリガーを設定することができます。   実行数 GASの実行ログが表示されます。   プロジェクトの設定 プロジェクトの設定を行うことができます。    概要 プロジェクトの詳細の情報を確認することができます。\nまた、過去７日間のエラー率や実行数を確認することができます。\nエディタ GASのコーディングや実行を行うことができる画面です。\n実行したい関数を指定して「実行」ボタンをクリックすると指定した関数を実行することができます。\n（関数については次章で解説します。）\n関数を実行すると画面下部に実行ログが表示されます。\n関数が正常終了したのか、それともエラーが発生して異常終了したのかはこの実行ログで確認することができます。\nまた、console.log()などのログを出力するメソッドを実行するとその結果が実行ログに出力されます。\nエディタ画面の左側にはファイル、ライブラリ、サービスの3つの項目があります。\nそれぞれの項目の使い方について解説します。\nファイル 「＋」ボタンをクリックすると、プロジェクトにファイルを追加することができます。\nなお、追加することができるファイルはスクリプト（.gs）とHTML（.html）のみです。\nライブラリ 他のGASプロジェクトのスクリプトを利用したい場合に使用します。\n「＋」ボタンをクリックすると、ダイアログが表示されスクリプトIDの入力欄が表示されます。\nその入力欄にスクリプトIDを入力して設定することでスクリプトを利用できるようになります。\nサービス GASで多くの Google のサービスを操作することができますが、\n各サービスのAPIを活用することでより高度な処理を行うことができるようになります。\n「＋」ボタンをクリックすると、ダイアログが表示され、\n追加したいサービスとそのバージョンを指定して追加ボタンをクリックすることで同サービスを利用できます。\n詳細はの公式ガイドをご参照ください。\nトリガー トリガー画面ではGASの関数を時限的に実行するトリガーを設定することができます。\n例えば、以下の画像のようにトリガーを設定すると、myFunction関数を1時間おきに実行されます。\n実行する関数や実行タイミングはそれぞれ設定することができます。\n実行数 実行数画面では過去7日間の同GASプロジェクトの実行結果を確認することができます。\n過去に実行された関数の実行結果を確認したい場合はこの画面で確認しましょう。\nプロジェクトの設定 GASプロジェクトの全般の設定をすることができます。\n Chrome V8 ランタイムの有効化・無効化 マニュフェストファイル（appsscript.json）の表示・非表示  また、プロジェクトに一意に割り振られているスクリプトIDもこの画面で確認することができます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_4/",
	"title": "シートを操作する",
	"tags": [],
	"description": "",
	"content": "Sheetクラスとは Sheetクラス は、シートを操作する機能を提供するクラスです。\nシートの情報を取得するメソッドや行・列の操作、シート上のセルを取得するなどのメソッドが提供されています。\n早速、次のサンプルを実行し、シートの様々な情報を取得してみましょう。\nfunction spreadsheet_5() { var sheet = SpreadsheetApp.getActiveSheet(); console.log(sheet.getIndex()); // シートのインデックス  console.log(sheet.getName());　// シートの名前 } セルを取得する Sheetクラスはシートのセルを取得する機能が備わっていることが大きな特徴です。\nセルを取得するいくつかのメソッドが用意されていますが、その中でも最もスタンダードなメソッドが getRangeメソッド です。\ngetRangeメソッドは引数の数によって様々なパターンのセルを取得することができます。\n一番シンプルなのは、引数に「A1」や「A1:C3」のようなセルのアドレスを文字列で渡して取得する方法です。\nSheetオブジェクト.getRange(アドレス) 他のパターンとしては、行番号・列番号・行数・列数を引数に指定することでセルを取得する方法です。\nSheetオブジェクト.getRange(行番号, 列番号[, 行数, 列数]) ※ []は任意のため省略可能です。\n行番号から行数分、列番号から列数分の範囲を指定して取得することができます。\n行数と列数は省略することができ、省略した場合はそれぞれの値は1となります。\n各値は数値で設定するため、セルを動的に取得したい場合はこの方法を用います。\nそれでは、次のサンプルを実行してセルを取得できているか確認してみましょう。\nfunction spreadsheet_6() { var sheet = SpreadsheetApp.getActiveSheet(); console.log(sheet.getRange(\u0026#39;A1\u0026#39;).getA1Notation()); // A1  console.log(sheet.getRange(\u0026#39;B2:D5\u0026#39;).getA1Notation()); // B2:D5  console.log(sheet.getRange(\u0026#39;2:2\u0026#39;).getA1Notation()); // 2:2  console.log(sheet.getRange(\u0026#39;B:B\u0026#39;).getA1Notation()); // B:B  console.log(sheet.getRange(3, 3).getA1Notation()); // C3  console.log(sheet.getRange(3, 3, 2).getA1Notation()); // C3:C4  console.log(sheet.getRange(3, 3, 2, 2).getA1Notation()); // C3:D4 } サンプル内で実行しているgetA1Notationメソッドはセル範囲のアドレスをA1形式で取得するメソッドです。\nA1形式のアドレス指定であれば行または列全体の取得も可能です。\nまた、行番号・列番号・行数・列数は変数で指定することも可能です。\nシートのデータ範囲を取得する アドレスや行番号、列番号がわからない場合や、シートに値が追加されていって取得するセル範囲が変化する場合はどのようにして取得するとよいでしょう？\nこのようなときに getDataRangeメソッド は非常に便利で、シート上のデータが存在する範囲をすべて取得してくれます。\nSheetオブジェクト.getDataRange() また、セルの範囲ではなく、データが存在する最後の行番号を取得する getLastRowメソッド や、\nデータが存在する最後の列を取得する getLastColumメソッド も便利なメソッドです。\nSheetオブジェクト.getLastRow() Sheetオブジェクト.getLastColumn() これらのメソッドの使用例を次のサンプルで確認してみましょう。\nfunction spreadsheet_7() { var sheet = SpreadsheetApp.getActiveSheet(); console.log(sheet.getDataRange().getA1Notation()); console.log(sheet.getlastRow()); console.log(sheet.getlastColumn()); } getDataRangeメソッドの取得範囲の起点はA1セルで、そこからデータが入っている最終行および最終列までの範囲を取得します。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/control_syntax/page_2_2_4/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "条件分岐処理や繰り返し処理などのJavaScriptの制御構文について紹介してきました。\nGASで実装する際に制御構文がかけると処理幅を大きく広がるので是非活用してください。\n次は「関数」について解説いたします。\n関数を使用することで一連の処理をひとまとめにして、再利用をしやすくなります。\n開発を効率よく進めたり、メンテナンス性を高める効果があるのでしっかり学んでいきましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/page_2_3_4/",
	"title": "無名関数",
	"tags": [],
	"description": "",
	"content": "関数式と無名関数 ここまで関数を定義するのに「関数宣言」を用いてきました。\nあとで呼び出して使用する関数名と関数が何をするかの定義の両方を指定する方法です。\n実はJavaScriptでは他にも関数の定義方法があり、その一つが関数名を指定しない「無名関数（匿名関数）」といいます。\n名前のない関数をどうやった呼び出すのか？といいますと、「関数式」を使用することで呼び出せるようになります。\n関数式は構文的には関数名を省略する以外は関数宣言と全く同じです。\n下記の例では変数fを使って、f()で代入した関数を呼び出すことができます。\nvar f = function() { // 処理内容 } 無名関数は他の関数（メソッド）の引数として、あるいはオブジェクトのプロパティとしてよく使われます。\n即時関数 ここまでの関数は事前に定義をして、その後に関数を実行してきましたが、\n宣言と同時に関数を実行することもできます。\nこの関数を即時関数といいます。\n即時関数の文法は下記の通りです。\n(function() { // 処理内容 })(); 先ほどは関数式を使用することで無名関数を作ることができると説明しましたが、\nその応用でその関数を即時に呼び出すことができます。\n即時関数のメリットは即時に関数を実行できることと関数内部に独自のスコープを持っているためスコープ外からはアクセスできないことにあります。\nvar message = (function(){ return 10 * 10; })(); console.log(message); // 100 "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/",
	"title": "関数を学ぼう",
	"tags": [],
	"description": "",
	"content": "Chapter 2 - 4 JavaScriptの関数 JavaScriptの関数の仕組みについて学びましょう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/page_2_1_4/",
	"title": "変数",
	"tags": [],
	"description": "",
	"content": "変数とは 変数（variable）は値を記憶する領域に名前つけたもののことを指します。\n変数という名前の通り、記憶した値を変更することができます。\n例えるなら、値を格納する箱のようなものが変数で、その箱に格納した値は任意で変更することができるのです。\n変数を使うことで、データを一時的に保管したり、変数名で呼び出して格納した値を何度でも使用することができます。\n変数を実際に使うには、その変数を 宣言 する必要があります。\nJavaScriptで変数を宣言する際は行頭に var をつけて、その後に変数名を記述します。\nvar 変数名; var 変数名1, 変数名2, 変数名3; // カンマ区切りにすることで、1行で変数を複数宣言することもできます。 変数に値を代入する 変数にデータを格納することを 代入 といいます。\n代入は左辺に変数名を記述し、イコールを挟んで右辺に格納する値を記述します。\n変数を宣言する際に初期値を必ずしも指定する必要はなく、\n指定しない場合は「未定義」であることを意味する undefined が自動的に設定されます。\n変数名 = 値; 変数に値を代入したのち、その変数名を記述することで格納した値を呼び出すことができます。\n下記のサンプルではログに2回出力しています。\n1回目のログ出力は代入する前であるため「未定義」を意味する undefined が出力され、\n2回目のログ出力は「10」を変数numに代入しているため 10 がログに出力されます。\nfunction myFunction() { var num; console.log(num); // undefined  num = 10; console.log(num); // 10 } 変数の宣言時に値の代入をすることもでき、このことを 初期化 といいます。（2行のコードが1行になるのでスッキリしますね。）\nこの場合もカンマ区切りでまとめて初期化を行うことができます。\nfunction myFunction() { var num_1 = 10; var num_2 = 100, num_3 = 1000; // まとめて初期化も可能  console.log(num_1); // 10  console.log(num_2); // 100  console.log(num_3); // 1000 } また、変数に代入したのち、変数に格納した値を上書きすることもできます。\n上書きは変数に値を代入する方法と同じ方法で記述することができます。（宣言ではないので var は不要です。）\nfunction myFunction() { var num = 10; console.log(num); // 10  num = 100; console.log(num); // 100 } 定数とは 変数は上書きができると説明しましたが、ときには変数を上書きしたくないケースもあります。\nこのように上書きしたくない変数は 定数 として宣言して使用します。\n定数（constant）も同様に値を保持できますが、変数とは違って初期化後に再代入することができません。\nまた、具体的な数値や文字列を表す定数の変数名には、\n大文字と「_」（アンダースコア）を組み合わせて名前をつけることが慣習となっています。（必須ではありません。）\nこのようにすることで、大量のコードの中から値が変わらない（変えてはいけない）変数が見つかりやすくなります。\n定数は変数と同じく名前をつけることができ、値を格納することもできますが、 一度値を格納すると以降はその値を変更することができません。\nJavaScriptで定数を宣言する際は行頭に const をつけて初期化を行います。\nconst 定数名 = 値; 下記のサンプルで定数が更新されないことを確認してみましょう。\nfunction myFunction() { const num = 10; num = 100; console.log(num); } 定数numに対して、100を再代入して上書きしようとしましたが、\n「TypeError: Assignment to constant variable.」とエラーが表示されます。\n一般的に定数を使用できるのであれば、変数ではなく定数を使うべきです。\nスプレッドシートのIDやURLなど、処理の中で変わることがない値は定数で宣言することを推奨します。\n逆に変数を使うべき場面もあります。\n例えば、ループ処理の中で値が更新される場合は変数を使う必要があります。\n 識別子の命名規則 ここまでで変数、定数、関数に対して任意の名前をつけることができると説明してきました。\nこれらの名前は 識別子 といい、JavaScriptでは自由に名前をつけることができるのですが、実はルールが設けられています。\n 先頭文字は数字や記号文字を使うことができない。（記号文字のうちアンダースコア（_）とドル記号($)は使用できます。） 予約後は使用できない。 大文字と小文字は区別される。  予約語 はJavaScriptで特別な意味を持つ単語として決められているワードになります。\n例えば、変数宣言で使用する var や、関数の定義で使用する function が挙げられます。\nJavaScriptの予約語は下記の通りです。\n break case catch continue debugger default delete do else finally for function if in instanceof new throw try typeof var void while with  識別子の命名のコツ 識別子のルールが守られていれば自由に名前をつけることができます。\nただ、名前の付け方が統一されていて、かつ読みやすい名前ですとコーディングがしやすいですよね。\n以下のポイントを守って名前をつけるとコーディングがしやすくなります。\n変数の中身や関数の内容がわかる名前をつける 例えば、変数に名前を格納したい場合ですと皆さんはどのような変数名をつけますか？\n下記のサンプルでは、文字列の「Taro」を変数nameと変数numに格納しています。\n変数名をnameにすると、格納されている値は名前だと想像することができます。\nその一方、変数名がnumにすると、格納されている値は一見数字であると想像してしまいます。\n関数の名前も同様にどのような処理が行われているイメージがしやすい名前をつけるようにしましょう。\nvar name = \u0026#39;Taro\u0026#39;; // Good! var num = \u0026#39;Taro\u0026#39;; // NG! 日本語やローマ字は使わず、英語を使う JavaScriptの予約後は英語なので、識別子は英語で統一するとコードが読みやすくなります。\n日本語やローマ字で変数宣言や関数の定義をすることはできますが、書き方に統一感がないと読みにくくなるためおすすめはできません。\nvar name = `Taro`; // Good! var 名前 = `Taro`; // NG! var namae = `Taro`; // NG! 変数名と関数名はキャメル記法、定数名にはスネーク記法を使う キャメル記法 というのは、複数の英単語で変数名や関数名をつける際に2つ目以降の頭文字を大文字にする記法です。\nキャメルというのはラクダ（Camel）が由来なのですが、頭文字を大文字にするとちょうどそこがコブのように見えることから キャメル記法 と言われています。\nもうひとつの記法として スネーク記法 と呼ばれるものがあります。こちらは英単語をアンダースコア（_）でつないでいく記法です。\n// 関数名はキャメル記法 function getUserName() { // 変数名はキャメル記法  var userName = \u0026#39;Taro\u0026#39;; // 定数はスネーク記法  const greeting_word = \u0026#39;Hello \u0026#39;; console.log(greeting_word + userName); // Hello Taro } これらのポイントを意識しながらコーディングをすると、自然と読みやすいスクリプトになっていきます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/page_5/",
	"title": "Web画面にスプレッドシートの値を表示してみましょう",
	"tags": [],
	"description": "",
	"content": "Scriptletについて GASで生成した値を画面に出力したいときは　Scriptlet を使用すると簡単に出力することができます。\nScriptletには「Standard scriptlets」と「Printing scriptlets」の２種類あります。\nStandard scriptlets スクリプトとして実行しますが、結果は画面に出力されません。\nfor文などの処理をしたい場合に記述します。\n\u0026lt;? ... ?\u0026gt; Printing scriptlets 実行結果を画面に出力することができます。\n\u0026lt;?= ... ?\u0026gt; スプレッドシートの値を表示する Scriptletを使用するとスプレッドシートの値を画面に出力することができます。\nfunction doGet(e) { var template = HtmlService.createTemplateFromFile(\u0026#39;index\u0026#39;); var sheet = SpreadsheetApp.openById(\u0026#39;XXXX\u0026#39;).getSheetByName(\u0026#39;XXXX\u0026#39;); var values = sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn() - 1).getValues(); template.values = values; return template.evaluate(); } \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;base target=\u0026quot;_top\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;wrapper\u0026quot;\u0026gt; \u0026lt;div id=\u0026quot;header\u0026quot;\u0026gt; \u0026lt;h1\u0026gt;成績表\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;main\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;events\u0026quot;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;名前\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;国語\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;英語\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;数学\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;? for (var i = 0; i \u0026lt; values.length; i++) { ?\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][0]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][1]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][2]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;\u0026lt;?= values[i][3]; ?\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;? } ?\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/web/",
	"title": "Webアプリ編",
	"tags": [],
	"description": "",
	"content": "Chapter 4 Webアプリ編 Google Apps Script で Webアプリを作ってみよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/page_5/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "これにて clasp の使い方の解説は終了です。\nclasp はGASのチーム開発で必須となるツールです。\nぜひ、活用してみてください！\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/local/",
	"title": "ローカル開発編",
	"tags": [],
	"description": "",
	"content": "Chapter 5 ローカル開発編 ローカル環境でGAS開発をしてみよう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_5/",
	"title": "セル範囲を操作する",
	"tags": [],
	"description": "",
	"content": "Rangeクラスとは Rangeクラス は、セル範囲を操作する機能を提供するクラスです。\nセルの値や数式の取得や設定、セル範囲の情報の取得、書式の設定、並べ替えなどのメンバーが用意されています。\n試しに、セル範囲の様々な情報を取得するサンプルを実行してみましょう。\nfunction spreadsheet_8() { var range = SpreadsheetApp.getActiveSheet().getRange(\u0026#39;A2:C5\u0026#39;); console.log(range.getRow()); // 2  console.log(range.getColumn()); // 1  console.log(range.getNumRows()); // 4  console.log(range.getNumColumns()); // 3  console.log(range.getLastRow()); // 5  console.log(range.getLastColumn()); // 3 } 値を取得・設定する Rangeクラスのメンバーで最も基本的な操作はセルからの値の取得・設定といえます。\n単体セルの値を取得する getValueメソッド と単体セルの値を設定する setValueメソッド の構文を確認していきましょう。\nRangeオブジェクト.getValue() Rangeオブジェクト.setValue(値) このメソッドには注意すべきことがありまして、セルを1つ1つに処理していくため、\nそのセルの数の分だけスプレッドシートへのアクセス回数がかさんでしまいます。\nアクセス回数がかさむと処理速度も遅くなります。\nそのため、複数のセル範囲を取得・設定する場合は、\nセル範囲が対象の場合はセル範囲の値を取得する getValuesメソッド を、\nセル範囲の値を設定する setValuesメソッド を使用するようにしましょう。\nRangeオブジェクト.getValues() Rangeオブジェクト.setValues(配列)  setValuesメソッドでは、対象となるセル範囲の「行数×列数」と、引数の二次元配列の「要素数×要素数」が一致している必要があります。\n function spreadsheet_9() { var sheet = SpreadsheetApp.getActiveSheet(); sheet.getRange(\u0026#39;A1\u0026#39;).setValue(\u0026#39;Google\u0026#39;); console.log(sheet.getRange(\u0026#39;A1\u0026#39;).getValue()); // google  var values = [ [\u0026#39;Taro\u0026#39;, 22, \u0026#39;東京\u0026#39;], [\u0026#39;Hanako\u0026#39;, 25, \u0026#39;大阪\u0026#39;] ]; sheet.getRange(\u0026#39;A2:C3\u0026#39;).setValues(values); console.log(sheet.getRange(\u0026#39;A2:C3\u0026#39;).getValues()); // [\u0026#39;Taro\u0026#39;, 22, \u0026#39;東京\u0026#39;],[\u0026#39;Hanako\u0026#39;, 25, \u0026#39;大阪\u0026#39;] } "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/object_mechanism/",
	"title": "オブジェクトの仕組みを学ぼう",
	"tags": [],
	"description": "",
	"content": "Chapter 2 - 5 オブジェクトの仕組み JavaScriptのオブジェクトの仕組みを学びましょう！ "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/function/page_2_3_5/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "関数とは何か、またその定義の方法やスコープについて解説いたしました。\nJavaScriptの関数は一連の処理をまとめる以上の機能を持っていることを確認できたのではないかと思います。\n続いては「オブジェクト」について紹介します。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/page_2_1_5/",
	"title": "データ型",
	"tags": [],
	"description": "",
	"content": "データ型とは データ型とは、データの種類のことをいいます。\n例えば、データが「数値型」であれば四則演算で計算を行うことができますが、「文字列型」の場合は四則演算で計算を行うことができません。\nJavaScriptではデータの種類を「プリミティブ(primitive)」と「オブジェクト(object)」の2つに分けられます。\nこれらのデータ型の値は リテラル といわれていて、変数や定数に格納して使用されます。\nプリミティブ プリミティブ（文字列や数値）は「不変(immutable)」という特徴があり、プリミティブのデータ型は次の5種類があります。\n下記のようにデータ型により実行できる処理が異なります。\n   データ型 概要 データの例     数値型（Number） 整数値や浮動小数点値 10, 1.23   文字列型（String） 文字列 \u0026lsquo;Taro\u0026rsquo;, \u0026lsquo;123\u0026rsquo;   真偽型（Boolean） 真と偽のどちらかの値 true, false   null 値がないことを表す特殊な値 null   undefined 値が定義されていないことを表す特殊な値 undefined    この「不変」というのは「変数の値を変更できない」という意味ではありません。\n下記のサンプルは文字列の中から一部の文字列を切り取っていますが、実行すると切り取り元のデータは変わっていないことが確認できます。\nfunction myfunction() { var str = \u0026#39;12345\u0026#39;; // 0文字目から3文字を切り出す  var result = str.substr(0, 3); // 切り出した0文字目から3文字  console.log(result); // 切り取り元のデータは変更されていない。  console.log(str); } 123 12345 このように プリミティブ型は置き換える（再代入）することはできますが、値をそのものを変更することはできません。\n上記をプリミティブ型の特徴を念頭に置いて、各プリミティブ型の違いを確認していきましょう。\n他のプログミング言語（Javaなど）では、変数宣言時に指定したデータ型以外の値を入れることができないものもありますが、\nJavaScriptはデータ型については寛容です。\n例えば、数値型のデータを格納していた変数に文字列型のデータを代入することも可能です。\n 数値型（Number） 数値型は整数や小数以外にも16進数を扱うことができます。\n全角数値の場合やカンマが含まれている場合（例：1,000）は数値として扱われないため注意しましょう。\nfunction outputNumber() { console.log(10); // 10  console.log(1.23); // 1.23  console.log(0xFFFF); // 65535  console.log(100000000); // 1.0E7  console.log(0.0000001); // 1.0E-6 } 上記のサンプルを実行すると、「1.0E7」や「1.0E-6」という結果が表示されます。\nこれらは 指数表現 といい、整数部の桁数が7桁以上、小数点の桁数が6桁以上の数値は指数表記となります。\nまた、数値と数値の間に四則演算子がある場合は計算が行われます。\nfunction calNumber() { console.log(1 + 1); // 2  console.log(2 - 3); // -1 } 文字列型（String） JavaScriptでは文字列型の値を記述する場合はシングルクォーテーション（'）、またはダブルクォーテーション（\u0026quot;）で囲います。\nどちらを使ってもよいのですが、コーディングをする際はどちらかに統一するとコードが読みやすくなります。\nまた、シングルクォーテーションまたはダブルクォーテーションを文字列として使用したい場合は、\n使用されていないクォーテーションで囲うことになります。\nfunction outputString_1() { console.log(\u0026#39;Hello \u0026#34;Taro\u0026#34;!\u0026#39;); // Hello \u0026#34;Taro\u0026#34;!  console.log(\u0026#34;I\u0026#39;m Taro\u0026#34;); // I\u0026#39;m Taro } 改行やタブなどの特別な文字はバックスラッシュ（\\）に指定文字を組み合わせることで表現することができます。\nこれを エスケープシーケンス といいます。\nGASで使用できるエスケープシーケンスは下記の通りです。\n   エスケープシーケンス 概要     \\n 改行   \\r 復帰   \\t タブ   \\\\ バックスラッシュ   \\\u0026rsquo; シングルクォーテーション   \\\u0026rdquo; ダブルクォーテーション    試しに下記のサンプルでエスケープシーケンスを確認してみましょう。\nfunction outputString_2() { /* Hello \u0026#39;GAS\u0026#39;! */ console.log(\u0026#39;Hello\\n\\\u0026#39;GAS\\\u0026#39;!\u0026#39;); } 文字列は四則演算子の+で結合することができます。\n下記のサンプルでは+の左辺と右辺を結合してひとつの文字列しています。\nなお、左辺と右辺が数値の場合は加算の処理がなされる点には気をつけてください。\nfunction outputString_3() { console.log(\u0026#39;Hello \u0026#39; + \u0026#39;GAS\u0026#39;); // Hello GAS  console.log(\u0026#39;1\u0026#39; + \u0026#39;2\u0026#39;); // 12  console.log(1 + 2); // 3 } 文字列の中に変数などの値を設定したい場合は、下記の通り「＋」記号で文字列連結を行うことで実現できます。\nfunction outputString_4() { var age = 50; var message = \u0026#39;私の年齢は\u0026#39; + age + \u0026#39;歳です。\u0026#39;; console.log(message); // 私の年齢は50歳です。 } 上記のように文字列連結で実現できますが、\nテンプレートリテラル を使用するとよりスマートに書くことができます。\nfunction outputString_5() { var age = 50; var message = `私の年齢は${age}歳です。`; console.log(message); // 私の年齢は50歳です。 } このようにテンプレートリテラルを使うと、変数などの値を文字列に埋め込むのがシンプルに書けます。\nテンプレートリテラルは文頭と文末を「`」(バッククォート）で囲むことで使用できます。\nテンプレートリテラルでは「$」を特別な値として扱っており、\n変数や定数を「${}」で囲むことでその変数や定数の値を文字列に埋め込むことができます。\n「${}」の中には計算式や関数を設定することで、その結果を埋め込むこともできます。\nfunction outputString_6() { var age = 50; var message = `私の年齢は${age + 10}歳です。`; console.log(message); // 私の年齢は60歳です。 } 真偽型（Boolean） 真偽型 は、trueとfalseのいずれかの値で表現する値です。\n「正しい（true）または誤り（false）」、「Yes（true）またはNo（No）」といったどちらかの結果のみ扱う場合に使用します。\n真偽型は後々登場する条件式で活躍するため覚えておきましょう。\nなお、JavaScriptでは次の値は偽（false）とみなされます。\n undefined null false 0 NaN \u0026lsquo;'(空文字列)  null null は値が存在しないことを意味します。\n数値の「0」や文字列の「’’」も値が存在しないという意味をしているように思えますが、\n厳密には「0」という数値、「''」という文字列が存在しています。\n一方で、nullは本当の意味で値が存在しないこと意味しています。\n例えば、文字列型の変数の値がnullの場合は「変数に文字列は入っていない」という意味になります。\n文字列型の変数の値が'\u0026lsquo;の場合は「変数に空文字（''）が入っている」という意味になります。\nどういうときに使うかといいますと、後々代入する予定の変数を初期化する際に使われることがあります。\nこれができて何が嬉しいの？と思われると思いますが、後々解説する制御構文でその意味がわかると思います。\nvar num = null; undefined undefined は値が未定義であることを意味します。\n例えば、下記のサンプルでは変数の宣言後に代入を行っていませんが、この変数のを参照するとundefinedとなっています。\nどの変数も宣言して代入するまではundefinedの状態になります。\nfunction outputUndefined() { var num; console.log(num); // undefined } オブジェクト オブジェクトはプリミティブとは異なり、さまざまな形式や値をを取ることができる柔軟性があるデータです。\nそのため、実装者にとって都合のよいオリジナルのデータ型を作ることができます。\nJavaScriptにはオブジェクトのデータ型が用意されており、今回は下記の２点を次章以降で紹介します。\n   データ型 概要 データの例     配列型（Array） インデックスをキーとするデータの集合体 [1, 2, 3], [\u0026lsquo;太郎\u0026rsquo;, 20, true]   オブジェクト型（Object） プロパティをキーとするデータの集合体 {name: \u0026lsquo;太郎\u0026rsquo;, age: 20, isStudent: true}    また、プリミティブ型の数値と文字列、論理値にはそれぞれオブジェクト型が存在しており、\n数値はNumber型、文字列にはString、論理値にはBooleanが対応しています。\nそれぞれ、対応するプリミティブ型の機能を提供しています。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_5/",
	"title": "GASでコーディングしてみよう",
	"tags": [],
	"description": "",
	"content": "関数とは では早速、GASのスクリプトをコーディングしていきましょう。\nスクリプトエディタには既に下記のコードが記述されていると思います。\nfunction myFunction() { } これは関数と呼ばれ、一連の処理をひとまとめにして名前をつけたものになります。\n{ と } の間に1行空いていますが、この間に処理をコーディングしていきます。\nコーディングの際は下記のルールに気をつけてください。\n下記のルールが守られていない場合は、スクリプトを保存する際にエラーとなります。\n  英数字、記号はすべて 半角 であること\n  アルファベットの大文字、小文字を間違えないこと（myFunctionとMYFUNCTIONとでは別の関数として認識されます。）\n  ピリオドやセミコロンなどの記号の入力漏れや打ち間違いがないこと\n   メッセージを表示してみる 今回のハンズオンでは「Hello World!」というメッセージをスプレッドシートに表示してみたいと思います。\nmyFunction関数の　{ と } の間に下記のようにコードを追記してください。\nまた、追記する際は字下げ（インデント）をしてコードを読みやすくしましょう。\n字下げ（インデント）はTabキーをクリックすると行えます。\nfunction myFunction() { Browser.msgBox(\u0026#39;Hello World!\u0026#39;); } スクリプトを編集した場合は保存をする必要があります。\nスクリプトを編集すると、「コード.gs」の前に赤いアスタリスクマークが表示されます。\nスクリプトエディタ上のスクリプトは編集をしても自動的に更新はなされないため、編集したスクリプトを反映させるには保存する必要があります。\nこの赤いアスタリスクマークが表示されている場合は保存がなされていない状態です。\nツールメニューバーの「保存」ボタン（ディスクのアイコン）をクリックすると保存することができます。\n赤いアスタリスクのマークがなくなれば保存は完了です！\nスクリプトの保存はショートカットキーがあり、WindonwsはCtrl + S、Macはcommand + Sで保存することができます。\n 保存が完了すれば、最後にスクリプトの実行です。\nスクリプトの実行はツールメニューバーの「実行」ボタン（再生のアイコン）をクリックすると実行することができます。\nこの際にツールバーに実行する関数の名前が表示されているかを確認しましょう。\nスクリプトの実行はショートカットキーがあり、WindonwsはCtrl + R、Macはcommand + Rで実行することができます。\n 初回の実行の際は「承認が必要です」というダイアログが表示します。\nスクリプトを実行するユーザーに対して、操作対象のスプレッドシートへアクセスする必要があります。\n「許可を確認」をクリックすると、さらに小画面が表示されアカウントの一覧が表示されます。\nここで今回のGASを実行するアカウントを選択します。\n最後に表示された画面の「許可」ボタンをクリックすると、スクリプトが実行されます。\n実行するとスクリプトエディタが表示されており、特に変化は見当たらないと大みます。\nでは、スプレッドシートの画面に切り替えてみてください。\n「Hello World!」とメッセージが表示されているはずです。\n（メッセージは「OK」ボタンもしくは右上の「×」ボタンで閉じることができます。）\n 関数を更新してみる 作成した関数はもちろん編集することができます。\n先ほど作成したmyFunction関数で表示したメッセージを「Hello World!」から「Hello GAS!」に変更してみましょう。\nfunction myFunction() { Browser.msgBox(\u0026#39;Hello GAS!\u0026#39;); } 先ほどと同じ手順で「保存」→「実行」をしてみましょう。\n（2回目以降は承認の手続きは不要のため、承認のダイアログは表示されません。）\n「Hello GAS!」とメッセージが表示されていれば成功です！\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_6/",
	"title": "トリガー",
	"tags": [],
	"description": "",
	"content": "トリガーとは GASにはドキュメントを開くなどの特定のイベントが発生した際に関数を自動的に実行するトリガーという機能があります。\nさまざまな条件でトリガーを設定することができますが、以下のトリガーはGASに組み込まれている予約済みの関数です。\nこのトリガーは シンプルトリガー と呼ばれており、関数を定義することで利用することができます。\n   関数名 概要     onOpen(e) ユーザーが編集する権限を持つスプレッドシート、ドキュメント、プレゼンテーション、またはフォームを開いたときに実行されます。   onInstall(e) ユーザーがGoogleドキュメント、スプレッドシート、スライド、またはフォーム内からエディターアドオンをインストールすると実行されます。   onEdit(e) ユーザーがスプレッドシートの値を変更したときに実行されます。   onSelectionChange(e) ユーザーがスプレッドシートの選択を変更したときに実行されます。   doGet(e) ユーザーがWebアプリにアクセスしたとき、 またはプログラムがHTTPGET要求をWebアプリに送信したときに実行されます。   doPost(e) プログラムがHTTPPOSTリクエストをWebアプリに送信するときに実行されます。    シンプルトリガーはユーザーの承認を求めることなく実行できるという特徴があります。\nその一方で、以下のような制限もあります。\n ファイルが読み取り専用（表示またはコメント）モードで開かれている場合、これらは実行されません。 承認が必要な サービスにはアクセスできません。(Gmail Service など) 30秒を超えて実行することはできません。  上記以外にもいくつか制限がありますので、詳細は以下リンク先の公式サイトで確認してください。\nhttps://developers.google.com/apps-script/guides/triggers\n今回はこのシンプルトリガーのうち onOpen(e) でシンプルトリガーがどのような機能かを確認してみましょう。\n（次章では doGet(e) を深掘りしていきます。）\nonOpen(e) onOpen関数でコーディングした内容は、スプレッドシート、ドキュメント、プレゼンテーション、またはフォームを開いたときに実行されます。\nただし、前提としてファイルを開いたユーザーに編集権限が必要 となります。\nonOpen関数の一般的な活用方法としては、初期表示時に画面上部にメニューを追加する処理を実行することが多いです。\nhttps://developers.google.com/apps-script/guides/menus\nfunction onOpen(e) { /** * スプレッドシートの上部に「カスタムメニュー」を追加します。 * 「カスタムメニュー」を開くと選択肢として「アイテム1」と「アイテム2」が表示されます。 */ SpreadsheetApp.getUi() .createMenu(\u0026#39;カスタムメニュー\u0026#39;) .addItem(\u0026#39;アイテム1\u0026#39;, \u0026#39;menuItem1\u0026#39;) .addItem(\u0026#39;アイテム2\u0026#39;, \u0026#39;menuItem2\u0026#39;) .addToUi(); } 上記スクリプトを保存したのち、スプレッドシートを更新して開き直してみてください。\nスプレッドシートを開き直すことでonOpen関数が実行され、以下画像のようにメニューが表示されます。\n時限式のトリガー 特定のイベントが発生した際に実行されるトリガーですが、\n時間を条件にトリガーを設定することもできます。\nこの時限式のトリガーを活用することで、「◯時間ごとに」や「毎日0〜1時に」などの時間を条件にしたトリガーを設定できます。\nトリガ＝は以下画像通り、[トリガー]を選択するとトリガーの画面が表示され、\n同画面の[トリガーを追加]ボタンをクリックするとトリガーを追加する画面が表示されます。\nトリガ＝を追加する画面ではまず「実行する関数を選択」で実行する関数の名前を指定します。\n指定したのちはその関数を実行する条件を指定していきます。\nイベントのソースを「時間手動型」を選択すると、「時間ベースのトリガーのタイプを選択」でトリガーのタイプを選択できます。\nここで「時間ベース」を選択すると何時間をおきに実行するかを設定できるようになります。\n他にもさまざまな条件のトリガーを設定することできますので、\n詳細は以下リンク先の公式サイトをご参照ください。\nhttps://developers.google.com/apps-script/guides/triggers/installable\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/page_3/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "最後に "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/page_2_1_6/",
	"title": "配列",
	"tags": [],
	"description": "",
	"content": "配列とは これまでは変数や定数に値を一つずつ代入して扱ってきましたが、複数のデータを1つにまとめたくなるケースもあります。\n例えば、果物の名前を変数で管理したい場合は下記の通りになります。\nvar fruitsName_1 = \u0026#39;apple\u0026#39;; var fruitsName_2 = \u0026#39;grape\u0026#39;; var fruitsName_3 = \u0026#39;orange\u0026#39;; このように一つずつ変数を初期化して扱うことは可能ですが、非常に管理がしづらい問題が発生します。\nさらに果物の名前の変数を作りたいとなった場合、fruiteName_Xの形式で変数名を作ることになりますが、\n今回の果物が何個目の果物なのかをわざわざ確認しないといけないですよね。\nこのように、複数のデータをまとめて集合として扱うことができるデータを 配列 といいます。\n配列はカンマで値と区切り、全体を角括弧（[]）で囲むことで表現することができます。（これを 配列リテラル といいます。）\n[値1, 値2, ...] 配列は下記の図のように、複数の箱が連結しているような構造になっています。\nそれぞれの入れ物には番号が順番に割りふられており、番号は「0」から始まります。\nこの番号は インデックス といい、配列に格納されている値を 要素 といいます。\nまた、配列は変数に代入することもできます。\n下記のサンプルは果物の名前を配列で管理した場合のコードとなります。\nfunction outputArray_1() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;]; console.log(fruits); } 'apple', 'grape', 'orange' 配列の特徴 配列には以下の3つの特徴があります。\n 配列の各要素は添字（インデックス）をもっており、先頭が0から始まる数字が割り当てられている。 JavaScriptの配列には異なる型の要素を入れることができる。 配列の最後の要素の添字（インデックス）よりも大きな添字を使って代入を行うと、\n配列が自動的に大きくなり、値が指定されていない要素にはundefinedが暗黙的に代入される。  配列の要素の参照と代入 配列から特定の要素を取り出す場合はインデックスを用います。\n配列名[インデックス] 下記のサンプルは配列fruitsからインデックスが1の要素をログに出力しています。\nインデックスは0から始まるため、インデックスが1の要素は先頭から2番目の要素なので、「grape」が出力されます。\nfunction outputArray_2() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;]; console.log(fruits[1]); // \u0026#39;grape\u0026#39; } また、配列内の特定の要素を代入で更新することもできます。\n配列名[インデックス] = 値; 配列内に指定したインデックスの要素が存在する場合は上書きされます。\n逆に、配列内に指定したインデックスの要素が存在しない場合は要素の追加がなされます。\nfunction outputArray_3() { var fruits = [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;]; fruits[4] = \u0026#39;peach\u0026#39;; console.log(fruits); // \u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;, null, peach  fruits[3] = \u0026#39;berry\u0026#39;; console.log(fruits); // \u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;, \u0026#39;orange\u0026#39;, berry, peach } 多次元配列 先ほどは配列の要素をインデックスで指定して値を取り出したり、上書きしたりしました。\n実はこの要素には配列を設定することができ、配列の中に配列がある 二次元配列 を作ることができます。\nこのように配列が入れ子になっている配列を 多次元配列 といいます。\n二次元配列は下記のように記述することで初期化することができます。\nvar foods = [[\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;], [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;], [\u0026#39;tuna\u0026#39;]]; 二次元配列は要素が多くなるほど構造が複雑になりイメージがしづらいかもしれません。\nそのようなときは下図のように箱の中に箱があるとイメージすると考えやすくなるでしょう。\n二次元配列に対して、「入れ子」になっていない通常の配列を一次元配列といいます。\n 二次元配列から特定の要素を取り出す場合もインデックスを用います。\nfunction outputArray_4() { var foods = [[\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;], [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;], [\u0026#39;tuna\u0026#39;]]; console.log(foods[0]); // \u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;  foods[2] = [\u0026#39;carrot\u0026#39;]; console.log(foods); // [\u0026#39;beef\u0026#39;, \u0026#39;pork\u0026#39;, \u0026#39;chicken\u0026#39;], [\u0026#39;apple\u0026#39;, \u0026#39;grape\u0026#39;], [\u0026#39;carrot\u0026#39;] } 二次元配列の内側の要素を取り出すには、外側のインデックスに続けて内側のインデックスも指定します。\n配列名[インデックス1][インデックス2] 配列名[インデックス1][インデックス2] = 値; 二次元配列の内側の要素の参照、代入および追加は下記のサンプルのように記述することができます。\nfunction outputArray_5() { var number = [[1, 2, 3], [10, 20], [100]]; console.log(number[0][0]); // 1  console.log(number[1][0]); // 10  console.log(number[1][1]); // 20 } function outputArray_6() { var number = [[1, 2, 3], [10, 20], [100]]; number[0][0] = 0; // 要素への代入  number[2][1] = 200; // 要素の追加  console.log(number); // [0, 2, 3], [10, 20], [100, 200] } GASではスプレッドシートのシートの行列のデータを利用する際にこの二次元配列を扱いますので、\n一次元配列だけでなく多次元配列についても理解しておく必要があります。\n配列要素の操作 配列の要素を操作するメソッドは多々ありますが、\n「配列内の要素を変更してしまうメソッド」と「新しい配列を返すメソッド」の２種類に分けられます。\n先頭の要素を操作する 配列の先頭はarr[0]と表現します。\n先頭の要素を操作する関数は下記の2つで、それぞれ配列そのものを変更します。\nshiftメソッド: 先頭の要素を削除する。削除した要素を返す。\nunshiftメソッド: 先頭に要素を追加する。追加後の配列の長さを返す。\nvar arr = [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; console.log(arr.shift()); // b console.log(arr); // [ \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] console.log(arr.unshift(\u0026#39;a\u0026#39;)); // 3 console.log(arr); // [ \u0026#39;a\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] 最後の要素を操作する 配列の最後はarr[arr.length - 1]と表現します。\n最後の要素を操作する関数は下記の2つで、それぞれ配列そのものを変更します。\npushメソッド：最後に要素を追加する。追加後の配列の長さを返す。\npopメソッド:最後の要素を削除する。削除した要素を返す。\nvar arr = [\u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; console.log(arr.push(\u0026#39;e\u0026#39;)); // 4 console.log(arr); //[ \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] console.log(arr.pop()); // e console.log(arr); // [ \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39; ] 複数の要素を追加する concatメソッドは複数の要素を配列に追加し、戻り値として配列のコピーを返します。\n引数として渡された配列の全ての要素を対象の配列の最後に追加します。\nvar arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; var arr2 = arr1.concat(\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;); console.log(arr1); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] console.log(arr2); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] concatメソッドは引数として配列を指定することもできます。\nvar arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; var arr2 = arr1.concat([\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;]); console.log(arr1); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] console.log(arr2); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39; ] 引数に多次元配列を指定することもできますが、その場合は内側の配列はそのまま追加されます。\nvar arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; var arr2 = arr1.concat([\u0026#39;d\u0026#39;, [\u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]]); console.log(arr1); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39; ] console.log(arr2); // [ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, [ \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39; ] ] 配列内の要素を部分的に取り出す 配列の要素のうち一部のみを取り出したい場合はsliceメソッドを使います。\nsliceメソッドは２個の引数を渡します。\n1つめは「要素を取得する開始位置（インデックス）」、2つめは「要素を取得する終了直前の位置（インデックス）」を指定します。\n第２引数を省略すると最後の要素まで取得することになります。\nまた、第2引数に負の値を指定すると最後の要素から数えた場所を指定することになります。\nvar arr1 = [1, 2, 3]; var arr2 = arr1.slice(1); // 元の配列に変化はない console.log(arr1); // [ 1, 2, 3 ] // インデックスが１以降の要素が表示される。 console.log(arr2); // [ 2, 3 ] var arr1 = [1, 2, 3]; var arr2 = arr1.slice(1, 3); // 元の配列に変化はない console.log(arr1); // [ 1, 2, 3 ] // インデックスが１の要素からインデックスが\u00083の直前の要素までが表示される。 console.log(arr2); // [ 2, 3 ] var arr1 = [1, 2, 3]; var arr2 = arr1.slice(1, -1); // 元の配列に変化はない console.log(arr1); // [ 1, 2, 3 ] // インデックスが１の要素から最後のインデックスが\u0008１つ前の要素までが表示される。 console.log(arr2); // [ 2 ] 途中の要素の削除や追加 spliceメソッドを使うと配列の任意の場所を指定して内容を変更することができます。\n第1引数には変更を開始する添字（インデックス）、第2引数には削除する要素の数、\n第3引数以降に追加する要素を指定します。\n戻り値として削除された要素からなる配列を返します。\nvar arr1 = [1, 4, 5]; var arr2 = arr1.splice(1, 0, 2, 3); // インデックス1の要素に3と4を追加 // 元の配列に要素が追加される console.log(arr1); // [ 1, 2, 3, 4, 5 ] // 要素は削除されていないため要素は返されない console.log(arr2); // [] var arr1 = [1, 4, 5]; var arr2 = arr1.splice(1, 2, 2, 3); // インデックス1の要素に3と4を追加 // 元の配列の要素が削除された上で要素が追加される console.log(arr1); // [ 1, 2, 3 ] // 削除された要素が返される console.log(arr2); // [ 4, 5 ] 配列内の要素の逆転とソート 配列の要素を逆順で並び替える場合はreversseメソッドを使用します。\nvar arr1 = [5, 4, 3, 2, 1]; arr1.reverse(); console.log(arr1); // [ 1, 2, 3, 4, 5 ] また、sortメソッドは配列の要素のソート（並び替え）をします。\n既定のソート順は昇順で、要素を文字列に変換してからUTF-16コード単位の値の並びとして比較します。\nvar arr1 = [3, 4, 2, 1, 5]; arr1.sort(); console.log(arr1); // [ 1, 2, 3, 4, 5 ] sortメソッドで配列内のオブジェクトも並び替えることができるのですが、\nその際にプロパティ値で並び替えることができます。\n配列内の要素の検索 配列内の要素を検索する方法をいくつかあります。\nindexOfメソッド 指定した値に厳密に等しい要素（===で等しい要素）をもつ最初の添字を返すメソッドです。\nまた、lastIndexOfメソッドは同様に最後の添字を返します。\n配列の一部だけを検索対象としたい場合は引数に開始位置を指定します。\nちなみに、要素が見つからなかった場合は-1を返します。\nvar arr = [1, 2, 3, 4, 1]; console.log(arr.indexOf(1)); // 0 console.log(arr.lastIndexOf(1)); // 4 console.log(arr.indexOf(5)); // -1 console.log(arr.lastIndexOf(-1)); // -1 上記のサンプルの通り、見つかった場合は添字番号（インデックス）を返し、見つからなかった場合は-1を返します。\nmapとfilter mapメソッドは配列内の要素に対して、引数で指定した関数を呼び出してその結果から新しい配列を生成します。\nvar fruits = [{name: \u0026#39;apple\u0026#39;, price: 300}, {name: \u0026#39;banana\u0026#39;, price: 400}]; // オブジェクトから名前のみ抽出して配列を生成する。 var names = fruits.map(function(fruit) { return fruit.name; }); // オブジェクトから価格のみ抽出して配列を生成する。 var prices = fruits.map(function(fruit) { return fruit.price; }); console.log(fruits); // [ { name: \u0026#39;apple\u0026#39;, price: 300 }, { name: \u0026#39;banana\u0026#39;, price: 400 } ] console.log(names); // [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;] console.log(prices); // [330, 440] 上記のサンプルでは要素（fruit）を1つずつ取り出し、その要素のプロパティ（name, price）を取得しています。\nmapメソッドの引数に関数を渡して、取得した要素を第1仮引数に設定して関数内の処理を行っています。\n関数に渡した第1仮引数は要素そのものですが、第2仮引数と第3仮引数も指定することできます。\n第２仮引数は添字（インデックス）が渡され、第３仮引数はメソッドを実行した配列そのものが渡されます。\nvar fruits = [{name: \u0026#39;apple\u0026#39;, price: 300}, {name: \u0026#39;banana\u0026#39;, price: 400}]; // 第1引数は要素そのもの、第2引数は添字、第3引数は配列そのものが設定されます。 var values = fruits.map(function(fruit, index, _fruits) { // ※第1引数の要素そのものを使用して、fruit.name でも名前を取得できます。  return {index: index, name: _fruits[index].name}; }); console.log(values); // [ { index: 0, name: \u0026#39;apple\u0026#39; }, { index: 1, name: \u0026#39;banana\u0026#39; } ] filterメソッドは配列の内容を特定の条件を絞り込むメソッドです。\nfiterはその名前の通り、配列から不要な要素を取り除く（フィルタリングする）ことができます。\nvar fruits = [{name: \u0026#39;apple\u0026#39;, price: 300}, {name: \u0026#39;banana\u0026#39;, price: 400}]; // オブジェクトから価格が300よりも大きい要素抽出して配列を生成する。 var _fruits = fruits.filter(function(fruit){ return fruit.price \u0026gt; 300; }); console.log(fruits); // [ { name: \u0026#39;apple\u0026#39;, price: 300 }, { name: \u0026#39;banana\u0026#39;, price: 400 } ] console.log(_fruits); // [ { name: \u0026#39;banana\u0026#39;, price: 400 } ] reduce mapメソッドは配列の各要素を変換しますが、reduceメソッドは配列全体を変換します。\nreduce（縮小する）という意味の通り、要素を一つずつ取り出して行う処理を配列全体をまとめて行うことで処理を縮小しています。\nmapやfilterとの違いは、引数として渡す関数の第1仮引数が異なります。\nreduceメソッドの第1仮引数は「アキュムレータ（accumulator）」といい、最終的な戻り値となります。\n下記のサンプルではsum (アキュムレータ)にオブジェクトの価格を加算してその合計を求めています。\nvar fruits = [{name: \u0026#39;apple\u0026#39;, price: 300}, {name: \u0026#39;banana\u0026#39;, price: 400}]; // 第1引数は要素そのもの、第2引数は添字、第3引数は配列そのものが設定されます。 var values = fruits.reduce(function(sum, fruits) { return sum += fruits.price; }); console.log(values); // 400 "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/introduction/page_6/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "ここまでで、皆さんはGASでコーディングした関数を実行することができるようになりました！\nでは早速GASのバリバリコーディングしていきましょう！と言いたいところですが、\nGASをコーディングするにはJavaScriptの基礎構文や制御構文を理解できているか否かで、できることの幅が大きく変わってきます。\nそこで、次章では JavaScript基礎編 と題しまして、GASの実行環境でJavaScriptを動かしながら学んでいきます。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/page_2_1_7/",
	"title": "オブジェクト",
	"tags": [],
	"description": "",
	"content": "オブジェクトとは 複数のデータを扱う方法として配列について説明をしましたが、JavaScriptには他にも複数のデータの集合を扱う方法があります。\nそれが オブジェクト です。（連想配列やハッシュとも呼ばれています。）\nオブジェクトは下記のようにプロパティと値の間をコロン（:）で繋いだ組み合わせをカンマ区切りで記述し、全体を波括弧（{}）で囲むことで生成できます。\nこの表記方法を オブジェクトリテラル といいます。\n{ プロパティ1: 値1, プロパティ2: 値2 } 配列ではインデックスをキーにしてその要素を参照したり、代入したりすることができました。\n一方、オブジェクトでは プロパティ をキーにすることで、同様に要素への参照や代入を行うことができます。\n下記の図のように複数の入れ物に、それぞれ名前がつけている構造です。\nそれぞれの入れ物につけられている名前がプロパティとなります。\nオブジェクトは文字列であるプロパティをキーにしてデータにアクセスできるので、配列と比べると可読性の高いデータ構造と言うことができます。\n＜図を追加する＞\n図の配列を初期化するスクリプトは下記のよう記述することができます。\nvar person = {name: \u0026#39;Taro\u0026#39;, age: 22, gendar: \u0026#39;male\u0026#39;};  プロパティには数値や文字列などのデータのほか、関数を格納することができます。関数を格納されたプロパティはメソッドといいます。\n プロパティの参照と代入 オブジェクトから値を取り出す方法は２つあります。\n1つ目はドット（.）でプロパティを指定する ドット記法 、もう一つが角括弧（[]）内に文字列のプロパティで指定する ブラケット記法 です。\n// ドット記法 オブジェクト名.プロパティ // ブラケット記法 オブジェクト名[\u0026#39;プロパティ\u0026#39;] 下記のサンプルではドット記法とブラケット記法でプロパティで値を取得してログに出力しています。\nfunction outputObject_1() { var person = {name: \u0026#39;Taro\u0026#39;, age: 22, gendar: \u0026#39;male\u0026#39;}; console.log(person.name); // Taro  console.log(person.age); // 22 } 一般的にドット記法の方が単純に記述できて可読性も高いので、どちらでもよい場合はドット記法を使うことがおすすめです。\n一方で、ブラケット記法は変数を使用してプロパティの指定ができることがメリットと言えます。\nfor in 文 によるループ内でプロパティの値を取り出す際などはブラケット記法が有効です。\n いずれの記法でも下記のようにイコール（=）を使うことで指定したプロパティの値を代入することができます。\nまた、オブジェクトに存在しないプロパティを指定して代入をするとオブジェクトにプロパティと値が追加されます。\n// ドット記法 オブジェクト名.プロパティ = 値; // ブラケット記法 オブジェクト名[\u0026#39;プロパティ\u0026#39;] = 値; function outputObject_2() { var person = {name: \u0026#39;Taro\u0026#39;, age: 22, gendar: \u0026#39;male\u0026#39;}; person.name = \u0026#39;Hanako\u0026#39;; person[\u0026#39;gendar\u0026#39;] = \u0026#39;female\u0026#39;; person.job = \u0026#39;Engineer\u0026#39;; console.log(person); // {name=\u0026#39;Taro\u0026#39;, age=22, gendar=\u0026#39;female\u0026#39;, job=\u0026#39;Engineer\u0026#39;} }  存在しないプロパティから値を取り出そうとすると、その値はundefinedとなります。\n "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/page_2_1_8/",
	"title": "演算子",
	"tags": [],
	"description": "",
	"content": "算術演算子とは 演算子 は値や変数などに対して、処理を行うための記号です。\n演算子にはいくつか種類があり、そのうちのひとつの 算術演算子 は、四則演算子など計算を行うための演算子です。\n下記にJavaScriptで一般的に使用する算術演算子をまとめています。\n   演算子 概要 使用例     + 数値の加算または文字列の連結 1 + 2, \u0026lsquo;a\u0026rsquo; + \u0026lsquo;bc\u0026rsquo;   - 数値の減算または符号の反転 3 - 1, -(-1)   * 数値の乗算 10 * 2   / 数値の徐算 10 / 2   % 数値の剰余 11 % 3    function outputCalculate_1() { var x = 11; var y = 4; console.log(x + y); // 15  console.log(x - y); // 7  console.log(x * y); // 44  console.log(x / y); // 2.75  console.log(x % y); // 2  console.log(-x); // -11 } 式の中に複数の演算が含まれている場合、数学での演算と同様に加減よりも乗除の方が優先して処理されます。\n優先順位が同列である場合は左に記述されている順に処理されます。\nまた、この優先順位は丸括弧を使用することで任意で変えることができます。各演算子の優先順位は下記の通りです。\n   演算子 優先順位 処理の内容     () 1 丸括弧   - 2 符号を反転   * 3 乗算   / 3 徐算   % 3 剰余   + 4 数値の加算   + 4 文字列の連結   - 4 減算    「+」による演算は、演算対象の値が どちらか一方が文字列である場合は文字列の連結 を行い、共に数値である場合は加算 を行います。\nこの処理がどの段階で行われるかは下記のサンプルを実行して確認してみましょう。\nfunction outputCalculate_2() { console.log(1 + 2); // 3  console.log(1 + \u0026#39;2\u0026#39;); // 12  console.log(1 + 2 + \u0026#39;3\u0026#39;); // 33  console.log(1 + \u0026#39;2\u0026#39; + 3); // 123 } インクリメント演算子とデクリメント演算子 JavaScriptには数値を1だけ加算する インクリメント演算子 と 数値を1だけ減算する デクリメント演算子 があります。\n   演算子 処理の内容     ++ インクリメント（1だけ加算）   \u0026ndash; デクリメント（1だけ減算）    インクリメント演算子とデクリメント演算子は 演算対象となる変数の値自体を変更します。\nそのため、下記の表の通りこの演算子を使用することで省略して書くことができます。\n   省略後の書き方 省略前の書き方     x++ x = x + 1   x\u0026ndash; x = x - 1    下記のサンプルを記述したのち実行して確認してみましょう。\nfunction outputCalculate_3() { var x = 10; x++; // インクリメント  console.log(x); // 11  x--; // デクリメント  console.log(x); // 10 } インクリメント演算子やデクリメント演算子は「++x」のように変数の前に演算子を書く方法と、\n「x++」のように変数の後に演算子を書く方法の2つがあります。\n実はこの2つの書き方ではそれぞれ値を返すタイミングが異なります。\n ++xと\u0026ndash;xの場合：変数をインクリメント・デクリメントした値を返す。 x++とx\u0026ndash;の場合：変数の値を返したのち、インクリメント・デクリメントをする。  それぞれの違いについては下記のサンプルで確認をしてみましょう。\nfunction outputCalculate_4() { var x = 1; var y = 10; console.log(++x); // 2  console.log(x); // 2  console.log(y++); // 10  console.log(y); // 11 } 「++x」のログ出力はインクリメントされた後の値が出力されます。\n一方、「y++」のログ出力はインクリメントされる前の値が出力され、その後にインクリメントされていることが確認できます。\n代入演算子 代入演算子 とは、変数に値を代入する演算子です。ここまで登場してきました「=」も代入演算子です。\nまた、代入演算子には代入と同時に処理を行う複合代入演算子が存在しています。\n   代入演算子 概要 使用例     = 左辺の変数に値を代入 x = 10   += 左辺の変数に右辺の値を加算して代入 x += 10   -= 左辺の変数に右辺の値を減算して代入 x -= 10   *= 左辺の変数に右辺の値を乗算して代入 x *= 10   /= 左辺の変数に右辺の値を徐算して代入 x /= 10   %= 左辺の変数に右辺の値で徐算した剰余を代入 x %= 10    複合代入演算子はそれぞれ下記の記法で表現することができ、使用することでスクリプトをシンプルに記述することができます。\n   省略後の書き方 省略前の書き方     x += 1 x = x + 1   x -= 1 x = x - 1   x *= 1 x = x * 1   x /= 1 x = x / 1   x %= 1 x = x % 1    下記のサンプルを記述し、実行して確認してみましょう。\nfunction outputCalculate_5() { var x = 1; var y = 10; x += 5; console.log(x); // 6  y *= 5; console.log(y); // 50 }  演算子には算術演算子や代入演算子の他にも存在し、比較演算子や論理演算子があります。\n "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/javascript_bases/basic_syntax/page2_1_9/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "JavaScriptの基本構文、変数、データ型、演算子について解説しました。\n配列とオブジェクトは直感的にイメージするのが難しいと思いますが、GASでは重量な役割を果たしていますのでしっかり理解をしておきましょう。\nここまでは書かれている順番にステートメントを上から順番に実行する「順次処理」のみを紹介してきましたが、\n実際のプログラミングは途中で処理を分岐したり、同じ処理を何度も繰り返したりします。\n次のチャプターではこのようなより多様な処理パターンである「条件分岐処理」と「繰返処理」のコーディング方法について学んでいきましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/sheets/page_7/",
	"title": "最後に",
	"tags": [],
	"description": "",
	"content": "GASでのスプレッドシートの操作、およびSpreadsheetサービスの基本となるクラスについて解説してきました。\nスプレッドシートはGASによるシステムではデータベースとしての役割を果たしますので、ぜひ活用してください。\nいよいよ、次はGASでWebアプリケーションを作ってみましょう。\n"
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/",
	"title": "GAS Edu",
	"tags": [],
	"description": "",
	"content": "GAS Edu 本コンテンツはGAS初心者向けのハンズオン形式の教材となります。\nコンテンツ一覧 ※ 未公開のコンテンツは随時更新予定\n   No. コンテンツ名 ステータス     1 入門編 公開済   2 JavaScript基礎編 公開済   3 スプレッドシート編 公開済   4 Webアプリ編 公開済   5 ローカル開発編 公開済    "
},
{
	"uri": "https://a-nakamura1015.github.io/gas-education/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]